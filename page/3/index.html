<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kaiktang.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1}},"activeClass":"disqus"},"algolia":{"appID":"FBQ33HXA0Q","apiKey":"5a256d1a0d5075a6a17b29fbae8cdbdc","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="学而后知不足">
<meta property="og:type" content="website">
<meta property="og:title" content="kaiktang&#39;s blogs">
<meta property="og:url" content="http://kaiktang.github.io/page/3/index.html">
<meta property="og:site_name" content="kaiktang&#39;s blogs">
<meta property="og:description" content="学而后知不足">
<meta property="og:locale">
<meta property="article:author" content="kaiktang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://kaiktang.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>kaiktang's blogs</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8714a47efb513991b4862eafeadb6a3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kaiktang's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2019/07/28/Vim%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/28/Vim%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">Vim实用技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-28 15:39:53" itemprop="dateCreated datePublished" datetime="2019-07-28T15:39:53+08:00">2019-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-07 20:11:39" itemprop="dateModified" datetime="2022-02-07T20:11:39+08:00">2022-02-07</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2019/07/28/Vim%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/07/28/Vim实用技巧/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文章主要用来记录一些平时不常用的命令，以期望自己能够在未来能够熟练自然的使用，提升开发效率。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/07/28/Vim%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/11/18/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/18/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">Go语言中的比较运算符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-18 14:53:15" itemprop="dateCreated datePublished" datetime="2018-11-18T14:53:15+08:00">2018-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-06 15:00:14" itemprop="dateModified" datetime="2019-01-06T15:00:14+08:00">2019-01-06</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/11/18/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/18/Go语言中的比较运算符/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go语言中的比较运算符"><a href="#Go语言中的比较运算符" class="headerlink" title="Go语言中的比较运算符"></a>Go语言中的比较运算符</h1><h2 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="keyword">struct</span>&#123; name <span class="type">string</span> &#125;&#123;<span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line">    t := T&#123;<span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line">    fmt.Println(s == t)  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">rune</span> = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">fmt.Println(a == b) <span class="comment">//invalid operation: a == b (mismatched types int and rune)</span></span><br></pre></td></tr></table></figure>
<h2 id="等于和不等于运算符"><a href="#等于和不等于运算符" class="headerlink" title="等于和不等于运算符"></a>等于和不等于运算符</h2><p>要求操作数是可比较的。在Go的官方声明中如下说道：</p>
<ul>
<li>boolean是可比较的。</li>
<li>整数和浮点数也是可以比较的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> c <span class="type">float32</span> = <span class="number">3.3</span></span><br><span class="line"><span class="keyword">var</span> d <span class="type">float32</span> = <span class="number">4.4</span></span><br><span class="line">fmt.Println(a == b) <span class="comment">// false</span></span><br><span class="line">fmt.Println(c == d) <span class="comment">// false</span></span><br><span class="line">fmt.Println(a == d) <span class="comment">// mismatched types int and float32</span></span><br></pre></td></tr></table></figure>
<ul>
<li>复数仅当他们的实数部分和虚数部分均相等才会返回相等。</li>
<li>字符串是可比较的。</li>
<li>指针在当均为nil或者都指向同一个变量的时候返回true。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := T&#123;<span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line">    t2 := T&#123;<span class="string">&quot;bar&quot;</span>&#125;</span><br><span class="line">    p1 := &amp;t1</span><br><span class="line">    p2 := &amp;t1</span><br><span class="line">    p3 := &amp;t2</span><br><span class="line">    fmt.Println(p1 == p2)   <span class="comment">// true</span></span><br><span class="line">    fmt.Println(p2 == p3)   <span class="comment">// false</span></span><br><span class="line">    fmt.Println(p3 == <span class="literal">nil</span>)  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：不占内存的变量的地址可能返回true或者false，我们不能依赖它的结果。</p>
</blockquote>
<ul>
<li><code>channel</code>只有当他们均为nil或者均是同一个make生成时才会相等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">fmt.Println(ch1 == ch2)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接口类型是可比较的。和channel和指针类型一样，两个接口类型仅当他们都是nil或者动态类型和动态值均相等时才相等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    m()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> J <span class="keyword">interface</span> &#123;</span><br><span class="line">    m()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> m() &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> U <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(U)</span></span> m() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i1, i2, i3, i4 I</span><br><span class="line">    <span class="keyword">var</span> j1 J</span><br><span class="line">    i1 = T&#123;<span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line">    i2 = T&#123;<span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line">    i3 = T&#123;<span class="string">&quot;bar&quot;</span>&#125;</span><br><span class="line">    i4 = U&#123;<span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line">    fmt.Println(i1 == i2)  <span class="comment">// true</span></span><br><span class="line">    fmt.Println(i1 == i3)  <span class="comment">// false</span></span><br><span class="line">    fmt.Println(i1 == i4)  <span class="comment">// false</span></span><br><span class="line">    fmt.Println(i1 == j1)  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>被比较的接口类型的方法集不能不相交。</p>
</blockquote>
<ul>
<li>类型为接口类型I的变量i和非接口类型T之间是可比较的，当且仅当T实现了I并且T的值是可比较的。他们仅当他们的动态类型和动态值都是相等的时候才会相等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> I <span class="keyword">interface</span> &#123;</span><br><span class="line">    m()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span></span> m() &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> S <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(S)</span></span> m() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T&#123;&#125;</span><br><span class="line">    s := S&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> i I</span><br><span class="line">    i = T&#123;&#125;</span><br><span class="line">    fmt.Println(t == i)  <span class="comment">// true</span></span><br><span class="line">    fmt.Println(s == i)  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体之间也是可以比较的，要求所有的字段都可比较，但是只要求所有的非空字段都相等即可算作相等。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    _ <span class="type">int32</span></span><br><span class="line">&#125;&#123;name: <span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line">b := <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">    _ <span class="type">int32</span></span><br><span class="line">&#125;&#123;name: <span class="string">&quot;foo&quot;</span>&#125;</span><br><span class="line">fmt.Println(a == b)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于数组，他们的元素类型需要可比较而且对应的元素是相等的，就会返回相等。</li>
</ul>
<p>有三个类型是不可比较的：<code>map</code>、<code>slice</code>、<code>function</code>，如果被用来比较将会抛出错误“map can only be compared to nil.”</p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>这些运算符也只能被用在三种类型上：整数、浮点数和字符串。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/11/18/Practical-Go-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/18/Practical-Go-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/" class="post-title-link" itemprop="url">Practical Go 学习心得</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-18 14:53:15" itemprop="dateCreated datePublished" datetime="2018-11-18T14:53:15+08:00">2018-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-06 14:57:21" itemprop="dateModified" datetime="2019-01-06T14:57:21+08:00">2019-01-06</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/11/18/Practical-Go-%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/18/Practical-Go-学习心得/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Practical-Go-学习心得"><a href="#Practical-Go-学习心得" class="headerlink" title="Practical Go 学习心得"></a>Practical Go 学习心得</h1><p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_introduction">Practical Go: Real world advice for writing maintainable Go programs</a></p>
<h1 id="Go编程的原则"><a href="#Go编程的原则" class="headerlink" title="Go编程的原则"></a>Go编程的原则</h1><ol>
<li>简单性</li>
<li>可读性</li>
<li>生产力</li>
</ol>
<h1 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h1><p>好的变量命名应该有如下几个特质：</p>
<ol>
<li>简洁（concise）</li>
<li>表达力强（descriptive）：应该介绍变量的应用而不是变量的内容。</li>
<li>可预测的（predictable）：应该能够从变量名中猜测出他大概的用法。</li>
</ol>
<h2 id="变量名的长度"><a href="#变量名的长度" class="headerlink" title="变量名的长度"></a>变量名的长度</h2><blockquote>
<p>一个变量使用的地方离它声明的地方越远，那么它变量名的长度就应该越长。</p>
</blockquote>
<ol>
<li>当变量的最近一次使用和它的声明离得很近，那么短变量名也是可以接受的。</li>
<li>变量的长度越长提供的信息就应该更多。</li>
<li>变量的名字中不要包含变量的类型信息，比如：userMap等</li>
<li>常量应该用来描述它们所持有的值，而不是它的用法。</li>
<li>分支和循环变量使用单字母变量名。函数参数和返回值使用单个单词的变量名。包级变量的变量名应该由多个单词组成。</li>
<li>方法名、包名和接口名应该使用单个单词。</li>
<li>记住当使用包内的资源的时候，调用者必须要加上包名，所以可以好好利用包名。</li>
</ol>
<h2 id="上下文是关键"><a href="#上下文是关键" class="headerlink" title="上下文是关键"></a>上下文是关键</h2><p>比如一个代表数组下标的变量，在作为循环变量的时候使用i就挺好，而在函数中作为参数的时候，可能使用index会更具表现力。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SNMP)</span></span> Fetch(oid []<span class="type">int</span>, index <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<h2 id="使用一致的声明风格"><a href="#使用一致的声明风格" class="headerlink" title="使用一致的声明风格"></a>使用一致的声明风格</h2><ul>
<li><p>当仅仅声明而不初始化一个变量的时候，使用<code>var</code>。当声明一个会在函数中被显式声明的变量的时候，使用<code>var</code>关键字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players <span class="type">int</span>    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> things []Thing <span class="comment">// an empty slice of Things</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing Thing    <span class="comment">// empty Thing struct</span></span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当在声明的同时初始化了变量的时候，应该使用<code>:=</code>。明确告诉读者，我们不要零值。</p>
</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ol>
<li><p>注释应该解释这段代码做了什么事情。</p>
<ul>
<li>这种适合在public的代码外标注</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open opens the named file for reading.</span></span><br><span class="line"><span class="comment">// If successful, methods on the returned file can be used for reading.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释应该解释这段代码是怎么做的这些事。</p>
<ul>
<li>这种一般适合在方法内部标注</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queue all dependant actions</span></span><br><span class="line"><span class="keyword">var</span> results []<span class="keyword">chan</span> <span class="type">error</span></span><br><span class="line"><span class="keyword">for</span> _, dep := <span class="keyword">range</span> a.Deps &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, execute(seen, dep))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释应该解释这段代码为什么要做这些事。</p>
<ul>
<li>这种类型的注释是不能被前两种所取代的，同时也不能取代前两种。主要用来解释导致执行这段代码的外部因素。注释用来解释上下文。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;v2.Cluster_CommonLbConfig&#123;</span><br><span class="line">	<span class="comment">// Disable HealthyPanicThreshold</span></span><br><span class="line">        HealthyPanicThreshold: &amp;envoy_type.Percent&#123;</span><br><span class="line">        	Value: <span class="number">0</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，注释解释了将Value设为0，将会导致使HealthyPanicThreshold失效。</p>
</li>
</ol>
<h2 id="变量和常量上的注释应该描述他们的内容而不是他们的目的"><a href="#变量和常量上的注释应该描述他们的内容而不是他们的目的" class="headerlink" title="变量和常量上的注释应该描述他们的内容而不是他们的目的"></a>变量和常量上的注释应该描述他们的内容而不是他们的目的</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StatusContinue           = <span class="number">100</span> <span class="comment">// RFC 7231, 6.2.1</span></span><br><span class="line">    StatusSwitchingProtocols = <span class="number">101</span> <span class="comment">// RFC 7231, 6.2.2</span></span><br><span class="line">    StatusProcessing         = <span class="number">102</span> <span class="comment">// RFC 2518, 10.1</span></span><br><span class="line"></span><br><span class="line">    StatusOK                 = <span class="number">200</span> <span class="comment">// RFC 7231, 6.3.1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>对于那些没有初始值的变量，注释应该说明谁负责初始化该变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeCalculationDisabled indicates whether it is safe</span></span><br><span class="line"><span class="comment">// to calculate Types&#x27; widths and alignments. See dowidth.</span></span><br><span class="line"><span class="keyword">var</span> sizeCalculationDisabled <span class="type">bool</span></span><br></pre></td></tr></table></figure>
<p>上例中就告诉读者，dowidth方法负责维护该变量的状态。</p>
<h2 id="始终为公共符号写文档"><a href="#始终为公共符号写文档" class="headerlink" title="始终为公共符号写文档"></a>始终为公共符号写文档</h2><ul>
<li>任何除了又明显又短的公开方法都必须写注释。</li>
<li>任何在库中的方法都需要被注释，无论复杂度和长度。</li>
<li>不需要为那些实现自接口的的方法写注释。</li>
</ul>
<blockquote>
<p>在写一个方法之前先写注释去描述这个方法。如果你发现很难写出注释，那么意味着你将写出难懂的代码。</p>
</blockquote>
<h2 id="不要为糟糕的代码写注释，重写它"><a href="#不要为糟糕的代码写注释，重写它" class="headerlink" title="不要为糟糕的代码写注释，重写它"></a>不要为糟糕的代码写注释，重写它</h2><p>当发现问题的时候，使用TODO来标记提醒自己未来去修复他。</p>
<blockquote>
<p>// TODO(dfc) this is O(N^2), find a faster way to do this.</p>
</blockquote>
<h2 id="如果需要注释一大段代码，不如重构它"><a href="#如果需要注释一大段代码，不如重构它" class="headerlink" title="如果需要注释一大段代码，不如重构它"></a>如果需要注释一大段代码，不如重构它</h2><p>好的代码不需要注释也能看懂。</p>
<p>一个函数应该只做一件事情，如果你正在为一段和其他函数不太相关的代码写注释，你可能需要提取这些代码为函数。</p>
<p>当函数被拆分的小而专精时，函数名就已经是最好的注释。</p>
<h1 id="包的设计"><a href="#包的设计" class="headerlink" title="包的设计"></a>包的设计</h1><p>模块之间应该不暴露任何不重要的东西，并且他们不依赖其他模块的实现。</p>
<p>一个好的Go的包应该努力降低源码的耦合度，降低修改代码时带来的级联的影响。</p>
<h2 id="一个好的设计应该从包名开始"><a href="#一个好的设计应该从包名开始" class="headerlink" title="一个好的设计应该从包名开始"></a>一个好的设计应该从包名开始</h2><p>包名应该体现它提供了什么，而不是它包含了什么</p>
<h3 id="好的包名应该（在项目内）是唯一的"><a href="#好的包名应该（在项目内）是唯一的" class="headerlink" title="好的包名应该（在项目内）是唯一的"></a>好的包名应该（在项目内）是唯一的</h3><p>包名应该来自该设计该包的目的，如果你发现两个包需要相同的名称，那么可能：</p>
<ol>
<li>包的名称太泛指。</li>
<li>两个包可能功能有重叠，考虑合并两个包。</li>
</ol>
<h3 id="避免像base，common或者util这样的包名"><a href="#避免像base，common或者util这样的包名" class="headerlink" title="避免像base，common或者util这样的包名"></a>避免像<code>base</code>，<code>common</code>或者<code>util</code>这样的包名</h3><p>这样的包一般都是为了共用工具方法避免循环引用而创建的。</p>
<p>建议应该通过分析这些工具方法他们都是在哪里被调用的，然后尝试把他们移到他们调用者的包里去。即使这样会涉及一些复制重复代码，但是这也比在两个包之间引入依赖要好。</p>
<blockquote>
<p>一些小重复代码比错误的抽象好太多。</p>
</blockquote>
<p>对于那些真正提供工具的包，建议使用负数的名称，比如：<code>strings</code>等。</p>
<p>比如，像<code>net/http</code>包，并没有包含<code>client</code>和<code>server</code>这样的子包，而是包含<code>client.go</code>和<code>server.go</code>这样的文件，每个文件里面都有他们各自的类型，还有一个<code>tansport.go</code>文件，这里面包含了通用的消息传输的代码。</p>
<blockquote>
<p>注意：一个标识符包含了包名。</p>
<ul>
<li>比如<code>net/http</code>包内的<code>Get</code>方法当在外部被访问的时候，应该是<code>http.Get</code>。</li>
<li><code>strings</code>包里的<code>Reader</code>类型被别的包引入的时候变为了<code>strings.Reader</code>。</li>
<li><code>net</code>包里的<code>Error</code>接口很明显是关于网络的错误。</li>
</ul>
</blockquote>
<h2 id="应该早点return而不是更深的嵌套"><a href="#应该早点return而不是更深的嵌套" class="headerlink" title="应该早点return而不是更深的嵌套"></a>应该早点return而不是更深的嵌套</h2><ul>
<li><p>早return的风格</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span></span> UnreadRune() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.lastRead &lt;= opInvalid &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.off &gt;= <span class="type">int</span>(b.lastRead) &#123;</span><br><span class="line">		b.off -= <span class="type">int</span>(b.lastRead)</span><br><span class="line">	&#125;</span><br><span class="line">	b.lastRead = opInvalid</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种风格能够保证成功路径的代码随着判断条件的增多是一直垂直向下延伸的。</p>
</li>
<li><p>嵌套的风格</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span></span> UnreadRune() <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.lastRead &gt; opInvalid &#123;</span><br><span class="line">		<span class="keyword">if</span> b.off &gt;= <span class="type">int</span>(b.lastRead) &#123;</span><br><span class="line">			b.off -= <span class="type">int</span>(b.lastRead)</span><br><span class="line">		&#125;</span><br><span class="line">		b.lastRead = opInvalid</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot;bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种风格的代码会导致成功路径的代码随着判断条件的增多不断地被向右移动。这样风格的代码让条件判断和返回语句离得太远，这样让维护者或者读者阅读更加困难。</p>
</li>
</ul>
<h2 id="利用零值"><a href="#利用零值" class="headerlink" title="利用零值"></a>利用零值</h2><p>比如<code>sync.Mutex</code>类型包含了两个没有导出的整数字段，代表了互斥信号量的内部状态，作者充分利用了数值类型零值为0的特点，使得<code>sync.Mutex</code>类型被使用的时候不需要被显式的初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu  sync.Mutex</span><br><span class="line">	val <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i MyInt</span><br><span class="line"></span><br><span class="line">	<span class="comment">// i.mu is usable without explicit initialisation.</span></span><br><span class="line">	i.mu.Lock()</span><br><span class="line">	i.val++</span><br><span class="line">	i.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个例子是<code>bytes.Buffer</code>这个类型，你可以不用显式初始化它，只需要声明它就能使用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">	b.WriteString(<span class="string">&quot;Hello, world!\n&quot;</span>)</span><br><span class="line">	io.Copy(os.Stdout, &amp;b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于在runtime包里定义的slice类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">        array *[...]T <span class="comment">// pointer to the underlying array</span></span><br><span class="line">        <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">        <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// s := make([]string, 0)</span></span><br><span class="line">	<span class="comment">// s := []string&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> s []<span class="type">string</span></span><br><span class="line"></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">	fmt.Println(strings.Join(s, <span class="string">&quot; &quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是注意注释里的两种方式出来的变量虽然都是零值，但是不相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 = []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> s2 []<span class="type">string</span></span><br><span class="line">	fmt.Println(reflect.DeepEqual(s1, s2)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于未初始化的变量虽然为nil，可以非常方便的提供默认值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	path <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Config)</span></span> Path() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;/usr/home&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c1 *Config</span><br><span class="line">	<span class="keyword">var</span> c2 = &amp;Config&#123;</span><br><span class="line">		path: <span class="string">&quot;/export&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(c1.Path(), c2.Path())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免包级别的状态"><a href="#避免包级别的状态" class="headerlink" title="避免包级别的状态"></a>避免包级别的状态</h2><p>有两个非常棒的方式来达到降低耦合度：</p>
<ol>
<li>使用接口。</li>
<li>避免使用全局变量。</li>
</ol>
<p>使用开放的全局变量会使得该变量非常容易被修改，导致不稳定因素。</p>
<p>如果你想要解决全局变量带来的耦合，可以通过：</p>
<ol>
<li>将一个结构体依赖的相关的变量放到它的成员变量里面。</li>
<li>使用接口来屏蔽实现，降低耦合。</li>
</ol>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>一个包应该有一个清晰的目标。如果你的 项目是一个库，那么应该提供只提供一件事，比如说解析XML或者日志库。你应该避免将多个不同目的的包合并进一个单独的包，这会帮助你避免产生类似<code>common</code>这样的库。</p>
<h2 id="考虑使用更少但是更大的包"><a href="#考虑使用更少但是更大的包" class="headerlink" title="考虑使用更少但是更大的包"></a>考虑使用更少但是更大的包</h2><p>和其他语言不同，Go语言里面只有两种访问控制符，public和private，所以当一个功能被拆到多个包里的时候，势必会导致很多接口都被迫的被开放为Public，而且这样的API层次太浅，并不是面向用户的。</p>
<p>所以推荐使用更少，更大的包来放所有相关的功能。要求每个文件夹内都应该有源代码，除了<code>cmd</code>等。</p>
<h3 id="通过import语句来组织代码"><a href="#通过import语句来组织代码" class="headerlink" title="通过import语句来组织代码"></a>通过import语句来组织代码</h3><p>如果你是根据代码为调用者提供的内容来组织包，那么你是否也应该同样来组织包内的文件呢？</p>
<p>你怎么知道什么时候将代码分散到多个<code>.go</code>文件中，你怎么知道你是否拆的太过，应该合并几个为一个<code>.go</code>文件呢？</p>
<ul>
<li>每个包先从一个<code>.go</code>文件开始。并且让这个文件的文件名和包名一致。比如：<code>http</code>包对应的文件下下应该有个<code>http.go</code>文件。</li>
<li>当你的包逐渐变大，你应该决定是否将不同的职责拆分到不同的文件中去。比如：<code>messages.go</code>里面包含<code>Request</code>和<code>Response</code>类型，<code>client.go</code>包含<code>Client</code>类型，<code>server.go</code>里面包含了<code>Server</code>类型。</li>
<li>当你发现你的几个文件中有着相似的<code>import</code>声明，那么考虑将他们合并。</li>
<li>不同的文件应该负责包中不同的领域的工作。</li>
</ul>
<blockquote>
<p>推荐使用名词来作为源代码文件的名称。</p>
<p>注意：Go的编译器在编译的时候会并行的编译各个包。而在每个包内，编译器会并行的编译各个方法。所以改变包内的代码结构并不会影响编译时间。</p>
</blockquote>
<h3 id="多用内部测试，而不是外部测试"><a href="#多用内部测试，而不是外部测试" class="headerlink" title="多用内部测试，而不是外部测试"></a>多用内部测试，而不是外部测试</h3><p>go工具支持把你的<code>testing</code>包放在两个地方。</p>
<ul>
<li>假设你的包叫<code>http2</code>，你可以把<code>http2_test.go</code>文件放到包内，那么编译的时候会把该文件作为包的一部分被编译进去，这被称为“内部测试”。</li>
<li>也可以使用一个以test结尾的特殊的包名，比如<code>http_test</code>包，这样在编译的时候，测试代码仿佛就是用户从外部调用接口，这样的方式被称为“外部测试”。</li>
</ul>
<p>建议使用内部测试来写单元测试，这可以使你能够直接的测试那些方法，而不用从外部引用。</p>
<p>但是你应该把你的样例测试代码放到外部的包中，因为这样在生成文档的时候，测试代码中有着正确的包名前缀，方便直接复制来用。</p>
<h3 id="使用internal包来减少开放的API"><a href="#使用internal包来减少开放的API" class="headerlink" title="使用internal包来减少开放的API"></a>使用<code>internal</code>包来减少开放的API</h3><p>如果你的项目包含了很多包，他们的接口只希望将接口暴露给其他本项目内的包的时候。你可以使用<code>interna/</code>这样一个特殊的目录，放在里面的代码对于本项目是public的，但是对于其他项目是private的。</p>
<p>为了创建这样一个包，应该将目录命名为<code>internal</code>或者一个名为<code>internal</code>的目录下。当go命令看到导入了一个包路径中包含<code>internal</code>，那么这代表这个包仅仅是在internal的父目录域下可见。</p>
<p>比如：<code>.../a/b/c/internal/d/e/f</code>只能被在<code>/a/b/c</code>目录下的代码所导入，而不能被<code>.../a/b</code>或者<code>.../a</code>或者其他仓库所导入。</p>
<h2 id="让包内的main越小越好"><a href="#让包内的main越小越好" class="headerlink" title="让包内的main越小越好"></a>让包内的main越小越好</h2><p>因为<code>main.main</code>是一个单例，只会被执行一次，而且对于在main函数内的逻辑很难写单元测试，所以建议让main函数内的逻辑越少越好。</p>
<blockquote>
<p>main应该用来解析flags，开放对数据库，日志的连接，然后将执行交给更高层次的对象。</p>
</blockquote>
<h1 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h1><p>对于上面提到的建议其实都可以不那么严格，因为这些都是可以在不影响向下兼容性的情况下被修复。但是API的设计需要更加严谨， 因为一旦有用户已经在使用这些API，那么这些API就不能再动了。</p>
<h2 id="将API设计成很难用错"><a href="#将API设计成很难用错" class="headerlink" title="将API设计成很难用错"></a>将API设计成很难用错</h2><p>API应该很容易使用而且很难被用错。</p>
<h3 id="注意那些接收几个相同类型参数的函数"><a href="#注意那些接收几个相同类型参数的函数" class="headerlink" title="注意那些接收几个相同类型参数的函数"></a>注意那些接收几个相同类型参数的函数</h3><p>让我们比较一下下面这两个方法签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(to, from <span class="type">string</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>对于Max方法，两个参数是可交换的，但是对于CopyFile的两个参数顺序不同将会导致完全不同的行为，而检查CopyFile是否被正确使用只能通过查阅文档。</p>
<p>解决这个问题的一种方式为：使用一个helper类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Source <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(src Source)</span></span> CopyTo(dest <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> CopyFile(dest, <span class="type">string</span>(src))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> from Source = <span class="string">&quot;presentation.md&quot;</span></span><br><span class="line">	from.CopyTo(<span class="string">&quot;/tmp/backup&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那些接收相同类型参数的函数非常容易被用错。</p>
</blockquote>
<h2 id="为默认用例设计API"><a href="#为默认用例设计API" class="headerlink" title="为默认用例设计API"></a>为默认用例设计API</h2><p>你不应该要求调用者提供他们不关心的参数。</p>
<h3 id="不建议使用nil作为参数"><a href="#不建议使用nil作为参数" class="headerlink" title="不建议使用nil作为参数"></a>不建议使用nil作为参数</h3><p>以<code>net/http</code>包为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span> &#123;</span><br></pre></td></tr></table></figure>
<p><code>ListenAndServe</code>接收两个参数，第一个为监听请求来源的TCP地址，第二个参数用来处理接收到的HTTP请求。第二个参数可以为nil，代表应该使用<code>http.DefaultServeMux</code>作为默认handler。</p>
<p>也就是下面两种写放做的事情是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p><code>http</code>包内有一个<code>http.Serve</code>方法，分别接受<code>listener</code>和<code>handler</code>。事实上，就是它实现了如果handler为nil，那么使用DefaultServeMux的逻辑。所以可以想象<code>ListenAndServe</code>的实现大概是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="type">string</span>, handler Handler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	l, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> l.Close()</span><br><span class="line">	<span class="keyword">return</span> Serve(l, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不推荐在同一个方法签名中同时出现可为nil和不为nil的参数。</p>
<p>对于上例，不建议使用下面两种写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">&quot;/htdocs&quot;</span>)</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// and</span></span><br><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">&quot;/htdocs&quot;</span>)</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>建议使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">&quot;/htdocs&quot;</span>)</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>避免在public API中设置只为测试使用的参数。</p>
<p>应该使用public的包装类来隐藏这些参数，然后使用test范围里的helper类来设置这个属性。</p>
<p>TomKK：因为test代码应该是在和待测试的方法在同一个包内可以访问私有属性，这样对于用户屏蔽了这些测试属性，又可以修改他们。</p>
</blockquote>
<h3 id="推荐使用可变数量参数而不是切片类型"><a href="#推荐使用可变数量参数而不是切片类型" class="headerlink" title="推荐使用可变数量参数而不是切片类型"></a>推荐使用可变数量参数而不是切片类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownVMs</span><span class="params">(ids []<span class="type">string</span>)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>像上面这种签名的函数，可能被调用的时候只需要传入一个参数，但是调用者必须将这一个参数强行包装成slice然后传入，这样非常不友好。而且slice类型的参数是能够接受nil的，这样会让函数多出一些多余的判断逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> svc.MaxConnections &gt; <span class="number">0</span> || svc.MaxPendingRequests &gt; <span class="number">0</span> || svc.MaxRequests &gt; <span class="number">0</span> || svc.MaxRetries &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// apply the non zero parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码的书写方式，会随着需要判断的参数的增长而越来越长，通过可变数量参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anyPostive indicates if any value is greater than zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyPositive</span><span class="params">(values ...<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个函数能够非常好的减少判断语句，让程序语句变的更加优雅：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) &#123;</span><br><span class="line">        <span class="comment">// apply the non zero parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，因为动态参数的限制，用户可以这样调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> anyPositive() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这样这个函数就会恒返回false，如果这样的调用是不允许的，那么我们可以通过修改函数签名来让编译器为我们限制用户的行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anyPostive indicates if any value is greater than zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyPositive</span><span class="params">(first <span class="type">int</span>, rest ...<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> first &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> rest &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="让函数自己定义他们需要的行为"><a href="#让函数自己定义他们需要的行为" class="headerlink" title="让函数自己定义他们需要的行为"></a>让函数自己定义他们需要的行为</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the file f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(f *os.File, doc *Document)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>像这样的函数就是很不好的，有如下几个弊端：</p>
<ol>
<li>如果未来不只想要将文件写入磁盘文件中，而是想要将文件写入网络，那么就需要修改函数的签名影响所有的调用者。</li>
<li>该函数签名也很不利于写测试用例，因为我们每次都会生成文件，并且需要保证文件被写入一个临时目录并且在每次测试后将临时文件删除。并且为了验证该测试用例，在将内容输出到磁盘后，我们必须再次读取文件的内容，这样才能证明测试通过。</li>
</ol>
<p>这是因为<code>*os.File</code>中定义了很多和<code>Save</code>方法无关的方法。我们应该让<code>Save</code>方法中只包含它所需要的行为（接口隔离原则）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// ReadWriterCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(rwc io.ReadWriteCloser, doc *Document)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>除了接口隔离原则，还要单一职责原则，所以还可以更加优化。</p>
<p>因为<code>Save</code>方法内不太可能会去读取文件的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// WriteCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(wc io.WriteCloser, doc *Document)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>但是这种签名中包含了写入和关闭两种行为，这就涉及了一个问题，什么时候应该去关闭文件，该方法是否需要改行为：</p>
<ul>
<li>可能用户想要在写入成功后马上关闭流。</li>
<li>可能用户想要在写入成功后还想要向其中在向其中写入信息。</li>
<li>可能用户想要在写入出错后立刻关闭流。</li>
</ul>
<p>所以作为函数的设计者，我们很难猜测用户的使用场景。所以我们应该更加优化函数的签名设计：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// Writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(w io.Writer, doc *Document)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>该函数只需要一个写入方法就够了。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="检查错误"><a href="#检查错误" class="headerlink" title="检查错误"></a>检查错误</h2><p>一个通用的准则就是：调用者在检查错误之前不应该相信函数返回的所有返回值。</p>
<p>大多数情况下，用户只检查返回的err是否为nil即可，但是对于那些和外界世界交互的接口等，可能需要知道err真正的原因，比如：网络程序，以此来决定是否要重发请求。</p>
<p>对于这种需求，一个常见的设计就是将错误的类型作为public公开，然后调用者通过使用类型断言来判断错误类型，但是这种设计方式会导致几个不太好的问题：</p>
<ul>
<li>public的错误类型会增加包的接口范围。</li>
<li>新实现的接口必须要返回那些声明的public的错误类型，即使真正的错误和它并不太匹配。</li>
<li>错误类型不能被修改，不然会引起不兼容变动。</li>
</ul>
<p>这种让用户类型断言错误是否为某一特定错误的设计本质上和让用户去通过判断<code>Error()</code>返回的字符串格式一样僵硬。</p>
<h3 id="断言错误的行为特征而不是类型"><a href="#断言错误的行为特征而不是类型" class="headerlink" title="断言错误的行为特征而不是类型"></a>断言错误的行为特征而不是类型</h3><p>这个建议更加契合Go语言<code>has a</code>的设计理念，而不是继承类语言的<code>is a</code>的理念。下面是一个样例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTimeout</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">type</span> timeout <span class="keyword">interface</span> &#123;</span><br><span class="line">                Timeout() <span class="type">bool</span></span><br><span class="line">        &#125;</span><br><span class="line">        te, ok := err.(timeout)</span><br><span class="line">        <span class="keyword">return</span> ok &amp;&amp; te.Timeout()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用者通过调用<code>isTimeout</code>去判断该错误是否和超时有关，这样能够对调用者屏蔽真实的错误类型。</p>
<h2 id="错误常量值"><a href="#错误常量值" class="headerlink" title="错误常量值"></a>错误常量值</h2><p>哨岗错误（常量错误值）并不好，但是有时很有必要，但是最好把它们设置为常量（常量错误值）。</p>
<p><code>io.EOF</code>就是一个典型的哨岗错误值，但是它却不是一个常量，而是一个任何代码都可以修改的公开变量。这会导致一些很奇怪的现象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(io.EOF == io.EOF) <span class="comment">// true</span></span><br><span class="line">x := io.EOF</span><br><span class="line">fmt.Println(io.EOF == x)      <span class="comment">// true</span></span><br><span class="line">	</span><br><span class="line">io.EOF = fmt.Errorf(<span class="string">&quot;whoops&quot;</span>)</span><br><span class="line">fmt.Println(io.EOF == io.EOF) <span class="comment">// true</span></span><br><span class="line">fmt.Println(x == io.EOF)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>另一个问题是<code>io.EOF</code>表现为一个单例，而不是常量。即使我们使用和包中完全一样的定义方式，他们也不能兼容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">&quot;EOF&quot;</span>)   <span class="comment">// io/io.go line 38</span></span><br><span class="line">fmt.Println(io.EOF == err) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在Go语言中，只要任何实现了<code>Error() string</code>方法的类型都能能算作是错误类型。</p>
<p>所以，我们为了解决上面的问题我们可以这样来设计：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="type">string</span>(e) &#125;</span><br></pre></td></tr></table></figure>
<p>对于上面提出的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eof = Error(<span class="string">&quot;eof&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span></span> Read([]<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, eof</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> r Reader</span><br><span class="line">        _, err := r.Read([]<span class="type">byte</span>&#123;&#125;)</span><br><span class="line">        fmt.Println(err == eof) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过消除错误来消除错误处理"><a href="#通过消除错误来消除错误处理" class="headerlink" title="通过消除错误来消除错误处理"></a>通过消除错误来消除错误处理</h2><p>比提升错误处理语法更好的是根本不需要处理错误。</p>
<h3 id="Counting-lines"><a href="#Counting-lines" class="headerlink" title="Counting lines"></a>Counting lines</h3><p>比如下面这个实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		br    = bufio.NewReader(r)</span><br><span class="line">		lines <span class="type">int</span></span><br><span class="line">		err   <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err = br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		lines++</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lines, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个奇怪的地方：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = br.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">lines++</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在错误处理之前递增了lines。这是因为可能某个文件的末尾没有换行符，这样br将读不出内容那么最后一行将不能被统计进去。但是其实这样也是不完美的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	sc := bufio.NewScanner(r)</span><br><span class="line">	lines := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">		lines++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用<code>bufio.NewScanner(r)</code>，能够将错误处理从我们的逻辑中剔除。而它底层其实也是使用的<code>bufio.Reader</code>，它能够扫描任何格式，但是默认扫描换行。它在检测到一行的内容并且没有遇到错误的时候才会返回<code>true</code>。</p>
<p>这样很好的处理了行末没有换行和空文件的特殊情况。并且让我们避免了判断是否读取遇到了错误。而且它还记住了第一个遇到的错误，替我们处理了<code>io.EOF</code>的情况（返回nil）。</p>
<blockquote>
<p>建议：如果你发现你需要处理很多难以忍受的错误处理，那么试图提取一些操作到helper类型中。</p>
</blockquote>
<h3 id="WriteResponse"><a href="#WriteResponse" class="headerlink" title="WriteResponse"></a>WriteResponse</h3><p>像上面那个例子中因为有<code>ioutil</code>之类的帮助类型的存在，使得我们能够避免一些错误处理。但是当我们处理一些较底层的网络协议的时候，使用原始的I/O来构建响应就是必须的了。</p>
<p>看下面这段http服务器中构建HTTP响应的代码片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key, Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code   <span class="type">int</span></span><br><span class="line">	Reason <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	_, err := fmt.Fprintf(w, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		_, err := fmt.Fprintf(w, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := fmt.Fprint(w, <span class="string">&quot;\r\n&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = io.Copy(w, body)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 通过引入一个<code>errWriter</code>类型来避免大量的错误处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	io.Writer</span><br><span class="line">	err <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWriter)</span></span> Write(buf []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, e.err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">	n, e.err = e.Writer.Write(buf)</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">	fmt.Fprintf(ew, <span class="string">&quot;HTTP/1.1 %d %s\r\n&quot;</span>, st.Code, st.Reason)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		fmt.Fprintf(ew, <span class="string">&quot;%s: %s\r\n&quot;</span>, h.Key, h.Value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Fprint(ew, <span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">	io.Copy(ew, body)</span><br><span class="line">	<span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过结构体来将错误处理的代码提取出来。</p>
<h2 id="只处理一个错误一次"><a href="#只处理一个错误一次" class="headerlink" title="只处理一个错误一次"></a>只处理一个错误一次</h2><p>不处理和处理一个错误多次都是不好的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteAll writes the contents of buf to the supplied writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">        w.Write(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就丢弃了错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="type">byte</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	_, err := w.Write(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;unable to write:&quot;</span>, err) <span class="comment">// annotated error goes to log file</span></span><br><span class="line">		<span class="keyword">return</span> err                           <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而上面的代码在函数中输出了错误日志并且将错误返回了，而调用者拿到错误后很可能又会再出输出到日志，这样就处理了两次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	buf, err := json.Marshal(conf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">&quot;could not write config: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以很可能在日志中就会呈现为这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unable to write: io.EOF</span><br><span class="line">could not write config: io.EOF</span><br></pre></td></tr></table></figure>
<p>但是第一条日志是没有上下文环境的。这样做无可厚非。</p>
<p>另一个情况是程序员在检测到错误后忘记return，因为我们在错误发生后无法信任所有其他返回值，所以忘记return可能导致很多隐蔽的错误。</p>
<h3 id="推荐在错误中加入上下文环境"><a href="#推荐在错误中加入上下文环境" class="headerlink" title="推荐在错误中加入上下文环境"></a>推荐在错误中加入上下文环境</h3><p>比如<code>json.Marshal(conf)</code>出错了，只报错提示marshal错误了就不是很具体，应该加入上下文：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf, err := json.Marshal(conf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;could not marshal config: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样能够加入更多的提示信息。</p>
<h3 id="使用github-com-pkg-errors包来包装错误"><a href="#使用github-com-pkg-errors包来包装错误" class="headerlink" title="使用github.com/pkg/errors包来包装错误"></a>使用github.com/pkg/errors包来包装错误</h3><p>使用<code>fmt.Errorf</code>已经能够很好的处理错误信息，但是它是以掩盖了错误源头的代价工作的。虽然前面说过隐藏真实的错误类型会让程序之间耦合更少，但是对于简单的错误处理而言：</p>
<ol>
<li>判断错误是否为nil</li>
<li>打印错误</li>
</ol>
<p>并不会影响什么。但是有些情况下，你需要从错误中恢复出根错误值，这时你可以使用这个errors包来处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	f, err := os.Open(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;open failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	buf, err := ioutil.ReadAll(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;read failed&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	home := os.Getenv(<span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">	config, err := ReadFile(filepath.Join(home, <span class="string">&quot;.settings.xml&quot;</span>))</span><br><span class="line">	<span class="keyword">return</span> config, errors.WithMessage(err, <span class="string">&quot;could not read config&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, err := ReadConfig()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;original error: %T %v\n&quot;</span>, errors.Cause(err), errors.Cause(err))</span><br><span class="line">		fmt.Printf(<span class="string">&quot;stack trace:\n%+v\n&quot;</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将分别输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">stack trace:</span><br><span class="line">open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">open failed</span><br><span class="line">main.ReadFile</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:16</span><br><span class="line">main.ReadConfig</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:29</span><br><span class="line">main.main</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:35</span><br><span class="line">runtime.main</span><br><span class="line">        /Users/dfc/go/src/runtime/proc.go:201</span><br><span class="line">runtime.goexit</span><br><span class="line">        /Users/dfc/go/src/runtime/asm_amd64.s:1333</span><br><span class="line">could not read config</span><br></pre></td></tr></table></figure>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>GoLang以其高并发特性闻名，编写他们的团队也在为Go的并发消耗更少的硬件资源上投入了很多的精力，但是如果没有好的使用，你很可能不能发挥出它的优势。</p>
<h2 id="让你自己保持忙碌或者自己做工作"><a href="#让你自己保持忙碌或者自己做工作" class="headerlink" title="让你自己保持忙碌或者自己做工作"></a>让你自己保持忙碌或者自己做工作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">&quot;Hello, GopherCon SG&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码中，最后一行的死循环会占据并浪费着CPU的资源。</p>
<p>那么我们如何去修复它呢？下面是一个建议：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是不了解潜在问题的症状。</p>
<p>但是如果你是一个有经验的Go程序员，你应该会写出下面这种：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该语句会一直阻塞在那里，但是并不占用CPU。</p>
<p>但是更好的做法是，既然在这里goroutine和主线程之间是有严格的同步关系的，那么不如就让主线程来做这件事情，而不是委派给别的协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">&quot;Hello, GopherCon SG&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做会消除很多的状态追踪、channel通信等携程间通信的操作。</p>
<h2 id="让调用者去做并发"><a href="#让调用者去做并发" class="headerlink" title="让调用者去做并发"></a>让调用者去做并发</h2><p>比较下面两个方法签名的区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListDirectory returns the contents of dir.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListDirectory returns a channel over which</span></span><br><span class="line"><span class="comment">// directory entries will be published. When the list</span></span><br><span class="line"><span class="comment">// of entries is exhausted, the channel will be closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="type">string</span>)</span></span> <span class="keyword">chan</span> <span class="type">string</span></span><br></pre></td></tr></table></figure>
<p>前者是一个同步调用，会阻塞的去读取文件夹，并将文件夹中的内容读入一个slice，然后返回。对于一个很大的文件夹可能会导致阻塞非常长时间。</p>
<p>第二个版本是返回一个channel，里面会被放入文件夹中的内容，如果channel被关闭，那么意味着目录的内容已经读取完毕。但是第二个版本还是有两个问题：</p>
<ul>
<li>无法传达错误信息。调用者无法分辨是读取顺利完成了还是中途发生了错误。</li>
<li>无法主动停止读取的协程，只能不断循环去读取直到读取协程主动关闭通道。这在大目录的时候更省内存，但是并没有比第一个版本的运行速度上更快些。</li>
</ul>
<p>比较好的方案是通过回调函数的形式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="type">string</span>, fn <span class="keyword">func</span>(<span class="type">string</span>)</span></span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议：如果你的方法启用了一个线程，那么你一定要提供了一个让调用者能够显示停止这个goroutine的方式。</p>
</blockquote>
<h2 id="不要启动一个不会停止的协程"><a href="#不要启动一个不会停止的协程" class="headerlink" title="不要启动一个不会停止的协程"></a>不要启动一个不会停止的协程</h2><p>有一个关于http服务器的例子，端口8080监听应用相关的内容，端口8001用来访问/debug/pprof。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	_ <span class="string">&quot;net/http/pprof&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">go</span> http.ListenAndServe(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux) <span class="comment">// debug</span></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux)                       <span class="comment">// app traffic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着项目的增长会不断有问题出现，我们先解决一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> serveDebug()</span><br><span class="line">	serveApp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过拆分相关的逻辑到<code>serveApp</code>和<code>serveDebug</code>中，我们降低了main函数的耦合度，并且对于这两个函数我们把并发的任务留给了调用者。</p>
<p>但是这个项目有一些可操作性错误，比如如果<code>serveApp</code>返回了那么main函数也会返回，从而导致程序的关闭，然后再被别的进程重新启动。</p>
<p>但是<code>serveDebug</code>是工作在单独一个协程中的，并且如果它退出了，那么剩下的程序还是能够正常运行的。这样运维人员将不再能够得到运行数据。</p>
<p>我们想要确保的是，如果任何为该应用服务的协程退出了，我们将关闭整个应用程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> serveDebug()</span><br><span class="line">	<span class="keyword">go</span> serveApp()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在发生错误的时候使用<code>log.Fatal</code>。</p>
<p>但是这种方式有一些弊端：</p>
<ol>
<li>如果<code>ListenAndServe</code>返回了nil错误，<code>log.Fatal</code>将不会调用，那么该协程将退出，而应用程序不会退出。</li>
<li><code>log.Fatal</code>会调用<code>os.Exit</code>，而它会无条件的退出整个应用程序，这会导致defer不会被执行，并且其他的协程也不会被通知关闭。这让程序员很难去写单元测试。</li>
</ol>
<blockquote>
<p>建议：只在main函数和init中使用<code>log.Fatal</code></p>
</blockquote>
<p>我们真正想要的效果是当协程产生错误的时候将错误传递回协程的创建者，这样它就知道为什么那个协程会退出，之后再将整个进程干净的退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveDebug()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveApp()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := &lt;-done; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用一个通道去收集协程的返回状态。通道的的大小等于我们想要控制的协程的数目，这样发送到done通道不会导致阻塞。</p>
<p>因为没有一个安全的方式去close通道，所以我们不能使用<code>for range</code>，而是使用for循环代替。</p>
<p>现在我们已经能够等待各个协程干净的退出，并且将错误信息输出。只需要找到一个方式去转发来自第一个退出的协程的关闭信号给另一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(addr <span class="type">string</span>, handler http.Handler, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr:    addr,</span><br><span class="line">		Handler: handler,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stop <span class="comment">// wait for stop signal</span></span><br><span class="line">		s.Shutdown(context.Background())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">&quot;Hello, QCon!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> serve(<span class="string">&quot;0.0.0.0:8080&quot;</span>, mux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> serve(<span class="string">&quot;127.0.0.1:8001&quot;</span>, http.DefaultServeMux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">error</span>, <span class="number">2</span>)</span><br><span class="line">	stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveDebug(stop)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveApp(stop)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stopped <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := &lt;-done; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;error: %v&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !stopped &#123;</span><br><span class="line">			stopped = <span class="literal">true</span></span><br><span class="line">			<span class="built_in">close</span>(stop)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当我们从done通道中收到一个值的时候，我们将关闭stop通道，这将导致所有等待的通道去关闭他们的<code>http.Server</code>，而这又会导致<code>ListenAndServe</code>的协程退出，一旦所有协程退出，整个进程也会干净的退出。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/heptio/workgroup">https://github.com/heptio/workgroup</a></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_1">1</a>. <a target="_blank" rel="noopener" href="https://gaston.life/books/effective-programming/">https://gaston.life/books/effective-programming/</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_2">2</a>. <a target="_blank" rel="noopener" href="https://talks.golang.org/2014/names.slide#4">https://talks.golang.org/2014/names.slide#4</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_3">3</a>. <a target="_blank" rel="noopener" href="https://www.infoq.com/articles/API-Design-Joshua-Bloch">https://www.infoq.com/articles/API-Design-Joshua-Bloch</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_1">1</a>. <a target="_blank" rel="noopener" href="https://www.lysator.liu.se/c/pikestyle.html">https://www.lysator.liu.se/c/pikestyle.html</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_2">2</a>. <a target="_blank" rel="noopener" href="https://speakerdeck.com/campoy/understanding-nil">https://speakerdeck.com/campoy/understanding-nil</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_3">3</a>. <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Ic2y6w8lMPA">https://www.youtube.com/watch?v=Ic2y6w8lMPA</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_4">4</a>. <a target="_blank" rel="noopener" href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_5">5</a>. <a target="_blank" rel="noopener" href="https://golang.org/doc/go1.4#internalpackages">https://golang.org/doc/go1.4#internalpackages</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_6">6</a>. <a target="_blank" rel="noopener" href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_7">7</a>. <a target="_blank" rel="noopener" href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_8">8</a>. <a target="_blank" rel="noopener" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_9">9</a>. <a target="_blank" rel="noopener" href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201">https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_10">10</a>. <a target="_blank" rel="noopener" href="https://blog.golang.org/errors-are-values">https://blog.golang.org/errors-are-values</a></p>
<p><a target="_blank" rel="noopener" href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_11">11</a>. <a target="_blank" rel="noopener" href="http://www.gopl.io/">http://www.gopl.io/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/09/25/%E3%80%8AGo%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/25/%E3%80%8AGo%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《Go并发编程实战》读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-25 12:27:15" itemprop="dateCreated datePublished" datetime="2018-09-25T12:27:15+08:00">2018-09-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-06 15:06:25" itemprop="dateModified" datetime="2019-01-06T15:06:25+08:00">2019-01-06</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/09/25/%E3%80%8AGo%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/09/25/《Go并发编程实战》读书笔记/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《Go并发编程实战》读书笔记"><a href="#《Go并发编程实战》读书笔记" class="headerlink" title="《Go并发编程实战》读书笔记"></a>《Go并发编程实战》读书笔记</h1><h2 id="第四章-Go的并发机制"><a href="#第四章-Go的并发机制" class="headerlink" title="第四章 Go的并发机制"></a>第四章 Go的并发机制</h2><ul>
<li>go表达式后面的应该是称为调用表达式语句的调用表达式。而以下函数的调用表达式不能称为表达式语句：<code>append</code>、<code>cap</code>、<code>complex</code>、<code>imag</code>、<code>len</code>、<code>make</code>、<code>new</code>、<code>real</code>、<code>unsafe.Alignof</code>、<code>unsafe.Offsetof</code>、<code>unsafe.Sizeof</code>。</li>
<li><code>runtime.Gosched</code>的作用是用来暂定当前的G，让出CPU使用权，好让其他G有机会运行。</li>
<li>runtime包中的一些API：<ul>
<li><code>runtime.GOMAXPROCS</code>：用来设置程序运行期间能够使用的P的最大数量，这会引起所有M和P的剥离即”stop the world”。</li>
<li><code>runtime.Goexit</code>：会立即将当前的goroutine的运行终止，而其他goroutine不受影响。在退出前还是会执行defer语句。注意：不能再主goroutine中使用这个函数。</li>
<li><code>runtime.Gosched</code>：将当前的goroutine状态变成就绪态，让出CPU的使用权，等待再次被调度。</li>
<li><code>runtime.NumGoroutine</code>：返回当前go运行时系统中处于非Gdead状态的用户G的数量。</li>
<li><code>runtime.LockOSThread</code>和<code>runtime.UnlockOSThread</code>：前者会让当前的goroutine与当前的M锁定在一起，后者则是解除锁定。</li>
<li><code>runtime/debug.SetMaxStack</code>：约束单个goroutine所能申请栈空间的最大尺寸。该函数接收一个int类型的参数，该参数的含义是欲设定的栈空间的最大字节数，单位为字节。</li>
<li><code>runtime/debug.SetMaxThreads</code>：对Go运行时系统所使用的内核线程的数量（也可以认为是M的数量）进行设置。在引导程序中，该数量被设置成了10000。如果调用此函数时使用的新值比运行时系统当前正在使用的M的数量还要小的话，就会引发一个运行时恐慌。如果超过M的最大值将会造成运行时恐慌。</li>
<li><code>runtime/debug.SetGCPercent</code>和<code>runtime.GC</code>和<code>runtime/debug.FreeOSMemory</code>：前者用于设定触发自动GC的条件，后两者用来发起手动GC。手动GC期间调度是停止的。</li>
</ul>
</li>
<li><code>chan&lt;- T</code>：发送通道</li>
<li><code>&lt;-chan T</code>：接收通道，go不允许关闭接收通道。</li>
<li>试图从一个未被初始化的通道中接收元素值将会导致当前的goroutine永久阻塞！</li>
<li>在go语言中空结构体类型是不占用内存空间的，struct{}</li>
<li>如果有多个通道试图向通道中发送消息，但是因为缓冲区已满而被阻塞，那么最早开始等待的那个goroutine将会被最先唤醒。</li>
<li>如果通道已经有goroutine在等待且里面的缓存为空，那么发送方的数据会直接复制到接收方即跳过缓冲区的复制（总共只会复制一次），别的情况就是会存在缓冲区复制一次，到接受者那里又复制一次，共两次。</li>
<li>试图向一个已关闭的通道发送元素将会引发运行时恐慌。</li>
<li>在接收方还没有把缓冲区内的信息全部读取完之前发送发关闭了channel时，接收方还是能够正确的读取出剩余的信息。</li>
<li><strong>map</strong>的静态初始化m := map[string]int{“1”:1,”2”:2,}</li>
<li>单向通道是不能转换回双向通道的。</li>
<li>运行时系统会在select中case中按照“<strong>从左向右，从上向下</strong>”的顺序去判断操作是否会让当前goroutine被阻塞，会去执行第一个判断为肯定的分支。当多个case都满足的时候，将会使用一个伪随机算法选中一个case。</li>
<li>go语言支持break tag</li>
<li><code>time</code>包里面有两个函数可以用来构建time.Timer类型的值，分别为<code>time.NewTimer</code>和<code>time.AfterFunc</code>两个函数。<ul>
<li><code>NewTimer</code>：返回的是一个*time.Timer类型的值，包含两个方法<code>Reset</code>和<code>Stop</code>。前者用来重置定时器，后者用来停止定时器，返回一个布尔值，如果为false，那么代表该定时器早就已经到期或者已经被停止，否则就是说明该定时器是由于方法的调用而被停止。<ul>
<li>如果<strong>在定时器到期之前就终止了它</strong>，那么再试图从它的C字段中接收元素将会导致当前goroutine永远阻塞。</li>
<li>如果定时器到期了，但是你却没有及时的从它的C字段中接收元素值，那么该字段就会一直缓冲着这个元素即使在该定时器被重置之后也是这样，这意味着后面的通知将被直接丢掉。总而言之，<strong>如果想要复用定时器那么应该确保旧的通知已经被接收。</strong></li>
</ul>
</li>
<li><code>AfterFunc</code>：接收两个参数，第一个参数代表相对到期时间，第二个参数指定到期时需要执行的函数。虽然该函数也返回一个新建的定时器，<strong>该函数在时间到的时候并不会向它的通知通道里面发送元素值，而是新启用一个goroutine来执行调用方传入的函数。</strong></li>
</ul>
</li>
</ul>
<h2 id="第五章-同步"><a href="#第五章-同步" class="headerlink" title="第五章 同步"></a>第五章 同步</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><ul>
<li>试图解锁一个未被锁定的互斥锁将导致一个运行时恐慌。</li>
</ul>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li>除了<code>Lock</code>和<code>Unlock</code>和<code>RLock</code>和<code>RUnlock</code>这四个方法外，还有<code>RLocker</code>这个指针方法，该方法返回读写锁的本身，但是<code>Lock</code>和<code>Unlock</code>将变为读锁定和写锁定，这样可以使我们使用相同的方式来操作读写锁中的写锁和读锁。</li>
</ul>
<h3 id="条件变量：sync-Cond"><a href="#条件变量：sync-Cond" class="headerlink" title="条件变量：sync.Cond"></a>条件变量：sync.Cond</h3><ul>
<li>需要通过<code>func NewCond(l Locker) *Cond</code>来创建一个条件变量，接收一个互斥锁或者读写锁对象作为参数。</li>
<li>该类型中一共有3个方法：<code>Wait</code>、<code>Signal</code>、<code>Broadcast</code>，分别代表了等待通知、单发通知和广播通知的操作。<ul>
<li><code>Wait</code>方法：<strong>会自动对与该条件变量关联的那个锁进行解锁</strong>，并使它所在的goroutine阻塞。一旦受到通知，该方法所在的goroutine就会被唤醒，并且<strong>该方法就会立即尝试锁定该锁</strong>（解锁阻塞，唤醒锁定）。</li>
<li>后两者都是用来发送通知，以唤醒正在为此阻塞的goroutine。不同的是，前者的目标只有一个，而后者的目标则是所有。</li>
</ul>
</li>
<li><strong>需要注意的是</strong>：<ul>
<li>一定要在调用<code>Wait</code>方法之前锁定与之关联的读锁，否则就会引发不可恢复的运行时恐慌。</li>
<li>一定不要忘记在<code>Wait</code>被唤醒之后及时解锁与条件变量关联的那个读锁。因为<code>Wait</code>在返回时会去锁定。</li>
</ul>
</li>
</ul>
<h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><ul>
<li>在<code>sync/atomic</code>中提供了对<code>int32</code>、<code>int64</code>、<code>uint32</code>、<code>uint64</code>、<code>uintptr</code>和<code>unsafe.Pointer</code>这几种类型的原子操作，包括增或减、比较并交换、载入、存储和交换。</li>
</ul>
<h4 id="增或减"><a href="#增或减" class="headerlink" title="增或减"></a>增或减</h4><ul>
<li>该类操作的名称均以<code>Add</code>为前缀，后面跟上具体类型的名称。例如：<code>newi32 := atomic.AddInt32(&amp;i32, 3)</code></li>
<li>如果要减少某个值，那么可以使用加上一个负数的方法，但是对于uint32这样的无符号整数第二个参数不能填入负数，那么可以使用如下方法：<code>atomic.AddUint32(&amp;ui32, ^uint32(-NN-1)) 其中NN代表一个负整数</code>。这主要利用了二进制补码的特性：一个负整数的补码可以通过对它按位（除了符号位）求反码并加一得到。</li>
</ul>
<h4 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h4><ul>
<li>该类操作的名称是以<code>CompareAndSwapInt32</code>为前缀，比如<code>func CompareAndSwapInt32(addr *int32, old, new int32)(swapped bool)</code>。</li>
<li>接收三个参数，第一个参数为被操作值的指针值，后两个参数为被操作值的旧值和新值。</li>
<li>执行过程为：先判断参数<code>addr</code>指向的被操作值与参数<code>old</code>的值是否相等，只有得到肯定的结果后该函数才会用new来替换old值。返回值swapped代表是否进行了替换操作。</li>
</ul>
<h4 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h4><ul>
<li>都以<code>Load</code>为前缀，用于原子的读取变量的值。例如：<code>v := atomic.LoadInt32(&amp;value)</code></li>
</ul>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><ul>
<li>与读取操作相对应的存储函数，名称均以<code>Store</code>为前缀。</li>
<li>接收两个参数，第一个参数为被操作数的指针，第二个参数为欲存储的新值。</li>
</ul>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><ul>
<li>函数名称以<code>Swap</code>为前缀。</li>
<li>比存储多做了一步，就是返回被操作值的旧值。</li>
<li>接收两个参数：第一个参数是被操作数的地址，第二个参数为新值。</li>
</ul>
<h3 id="原子值：sync-atomic-Value"><a href="#原子值：sync-atomic-Value" class="headerlink" title="原子值：sync/atomic.Value"></a>原子值：sync/atomic.Value</h3><p>该类型的值有两个公开的指针方法：<code>Load</code>和<code>Store</code></p>
<ul>
<li><code>Load</code>：原子地读取原子值实例中存储的值，返回一个interface{}类型的结果，且不接受任何参数。在没有使用<code>Store</code>方法存储值之前，总是返回nil。</li>
<li><code>Store</code>：接受一个interface{}类型的参数而没有任何结果。要求：<ul>
<li>传入的参数不能为nil</li>
<li>传入的参数的类型必须和之前传入的类型相同</li>
</ul>
</li>
<li>该类类型变量不建议被复制到别处：<ul>
<li>赋值给别的变量</li>
<li>作为参数值传入函数</li>
<li>作为结果值从函数返回</li>
<li>传入通道</li>
<li>……</li>
</ul>
</li>
<li>可以通过<code>go test -race 包名</code>来检测程序是否存在竞态条件。参考：<a target="_blank" rel="noopener" href="https://blog.golang.org/race-detector">https://blog.golang.org/race-detector</a><ul>
<li>通过加上<code>-race</code>选项来处理</li>
</ul>
</li>
</ul>
<h3 id="只执行一次：sync-Once"><a href="#只执行一次：sync-Once" class="headerlink" title="只执行一次：sync.Once"></a>只执行一次：sync.Once</h3><h3 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h3><ul>
<li><p>结构体中有一个代表计数的字节数组类型的字段。用4字节表示给定计数，另用4字节表示等待计数。</p>
</li>
<li><p>该类型有3个指针方法：<code>Add</code>、<code>Done</code>、<code>Wait</code>。</p>
</li>
<li>可以通过<code>Add</code>方法来将计数值减少，如<code>Add(-3)</code>，但是注意不能让计数值变为负数，那样会导致一个运行恐慌。通过如果使用<code>Done</code>让计数值变为负数，也会导致运行时恐慌。</li>
<li>可以被复用。</li>
<li><strong>不应该被复制。</strong></li>
</ul>
<h3 id="临时对象池：sync-Pool"><a href="#临时对象池：sync-Pool" class="headerlink" title="临时对象池：sync.Pool"></a>临时对象池：sync.Pool</h3><ul>
<li>该类型有一个公开字段<code>New</code>，类型为<code>func() interface&#123;&#125;</code>是一个函数类型。该函数会被用来创建对象值，不过，一般该函数仅在池中无可用对象值的时候才被调用。</li>
<li>该类型有两个公开的指针方法<ul>
<li><code>Get</code>：从池中获取一个interface{}类型的值。获取到的值是任意的，如果从未”Put”，而且“New”字段也没有被初始化过，那么将返回nil。该方法返回的值不一定就是存在池中的值，但是如果这个结果是池中的，那么在该方法返回它之前，就一定会把它从池中删除。</li>
<li><code>Put</code>：向池中放入一个interface{}类型的变量。</li>
</ul>
</li>
<li>该类型有两个特点：<ul>
<li>一：它会为每个与操作它的goroutine想关联的P建立本地池。当调用Get方法的时候，一般将先会尝试从<strong>本地P对应的那个本地私有池和本地共享池</strong>中获取一个对象。如果获取失败，那么会试图从<strong>其他P的本地共享池</strong>中偷一个对象值并且直接返回给调用方。如果依旧失败，那么将使用<strong>当前临时对象池对象值生成函数</strong>来生成一个对象，需要注意的是，生成函数生成的对象将不会进入池中，而是直接返回给用户。临时对象池的Put方法会把它的参数值存放到本地P的本地池中。</li>
<li>二：垃圾回收的执行一般会将临时对象池中的对象全部移除。</li>
</ul>
</li>
</ul>
<h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>我们之所以对一个变量加锁，就是因为<strong>担心在“读取”或者“赋值”的时候，被调度器所中断</strong>导致数据不一致，即和任何同步执行序列的结果都不同。那么如果这个赋值或者读取操作本身就是一个原子操作，即在硬件层面就保证了不可中断的话那么加锁就没有必要了。</p>
<p>注意这里想要达到的目的仅仅是不会出现数据的紊乱，而不关心线程竞争的顺序，只要最终出现的结果始终是正常调用结果即可。</p>
<p>但是局限性是这个原子操作库里面仅仅提供了一些简单类型的操作。</p>
<p>原子操作比加锁更加的高效！如果可以的话，推荐使用原子操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/07/14/Go%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/14/Go%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">Go结构体嵌入接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-14 16:40:15" itemprop="dateCreated datePublished" datetime="2018-07-14T16:40:15+08:00">2018-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-06 15:06:40" itemprop="dateModified" datetime="2019-01-06T15:06:40+08:00">2019-01-06</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/07/14/Go%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5%E6%8E%A5%E5%8F%A3/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/14/Go结构体嵌入接口/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Go结构体嵌入接口"><a href="#Go结构体嵌入接口" class="headerlink" title="Go结构体嵌入接口"></a>Go结构体嵌入接口</h1><p>今天在看<code>github.com/pkg/errors</code>源码的时候，看到了一个很有趣的现象，然后通过查阅资料了解到了Go的一大特色。</p>
<h2 id="一、描述"><a href="#一、描述" class="headerlink" title="一、描述"></a>一、描述</h2><p>有一个结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> withStack <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="type">error</span></span><br><span class="line">   *stack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有两个内嵌字段，一个是接口，一个是自定义类型（stack是一个数组），但是让我不解的是这个函数的行为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStack</span><span class="params">(err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &amp;withStack&#123;</span><br><span class="line">      err,</span><br><span class="line">      callers(),</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它竟然把withStack结构体转换成了error类型？？？第一反应是它凭什么呢，它又没有实现Error()方法，实现Error()方法的不过是它的一个字段而已啊。</p>
<p>后来通过查阅发现了Go的一大特性。</p>
<h2 id="二、解释"><a href="#二、解释" class="headerlink" title="二、解释"></a>二、解释</h2><p>如果在结构体里面嵌入一个字段，那么会存在一个种叫做方法集提升的行为。一共有如下几条规则：</p>
<ul>
<li><strong>如果S包含一个匿名字段T，S和*S的方法集都包含接受者为T的方法提升。</strong></li>
<li><strong>对于 <em>S 类型的方法集包含接受者为 </em>T 的方法提升。</strong></li>
<li><strong>如果 S 包含一个匿名字段 <em>T，S 和 </em>S 的方法集都包含接受者为 T 或者 *T 的方法提升。</strong></li>
<li><strong>如果 S 包含一个匿名字段 T，S 的方法集不包含接受者为 *T 的方法提升。</strong></li>
</ul>
<h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p><a target="_blank" rel="noopener" href="https://my.oschina.net/xinxingegeya/blog/1560474">https://my.oschina.net/xinxingegeya/blog/1560474</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/07/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8channel%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/07/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8channel%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">为什么需要关注channel的关闭方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-13 21:17:15" itemprop="dateCreated datePublished" datetime="2018-07-13T21:17:15+08:00">2018-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 21:56:00" itemprop="dateModified" datetime="2019-01-13T21:56:00+08:00">2019-01-13</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/07/13/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%85%B3%E6%B3%A8channel%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/07/13/为什么需要关注channel的关闭方式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、为什么需要关注channel的关闭方式"><a href="#一、为什么需要关注channel的关闭方式" class="headerlink" title="一、为什么需要关注channel的关闭方式"></a>一、为什么需要关注channel的关闭方式</h2><p>因为在go语言中，试图关闭或者试图向一个已经关闭的channel发送消息都会导致panic。所以合理的关闭channel在多线程的情况下变的至关重要。</p>
<h2 id="二、在go语言中关闭channel需要遵循的原则"><a href="#二、在go语言中关闭channel需要遵循的原则" class="headerlink" title="二、在go语言中关闭channel需要遵循的原则"></a>二、在go语言中关闭channel需要遵循的原则</h2><blockquote>
<p>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.</p>
</blockquote>
<p>即永远不要在接受者端关闭channel，并且如果一个channel有多个并发的发送者时不要试图去关闭channel。简而言之，就是只有在只有一个发送者的时候，才能直接关闭channel。</p>
<h2 id="三、在不同情形下最佳实践"><a href="#三、在不同情形下最佳实践" class="headerlink" title="三、在不同情形下最佳实践"></a>三、在不同情形下最佳实践</h2><p>下面介绍了在不同的情形下，如何去优雅的关闭channel。</p>
<h3 id="情况1：有多个接收者，一个发送者"><a href="#情况1：有多个接收者，一个发送者" class="headerlink" title="情况1：有多个接收者，一个发送者"></a>情况1：有多个接收者，一个发送者</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	log.SetFlags(<span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line">	</span><br><span class="line">	wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wgReceivers.Add(NumReceivers)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// the sender</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> value := rand.Intn(MaxRandomNumber); value == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// The only sender can close the channel safely.</span></span><br><span class="line">				<span class="built_in">close</span>(dataCh)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;			</span><br><span class="line">				dataCh &lt;- value</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// receivers</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// Receive values until dataCh is closed and</span></span><br><span class="line">			<span class="comment">// the value buffer queue of dataCh is empty.</span></span><br><span class="line">			<span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">				log.Println(value)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，<strong>发送者</strong>可以放心的去关闭用于数据传输的channel，而接受者们可以检测到channel的关闭然后自动退出。这种操作也是满足第二章所说的原则的。</p>
<p>注意上面示例代码中的sync.WaitGroup不是必须的。</p>
<h3 id="情况2：多个发送者，一个接收者"><a href="#情况2：多个发送者，一个接收者" class="headerlink" title="情况2：多个发送者，一个接收者"></a>情况2：多个发送者，一个接收者</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	log.SetFlags(<span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line">	</span><br><span class="line">	wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wgReceivers.Add(<span class="number">1</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		<span class="comment">// stopCh is an additional signal channel.</span></span><br><span class="line">		<span class="comment">// Its sender is the receiver of channel dataCh.</span></span><br><span class="line">		<span class="comment">// Its reveivers are the senders of channel dataCh.</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// senders</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// The first select is to try to exit the goroutine</span></span><br><span class="line">				<span class="comment">// as early as possible. In fact, it is not essential</span></span><br><span class="line">				<span class="comment">// for this specified example, so it can be omitted.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Even if stopCh is closed, the first branch in the</span></span><br><span class="line">				<span class="comment">// second select may be still not selected for some</span></span><br><span class="line">				<span class="comment">// loops if the send to dataCh is also unblocked.</span></span><br><span class="line">				<span class="comment">// But this is acceptable for this example, so the</span></span><br><span class="line">				<span class="comment">// first select block above can be omitted.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> dataCh &lt;- rand.Intn(MaxRandomNumber):</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// the receiver</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">			<span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">				<span class="comment">// The receiver of the dataCh channel is</span></span><br><span class="line">				<span class="comment">// also the sender of the stopCh channel.</span></span><br><span class="line">				<span class="comment">// It is safe to close the stop channel here.</span></span><br><span class="line">				<span class="built_in">close</span>(stopCh)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			log.Println(value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，发送者不能直接关闭channel了，其实也并不需要关闭channel，只需要让其对应的go routine退出即可，因为如果一个channel不再被任何go routine引用，那么最终会被垃圾回收机制回收，所以这种情况下最佳实践就是不要去关闭channel。</p>
<p>在这种情况下，采用的是一个channel作为信号管道，当<strong>接受者</strong>不希望再接收来自多个发送者的消息的时候，可以去关闭信号管道，因为在信号管道角度来看接受者和发送者的角色互换了。</p>
<p>可以注意到在发送者中使用了两个select，第一个的意义在于让go routine尽早的退出，因为如果第二个select中两个分支通知满足，那么系统会随机选择一个分支执行，即该go routine可能会延迟退出，当然如果这种情况是可以接受的话，那么第一个select是不必须的。</p>
<h3 id="情况3：多个发送者和多个接受者"><a href="#情况3：多个发送者和多个接受者" class="headerlink" title="情况3：多个发送者和多个接受者"></a>情况3：多个发送者和多个接受者</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	log.SetFlags(<span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line">	<span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line">	</span><br><span class="line">	wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wgReceivers.Add(NumReceivers)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		<span class="comment">// stopCh is an additional signal channel.</span></span><br><span class="line">		<span class="comment">// Its sender is the moderator goroutine shown below.</span></span><br><span class="line">		<span class="comment">// Its reveivers are all senders and receivers of dataCh.</span></span><br><span class="line">	toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// The channel toStop is used to notify the moderator</span></span><br><span class="line">		<span class="comment">// to close the additional signal channel (stopCh).</span></span><br><span class="line">		<span class="comment">// Its senders are any senders and receivers of dataCh.</span></span><br><span class="line">		<span class="comment">// Its reveiver is the moderator goroutine shown below.</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> stoppedBy <span class="type">string</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// moderator</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		stoppedBy = &lt;-toStop</span><br><span class="line">		<span class="built_in">close</span>(stopCh)</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// senders</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				value := rand.Intn(MaxRandomNumber)</span><br><span class="line">				<span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// Here, a trick is used to notify the moderator</span></span><br><span class="line">					<span class="comment">// to close the additional signal channel.</span></span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> toStop &lt;- <span class="string">&quot;sender#&quot;</span> + id:</span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// The first select here is to try to exit the goroutine</span></span><br><span class="line">				<span class="comment">// as early as possible. This select blocks with one</span></span><br><span class="line">				<span class="comment">// receive operation case and one default branches will</span></span><br><span class="line">				<span class="comment">// be specially optimized as a try-receive operation by</span></span><br><span class="line">				<span class="comment">// the standard Go compiler.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Even if stopCh is closed, the first branch in the</span></span><br><span class="line">				<span class="comment">// second select may be still not selected for some</span></span><br><span class="line">				<span class="comment">// loops (and for ever in theory) if the send to</span></span><br><span class="line">				<span class="comment">// dataCh is also non-blocking.</span></span><br><span class="line">				<span class="comment">// This is why the first select block above is needed.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// receivers</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// Same as the sender goroutine, the first select here</span></span><br><span class="line">				<span class="comment">// is to try to exit the goroutine as early as possible.</span></span><br><span class="line">				<span class="comment">// This select blocks with one send operation case and</span></span><br><span class="line">				<span class="comment">// one default branches will be specially optimized as</span></span><br><span class="line">				<span class="comment">// a try-send operation by the standard Go compiler.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// Even if stopCh is closed, the first branch in the</span></span><br><span class="line">				<span class="comment">// second select may be still not selected for some</span></span><br><span class="line">				<span class="comment">// loops (and for ever in theory) if the receive from</span></span><br><span class="line">				<span class="comment">// dataCh is also non-blocking.</span></span><br><span class="line">				<span class="comment">// This is why the first select block is needed.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;- stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">					<span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">						<span class="comment">// The same trick is used to notify</span></span><br><span class="line">						<span class="comment">// the moderator to close the</span></span><br><span class="line">						<span class="comment">// additional signal channel.</span></span><br><span class="line">						<span class="keyword">select</span> &#123;</span><br><span class="line">						<span class="keyword">case</span> toStop &lt;- <span class="string">&quot;receiver#&quot;</span> + id:</span><br><span class="line">						<span class="keyword">default</span>:</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					log.Println(value)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	wgReceivers.Wait()</span><br><span class="line">	log.Println(<span class="string">&quot;stopped by&quot;</span>, stoppedBy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，发送者和接受者都不适合去触发信号通道了，这时候可以采用一个代理角色，让<strong>代理角色</strong>去触发关闭信号通道，而所有的发送者和接受者去监听这个信号通道。</p>
<p>简单的来说，就是所有的发送者和接受者都可以去通知代理角色去关闭信号通道，然后所有的发送者和接受者都去监听该信号通道是否关闭，如果关闭了那么就全部退出。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/05/26/%E5%AD%A6%E4%B9%A0progit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/26/%E5%AD%A6%E4%B9%A0progit/" class="post-title-link" itemprop="url">学习progit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-26 17:23:15" itemprop="dateCreated datePublished" datetime="2018-05-26T17:23:15+08:00">2018-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 21:58:13" itemprop="dateModified" datetime="2019-01-13T21:58:13+08:00">2019-01-13</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/05/26/%E5%AD%A6%E4%B9%A0progit/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/05/26/学习progit/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习progit"><a href="#学习progit" class="headerlink" title="学习progit"></a>学习progit</h1><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><h3 id="修改提交操作-git-commit-—amend"><a href="#修改提交操作-git-commit-—amend" class="headerlink" title="修改提交操作 git commit —amend"></a>修改提交操作 <code>git commit —amend</code></h3><p>有时我们提交完了之后才发现了漏掉了几个文件没有添加，或者提交信息写错了。此时可以使用该命令进行修正。这个命令会将暂存区中的文件提交（合并提交）。如果从上次提交以来你还未做任何修改，那么仅仅只会修改提交信息。</p>
<h3 id="取消暂存的文件-git-reset-HEAD-lt-file-gt"><a href="#取消暂存的文件-git-reset-HEAD-lt-file-gt" class="headerlink" title="取消暂存的文件 git reset HEAD &lt;file&gt;"></a>取消暂存的文件 <code>git reset HEAD &lt;file&gt;</code></h3><p>有时，你已经修改了两个文件并且想要将它们作为分别两次独立的修改提交，但是却意外的输入了<code>git add *</code>暂存了他们两个。可以通过该命令来取消暂存。</p>
<blockquote>
<p><strong>注意：</strong>该命令加上—hard会让git reset变得非常危险，可能导致工作目录中所有的当前进度丢失。</p>
</blockquote>
<h3 id="撤销对文件的修改-git-checkout-file"><a href="#撤销对文件的修改-git-checkout-file" class="headerlink" title="撤销对文件的修改 git checkout -- [file]"></a>撤销对文件的修改 <code>git checkout -- [file]</code></h3><p>当你不想保留对某个文件的修改的时候使用。</p>
<blockquote>
<p><strong>注意：</strong>该命令非常危险，会丢失所有修改，你只是拷贝了另一个文件来覆盖它。</p>
</blockquote>
<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><h3 id="查看远程仓库-git-remote-v"><a href="#查看远程仓库-git-remote-v" class="headerlink" title="查看远程仓库 git remote [-v]"></a>查看远程仓库 <code>git remote [-v]</code></h3><p>它会列出你指定的每一个远程服务器的简写。<code>origin</code>是Git给你克隆的仓库服务器的默认名称。加上<code>-v</code>会显示需要读写的远程仓库名称以及对应的URL。</p>
<h3 id="添加远程仓库-git-remote-add-lt-shortname-gt-lt-url-gt"><a href="#添加远程仓库-git-remote-add-lt-shortname-gt-lt-url-gt" class="headerlink" title="添加远程仓库 git remote add &lt;shortname&gt; &lt;url&gt;"></a>添加远程仓库 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code></h3><p>用来添加远程仓库</p>
<h3 id="从远程仓库拉取git-fetch-remote-name"><a href="#从远程仓库拉取git-fetch-remote-name" class="headerlink" title="从远程仓库拉取git fetch [remote-name]"></a>从远程仓库拉取<code>git fetch [remote-name]</code></h3><p>这个命令将会访问远程仓库，从中拉取所有你还没有的数据。执行完毕后，你将会拥有该远程仓库上的分支的所有引用，可以随时查看和合并。（注意该操作并不会自动合并或者修改你的工作）。</p>
<p>而<code>git pull</code>命令将会自动抓取远程分支并合并到本地当前分支。</p>
<h3 id="推送到远程分支git-push-remote-name-branch-name"><a href="#推送到远程分支git-push-remote-name-branch-name" class="headerlink" title="推送到远程分支git push [remote-name] [branch-name]"></a>推送到远程分支<code>git push [remote-name] [branch-name]</code></h3><p>只有你对于该分支有写入权限，并且之前没有人推送过的时候该命令才能生效。如果其他人先提交了，那么你应该先拉取他人的工作并合并进你的工作后才能提交。</p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="列出所有标签git-tag"><a href="#列出所有标签git-tag" class="headerlink" title="列出所有标签git tag"></a>列出所有标签<code>git tag</code></h3><p>该命令将会按照字母序号列出所有的标签，加上<code>-l</code>后支持正则。</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>通过<code>git tag -a [tag-name] -m [message]</code>来创建一个附注标签。</p>
<p>通过<code>git show [tag-name]</code>命令可以看到标签信息和对应的提交信息。</p>
<p>通过<code>git tag [tag-name]</code>即不添加<code>-a</code>，<code>-s</code>，或者<code>-m</code>选项，只需要提供标签名字。</p>
<p>后期打标签<code>git tag -a [tag-name] checksum</code>。</p>
<h3 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h3><p>默认情况下，<code>git push</code>不会传送标签到远程仓库服务器上，必须显示的手动推送标签到远端。可以使用<code>git push origin [tagname]</code>，想要一次推送很多标签，可以使用选项的<code>git push origin --tags</code>命令，这样会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="创建分支git-branch"><a href="#创建分支git-branch" class="headerlink" title="创建分支git branch"></a>创建分支<code>git branch</code></h3><p>是指上就是创建一个指针指向当前的提交对象。</p>
<h3 id="切换分支git-checkout-BRACH-NAME"><a href="#切换分支git-checkout-BRACH-NAME" class="headerlink" title="切换分支git checkout BRACH_NAME"></a>切换分支<code>git checkout BRACH_NAME</code></h3><p>切换分支的本质就是<code>HEAD</code>指针移动到指定的分支指针指向的那个提交对象。</p>
<h3 id="分支合并git-merge"><a href="#分支合并git-merge" class="headerlink" title="分支合并git merge"></a>分支合并<code>git merge</code></h3><p><code>fast-forward</code>模式：即如果能够顺着target分支一直走到source分支，那么只需要简单的移动分支就好了（将target分支的指针移动到source分支的头上）。</p>
<p>如果合并分支的时候出现了冲突，即两个分支都对同一个文件的同一个块地方做了修改，那么git将不能干净的进行合并，所以这时git将会停下，等待你进行合并，那些有冲突待解决的文件可以通过<code>git status</code>来进行查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status On branch master You have unmerged paths.</span></span><br><span class="line"></span><br><span class="line">(fix conflicts and run &quot;git commit&quot;)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line"></span><br><span class="line">(use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line"></span><br><span class="line">both modified:</span><br><span class="line"></span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>
<p>打开该文件有冲突的地方大概格式如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">======= </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span> please contact us at support@github.com <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure>
<p><code>=======</code>上面的代表的是当前分支的修改，下面的代表的是待并入分支的修改，用户可以根据需要进行合并，然后将<code>=====</code>，<code>&lt;&lt;&lt;&lt;&lt;</code>，<code>&gt;&gt;&gt;&gt;&gt;</code>这些标记删除。然后将解决完冲突后的文件，使用<code>git add</code>来暂存这些文件，git会将这些文件标记为冲突已解决。</p>
<p>这时<code>git status</code>将会输入如下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status On branch master All conflicts fixed but you are still merging.</span></span><br><span class="line"></span><br><span class="line">(use &quot;git commit&quot; to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">modified:</span><br><span class="line"></span><br><span class="line">index.html</span><br></pre></td></tr></table></figure>
<p>然后使用<code>git commit</code>来完成合并提交。</p>
<h3 id="删除分支git-brach-d-BRANCH-NAME"><a href="#删除分支git-brach-d-BRANCH-NAME" class="headerlink" title="删除分支git brach -d BRANCH_NAME"></a>删除分支<code>git brach -d BRANCH_NAME</code></h3><h3 id="查看分支git-branch"><a href="#查看分支git-branch" class="headerlink" title="查看分支git branch"></a>查看分支<code>git branch</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">iss53 </span><br><span class="line">* master</span><br><span class="line">testing</span><br></pre></td></tr></table></figure>
<h3 id="修改一个分支的远程分支"><a href="#修改一个分支的远程分支" class="headerlink" title="修改一个分支的远程分支"></a>修改一个分支的远程分支</h3><ul>
<li>如果想要创建一个新分支并且设置和它关联的远程分支，那么可以通过快捷操作<code>git checkout --track [remotename]/[brach]</code>做到或者通过<code>git checkout -b [branch] [remotename]/[branch]</code>来较为麻烦的实现。</li>
<li>对于一个已经存在的分支，如果想要修改它所指向的远程分支可以通过<code>git branch -u [remotename]/[branch]</code>或者<code>git branch --set-upstream-to [remotename]/[branch]</code></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/05/23/%E5%AD%A6%E4%B9%A0protobuf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/05/23/%E5%AD%A6%E4%B9%A0protobuf/" class="post-title-link" itemprop="url">学习protobuf</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-05-23 21:52:15" itemprop="dateCreated datePublished" datetime="2018-05-23T21:52:15+08:00">2018-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 21:59:11" itemprop="dateModified" datetime="2019-01-13T21:59:11+08:00">2019-01-13</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/05/23/%E5%AD%A6%E4%B9%A0protobuf/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/05/23/学习protobuf/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="学习protobuf"><a href="#学习protobuf" class="headerlink" title="学习protobuf"></a>学习protobuf</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p><strong>ProtoBuf：</strong> 是一套完整的 IDL（接口描述语言），出自Google，基于 C++ 进行的实现，开发人员可以根据 ProtoBuf 的语言规范生成多种编程语言（Golang、Python、Java 等）的接口代码，本篇只讲述 Golang 的基础操作。据说 ProtoBuf 所生成的二进制文件在存储效率上比 XML 高 3~10 倍，并且处理性能高 1~2 个数量级，这也是选择 ProtoBuf 作为序列化方案的一个重要因素之一。</p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/javatutorial">https://developers.google.com/protocol-buffers/docs/javatutorial</a></p>
</blockquote>
<p>简单来说使用protobuf，可以将代码序列化为较小的二进制文件，且处理效率高，适合网络传输之类的操作。</p>
<h2 id="Java版本"><a href="#Java版本" class="headerlink" title="Java版本"></a>Java版本</h2><h3 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h3><blockquote>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> tutorial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> java_package = <span class="string">&quot;com.example.tutorial&quot;</span>;</span><br><span class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">&quot;AddressBookProtos&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">enum </span><span class="title class_">PhoneType</span> &#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">message </span><span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> PhoneType type = <span class="number">2</span> [default = HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">AddressBook</span> &#123;</span><br><span class="line">  <span class="keyword">repeated</span> Person people = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><code>package</code>用来防止命名冲突。</li>
<li><code>java_package</code>用来指定生成的类所在的包，如果不指定，那么将会使用<code>package</code>字段指定的。</li>
<li><code>java_outer_classname</code>用来定义包含本文件中所有类的类名。如果不指定，那么会使用该文件名转换为驼峰形式作为其名称，例如”my_proto.proto”将会被转换成“MyProto”。</li>
<li>基本常见类型都有包含，如<code>bool</code>，<code>int32</code>，<code>float</code>，<code>double</code>，<code>string</code>，支持嵌套结构体。如在<code>Person</code>里面定义了<code>PhoneType</code>，意味着<code>PhoneType</code>只能是MOBILE，HOME，WORK中的其中一个。</li>
<li>像<code>=1</code>，<code>=2</code>这样的标记，代表了该字段在二进制编码中使用的唯一标记。标记从<code>1-15</code>相比于更高的数字使用了更少的字节去编码。所以作为一种优化，你可以将它们使用在那些经常被使用的或者重复的元素，而将16或者更高的数字使用在不常用的可选元素。</li>
<li>每个字段必须要被以下几个选项修饰：<ul>
<li><code>required</code>：该字段必须提供，否则该message将被视为“未初始化”。而构建一个“未初始化”状态的message将会导致抛出<code>RuntimeException</code>。解析一个“未初始化”的message将会抛出一个<code>IOException</code>。除此之外必填字段和可选字段表现一致。</li>
<li><code>optional</code>：该字段非必须。如果一个可选字段没有被设置，那么一个默认值将被使用。对于简单类型，你可以自定义默认值，正如例子中的“type”字段。如果没有自定义，那么系统默认值将被使用：对于数值类型将使用0，字符串将使用空字符串，布尔值使用false。对于嵌入的message，默认值将会是默认实例，即所有字段都没有设置。</li>
<li><code>repeated</code>：表示该字段将重复任意次数（包括0）。重复数值的顺序将会在protocol buffer中保存。可以类比动态长度的数组。</li>
</ul>
</li>
<li>使用<code>require</code>的话，将来想要修改可能造成兼容性问题。</li>
</ul>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>每一个在<code>AddressBookProtos</code>类中，每个类都有它自己的<code>Builder</code>类，它是用来创建这个类的实例的。message和builder的每个字段都有自动生成的访问方法，不同的是message只有getter而builder有getter和setter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// required string name = 1;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasName</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// required int32 id = 2;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasId</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optional string email = 3;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasEmail</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// repeated .tutorial.Person.PhoneNumber phones = 4;</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PhoneNumber&gt; <span class="title function_">getPhonesList</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPhonesCount</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> PhoneNumber <span class="title function_">getPhones</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>
<p>与此同时，<code>Person.Builder</code>有相同的getter加上另外的setter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// required string name = 1;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasName</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> java.lang.String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setName</span><span class="params">(String value)</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">clearName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// required int32 id = 2;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasId</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setId</span><span class="params">(<span class="type">int</span> value)</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">clearId</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// optional string email = 3;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasEmail</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setEmail</span><span class="params">(String value)</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">clearEmail</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// repeated .tutorial.Person.PhoneNumber phones = 4;</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PhoneNumber&gt; <span class="title function_">getPhonesList</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPhonesCount</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> PhoneNumber <span class="title function_">getPhones</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">setPhones</span><span class="params">(<span class="type">int</span> index, PhoneNumber value)</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">addPhones</span><span class="params">(PhoneNumber value)</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">addAllPhones</span><span class="params">(Iterable&lt;PhoneNumber&gt; value)</span>;</span><br><span class="line"><span class="keyword">public</span> Builder <span class="title function_">clearPhones</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于那种单个的字段，都有<code>has</code>之类的方法，该方法当该字段而被设置过时返回true。每个字段都有一个<code>clear</code>方法，用来将该字段设置为其空状态。</p>
<p>重复字段具有<code>count</code>方法。</p>
<h3 id="Builder-VS-Messages"><a href="#Builder-VS-Messages" class="headerlink" title="Builder VS Messages"></a>Builder VS Messages</h3><p>被protocol buffer编译器创建的message都是不可修改的。为了创建一个message，首先需要构建一个builder，然后设置对应的值，然后调用<code>build()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">john</span> <span class="operator">=</span></span><br><span class="line">  Person.newBuilder()</span><br><span class="line">    .setId(<span class="number">1234</span>)</span><br><span class="line">    .setName(<span class="string">&quot;John Doe&quot;</span>)</span><br><span class="line">    .setEmail(<span class="string">&quot;jdoe@example.com&quot;</span>)</span><br><span class="line">    .addPhones(</span><br><span class="line">      Person.PhoneNumber.newBuilder()</span><br><span class="line">        .setNumber(<span class="string">&quot;555-4321&quot;</span>)</span><br><span class="line">        .setType(Person.PhoneType.HOME))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h3 id="标准message方法"><a href="#标准message方法" class="headerlink" title="标准message方法"></a>标准message方法</h3><p>每个message和Builder都包含一个一系列的方法让你检查或者控制整个message：</p>
<ol>
<li><code>isInitialized()</code>：是否所有的必须字段都被设置了。</li>
<li><code>toString()</code>：输出可读的字符串。</li>
<li><code>mergeFrom(Message other)</code>：（仅限builder）该方法会将other变量合并到该message中，覆盖单个变量，合并复合字段以及连接重复字段。</li>
<li><code>clear()</code>：(仅限builder)清空。</li>
</ol>
<h3 id="解析和序列化"><a href="#解析和序列化" class="headerlink" title="解析和序列化"></a>解析和序列化</h3><p>每个protocol buffer类都有读写指定类型二进制的方法。</p>
<ul>
<li><code>byte[] toByteArray()</code>：序列化对象为原来的字节数组。</li>
<li><code>static Person parseFrom(byte[] data)</code>：将一个message从二进制解析出来。</li>
<li><code>void writeTo(OutputStream output)</code>：序列化message并且将它写入一个<code>OutputStream</code>。</li>
<li><code>static Person parseFrom(InputStream input)</code>：从一个<code>InputStream</code>读取和解析一个message。</li>
</ul>
<blockquote>
<p>注意：如果想要增加更丰富的功能，最好的方式是将自动生成的类包裹进一个应用程序特定的类。</p>
</blockquote>
<h3 id="写一个message"><a href="#写一个message" class="headerlink" title="写一个message"></a>写一个message</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.tutorial.AddressBookProtos.AddressBook;</span><br><span class="line"><span class="keyword">import</span> com.example.tutorial.AddressBookProtos.Person;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddPerson</span> &#123;</span><br><span class="line">  <span class="comment">// This function fills in a Person message based on user input.</span></span><br><span class="line">  <span class="keyword">static</span> Person <span class="title function_">PromptForAddress</span><span class="params">(BufferedReader stdin,</span></span><br><span class="line"><span class="params">                                 PrintStream stdout)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Person.<span class="type">Builder</span> <span class="variable">person</span> <span class="operator">=</span> Person.newBuilder();</span><br><span class="line"></span><br><span class="line">    stdout.print(<span class="string">&quot;Enter person ID: &quot;</span>);</span><br><span class="line">    person.setId(Integer.valueOf(stdin.readLine()));</span><br><span class="line"></span><br><span class="line">    stdout.print(<span class="string">&quot;Enter name: &quot;</span>);</span><br><span class="line">    person.setName(stdin.readLine());</span><br><span class="line"></span><br><span class="line">    stdout.print(<span class="string">&quot;Enter email address (blank for none): &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> stdin.readLine();</span><br><span class="line">    <span class="keyword">if</span> (email.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      person.setEmail(email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      stdout.print(<span class="string">&quot;Enter a phone number (or leave blank to finish): &quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">number</span> <span class="operator">=</span> stdin.readLine();</span><br><span class="line">      <span class="keyword">if</span> (number.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Person.PhoneNumber.<span class="type">Builder</span> <span class="variable">phoneNumber</span> <span class="operator">=</span></span><br><span class="line">        Person.PhoneNumber.newBuilder().setNumber(number);</span><br><span class="line"></span><br><span class="line">      stdout.print(<span class="string">&quot;Is this a mobile, home, or work phone? &quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> stdin.readLine();</span><br><span class="line">      <span class="keyword">if</span> (type.equals(<span class="string">&quot;mobile&quot;</span>)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.MOBILE);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;home&quot;</span>)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.HOME);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;work&quot;</span>)) &#123;</span><br><span class="line">        phoneNumber.setType(Person.PhoneType.WORK);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stdout.println(<span class="string">&quot;Unknown phone type.  Using default.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      person.addPhones(phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Main function:  Reads the entire address book from a file,</span></span><br><span class="line">  <span class="comment">//   adds one person based on user input, then writes it back out to the same</span></span><br><span class="line">  <span class="comment">//   file.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;Usage:  AddPerson ADDRESS_BOOK_FILE&quot;</span>);</span><br><span class="line">      System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddressBook.<span class="type">Builder</span> <span class="variable">addressBook</span> <span class="operator">=</span> AddressBook.newBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the existing address book.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      addressBook.mergeFrom(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(args[<span class="number">0</span>]));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      System.out.println(args[<span class="number">0</span>] + <span class="string">&quot;: File not found.  Creating a new file.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add an address.</span></span><br><span class="line">    addressBook.addPeople(</span><br><span class="line">      PromptForAddress(<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in)),</span><br><span class="line">                       System.out));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write the new address book back to disk.</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(args[<span class="number">0</span>]);</span><br><span class="line">    addressBook.build().writeTo(output);</span><br><span class="line">    output.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="读取一个message"><a href="#读取一个message" class="headerlink" title="读取一个message"></a>读取一个message</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.tutorial.AddressBookProtos.AddressBook;</span><br><span class="line"><span class="keyword">import</span> com.example.tutorial.AddressBookProtos.Person;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListPeople</span> &#123;</span><br><span class="line">  <span class="comment">// Iterates though all people in the AddressBook and prints info about them.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Print</span><span class="params">(AddressBook addressBook)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Person person: addressBook.getPeopleList()) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Person ID: &quot;</span> + person.getId());</span><br><span class="line">      System.out.println(<span class="string">&quot;  Name: &quot;</span> + person.getName());</span><br><span class="line">      <span class="keyword">if</span> (person.hasEmail()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;  E-mail address: &quot;</span> + person.getEmail());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Person.PhoneNumber phoneNumber : person.getPhonesList()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (phoneNumber.getType()) &#123;</span><br><span class="line">          <span class="keyword">case</span> MOBILE:</span><br><span class="line">            System.out.print(<span class="string">&quot;  Mobile phone #: &quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> HOME:</span><br><span class="line">            System.out.print(<span class="string">&quot;  Home phone #: &quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> WORK:</span><br><span class="line">            System.out.print(<span class="string">&quot;  Work phone #: &quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(phoneNumber.getNumber());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Main function:  Reads the entire address book from a file and prints all</span></span><br><span class="line">  <span class="comment">//   the information inside.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">      System.err.println(<span class="string">&quot;Usage:  ListPeople ADDRESS_BOOK_FILE&quot;</span>);</span><br><span class="line">      System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the existing address book.</span></span><br><span class="line">    <span class="type">AddressBook</span> <span class="variable">addressBook</span> <span class="operator">=</span></span><br><span class="line">      AddressBook.parseFrom(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(args[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    Print(addressBook);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓展protocol-buffer"><a href="#拓展protocol-buffer" class="headerlink" title="拓展protocol buffer"></a>拓展protocol buffer</h3><p>迟早当你想要拓展protocol buffer的定义的时候，如果你想要你的新的buffers向后兼容，然后你的老的buffers向前兼容，那么你需要遵循如下几个规则：</p>
<ul>
<li>你不能修改任何已经存在的字段的tag number</li>
<li>不能删除和增加任何必须字段</li>
<li>可以删除可选或者重复字段</li>
<li>你可以新增可选或者重复字段，但是你必须使用新的tag number（指从未被用过的数字，即使对于被删除的字段）</li>
</ul>
<p>如果你遵循了这些规则，老代码将会能够读取新的消息并且忽略新字段。对于老代码，那些被删除的可选字段将会被设置为他们的默认值，而那些重复字段将会变为空。新的代码将会透明的读取老message。但是，记住，新增的可选字段将不会出现在老的message中，所以你将需要使用<code>hasXXX</code>来判断他们是否被设置，或者在.proto文件中加上一个合理的[default = value]。如果你新增了一个重复字段，你的新代码将不能分辨它是因为新代码没有设置导致的，还是因为老代码中没有这个字段，因为它并没有<code>hasXXX</code>方法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/04/28/EVM%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/04/28/EVM%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">EVM学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-04-28 12:19:15" itemprop="dateCreated datePublished" datetime="2018-04-28T12:19:15+08:00">2018-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-13 22:00:04" itemprop="dateModified" datetime="2019-01-13T22:00:04+08:00">2019-01-13</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/04/28/EVM%E5%AD%A6%E4%B9%A0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/04/28/EVM学习/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="EVM学习"><a href="#EVM学习" class="headerlink" title="EVM学习"></a>EVM学习</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1969f3761208">深入理解以太坊虚拟机系列一：EVM汇编代码的介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9df8d15418ed">深入理解以太坊虚拟机系列二：固定长度数据类型的表示方法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/af5721c79505">深入理解以太坊虚拟机系列三：动态数据类型的表示方式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d0e8e825d41b">深入理解以太坊虚拟机系列四：ABI编码外部方法调用的格式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d9137e87c9d3">深入理解以太坊虚拟机系列五：一个新合约被创建后会发生什么</a></p>
</blockquote>
<p>每个存储槽都可以存储32个字节。所以为了优化，如果可以的话，会将两个小一点的数据类型进行打包然后存储在同一个存储槽中。</p>
<h3 id="存储变量"><a href="#存储变量" class="headerlink" title="存储变量"></a>存储变量</h3><p>打包存储</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>打包存储</p>
<h3 id="定长数组"><a href="#定长数组" class="headerlink" title="定长数组"></a>定长数组</h3><p>不打包</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>对于<code>mapping(uint256 =&gt; uint256) items</code>其中的value的存储地址的计算规则为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keccak256(bytes32(key) + bytes32(position))</span><br></pre></td></tr></table></figure>
<p>其中<code>key</code>为map的key，<code>positoin</code>为该映射变量的位置。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line">contract C &#123;</span><br><span class="line">    mapping(uint256 =&gt; uint256) items;</span><br><span class="line">    function C() &#123;</span><br><span class="line">      items[0xC0FEFE] = 0x42;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">key = 0xC0FEFE, position = 0</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; keccak256(bytes32(0xC0FEFE) + bytes32(0))</span></span><br><span class="line">&#x27;79826054ee948a209ff4a6c9064d7398508d2c1909a392f899d301c6d232187c&#x27;</span><br></pre></td></tr></table></figure>
<p>这里<code>position</code>为0，这是因为items是第一个变量。</p>
<p>如果mapping的value存储的是一个struct，那么结构体成员是依次排列的。</p>
<p>映射不会打包，即存储单位为32字节。</p>
<h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>在solidity中数组是一种更加昂贵的映射。数组里面的元素会按照顺序排列在存储器中。</p>
<p>但是请记住，对于这些存储槽的每次访问实际上就像数据库中的key-value的查找一样。访问一个数组的元素和访问一个映射的元素是没有什么区别的。</p>
<p>所以其实<code>[]uint256</code>和<code>mapping(uint256=&gt;uint256)</code>是一样的，只不过后者多了一点特征：</p>
<ol>
<li>length表示一共有多少元素</li>
<li>边界检查。当读取或者写入时索引值大于length就会报错</li>
<li>比映射更加复杂的存储打包行为</li>
<li>当数组变小的时候，自动清除未使用的存储槽</li>
<li>bytes和string的特殊优化让短数组（小于32字节）存储更加高效</li>
</ol>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>拥有4个元素的<code>uint128[]</code>刚好需要2个存储槽（再加1个存储槽用来存储长度）。长度存在第一个，然后后两个存储槽里面每个存储槽存两个元素。</p>
<h4 id="字节数组和字符串"><a href="#字节数组和字符串" class="headerlink" title="字节数组和字符串"></a>字节数组和字符串</h4><p><code>bytes</code>和<code>string</code>是为字节和字符进行优化的特殊数组类型。如果数组的长度小于31字节，只需要1个存储槽来存储整个数组。长一点的字节数组跟正常数组的表示方式差不多。</p>
<h2 id="ABI编码"><a href="#ABI编码" class="headerlink" title="ABI编码"></a>ABI编码</h2><p>调用函数的payload格式：</p>
<p>前4个字节为方法选择器，后面的都是方法的参数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/03/12/%E5%AD%A6%E4%B9%A0Solidity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/12/%E5%AD%A6%E4%B9%A0Solidity/" class="post-title-link" itemprop="url">学习Solidity</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-12 10:45:54" itemprop="dateCreated datePublished" datetime="2018-03-12T10:45:54+08:00">2018-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-06 15:08:17" itemprop="dateModified" datetime="2019-01-06T15:08:17+08:00">2019-01-06</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/03/12/%E5%AD%A6%E4%B9%A0Solidity/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/12/学习Solidity/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Solidity介绍"><a href="#Solidity介绍" class="headerlink" title="Solidity介绍"></a>Solidity介绍</h1><blockquote>
<ul>
<li>官网：<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/">http://solidity.readthedocs.io/en/develop/</a></li>
</ul>
<ul>
<li><p>Solidity 是一个面向合约的高级语言，其语法类似于JavaScript 。是运行在以太坊虚拟机中的代码。</p>
</li>
<li><p>Solidity 是静态类型的编程语言，编译期间会检查其数据类型。支持继承、类和复杂的用户定义类型。</p>
</li>
<li><p>在线体验： <a target="_blank" rel="noopener" href="https://remix.ethereum.org">https://remix.ethereum.org</a></p>
<p>但是这平台只能撰写和编译Solidity代码，如果想真正运行代码的话，需要有一个以太坊的本地环境。</p>
</li>
</ul>
</blockquote>
<h1 id="Solidity源文件的布局"><a href="#Solidity源文件的布局" class="headerlink" title="Solidity源文件的布局"></a>Solidity源文件的布局</h1><h2 id="Version-Pragma"><a href="#Version-Pragma" class="headerlink" title="Version Pragma"></a>Version Pragma</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br></pre></td></tr></table></figure>
<p>这代表着该源文件只会被版本为从<code>0.4.0</code>到<code>0.5.0</code>之间的编译器编译（后面一个条件是由<code>^</code>来指出）。更复杂的编译器限定语法和npm一样。</p>
<h2 id="导入语句"><a href="#导入语句" class="headerlink" title="导入语句"></a>导入语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;filename&quot;;</span><br><span class="line">import * as symbolName from &quot;filename&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="State-Sariables"><a href="#State-Sariables" class="headerlink" title="State Sariables"></a>State Sariables</h2><p>会在合约存储中持久存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData; // State variable</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>函数是合约中的执行单元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    function bid() public payable &#123; // Function</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Function-Modifiers"><a href="#Function-Modifiers" class="headerlink" title="Function Modifiers"></a>Function Modifiers</h2><p>声明函数执行的条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    address public seller;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123; // Modifier</span><br><span class="line">        require(msg.sender == seller);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function abort() public onlySeller &#123; // Modifier usage</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><p>提供日志功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); // Event</span><br><span class="line"></span><br><span class="line">    function bid() public payable &#123;</span><br><span class="line">        // ...</span><br><span class="line">        HighestBidIncreased(msg.sender, msg.value); // Triggering event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Struct-Types"><a href="#Struct-Types" class="headerlink" title="Struct Types"></a>Struct Types</h2><p>结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Ballot &#123;</span><br><span class="line">    struct Voter &#123; // Struct</span><br><span class="line">        uint weight;</span><br><span class="line">        bool voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Enum-Types"><a href="#Enum-Types" class="headerlink" title="Enum Types"></a>Enum Types</h2><p>枚举类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    enum State &#123; Created, Locked, Inactive &#125; // Enum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>被赋值的时候为值传递，即会被原样复制一份。</p>
<h3 id="Boolean（布尔）"><a href="#Boolean（布尔）" class="headerlink" title="Boolean（布尔）"></a>Boolean（布尔）</h3><p>存在短路效应</p>
<h3 id="Integers（整数）"><a href="#Integers（整数）" class="headerlink" title="Integers（整数）"></a>Integers（整数）</h3><p><code>int/uint</code>都支持声明位数，规则为<code>int8/uint8</code>到<code>int256/uint256</code>以8为步长都支持。除法操作始终会截断，除非操作数都是字面值。<code>2**2</code>代表2的2次方。</p>
<p>注意：对负数进行右移操作会导致结果接近0。</p>
<h3 id="Fixed-Point-Numbers（定点数）"><a href="#Fixed-Point-Numbers（定点数）" class="headerlink" title="Fixed Point Numbers（定点数）"></a>Fixed Point Numbers（定点数）</h3><p>注意：还未完全支持，只能声明不能赋值或被赋值。</p>
<h3 id="Address（地址）"><a href="#Address（地址）" class="headerlink" title="Address（地址）"></a>Address（地址）</h3><p>20字节长。</p>
<p>支持操作：<code>&lt;=</code>，<code>&lt;</code>，<code>==</code>，<code>!=</code>，<code>&gt;=</code>，<code>&gt;</code></p>
<p>注意：从<code>0.5.0</code>版本开始合约只能从地址显式转换。</p>
<p>拥有的成员：</p>
<ul>
<li><code>balance</code>：用来查询账户余额</li>
<li><code>transfer</code>：用来向某个账户转账。如果转账失败，那么会产生异常并回滚。</li>
<li><code>send</code>：和<code>transfer</code>对应的更底层的方法。如果转账失败那么<code>send</code>将会返回false，而不会产生异常。</li>
<li><code>call</code>：接收任意个数任意类型的参数。返回一个bool代表执行是否成功。但是无法获取执行的返回值。可以设置供给的<code>gas()</code>和<code>value()</code></li>
<li><code>callcode</code>：不推荐使用，未来将会被移除。</li>
<li><code>delegatecall</code>：只执行指定地址的代码</li>
</ul>
<h3 id="Fixed-size-byte-arrays（定长字节数组）"><a href="#Fixed-size-byte-arrays（定长字节数组）" class="headerlink" title="Fixed-size byte arrays（定长字节数组）"></a>Fixed-size byte arrays（定长字节数组）</h3><p>支持<code>byte</code>,<code>byte1</code>…<code>byte32</code>，其中<code>byte</code>是<code>byte1</code>的别名。</p>
<p>支持操作：<code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, <code>&gt;</code>，<code>&amp;</code>, <code>|</code>, <code>^</code>，<code>~</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，索引操作</p>
<p>拥有的成员：<code>.length</code>只读，返回长度</p>
<h3 id="Dynamically-sized-byte-array（变长字节数组）"><a href="#Dynamically-sized-byte-array（变长字节数组）" class="headerlink" title="Dynamically-sized byte array（变长字节数组）"></a>Dynamically-sized byte array（变长字节数组）</h3><p><code>bytes</code>和<code>string</code>都是引用类型，即赋值的时候仅仅是引用传递。前者是动态长度的byte数组后者是动态长度的utf-8字符。</p>
<h3 id="Address-Literals（地址字面值）"><a href="#Address-Literals（地址字面值）" class="headerlink" title="Address Literals（地址字面值）"></a>Address Literals（地址字面值）</h3><p>通过校验和检验的十六进制常量。</p>
<h3 id="Rational-and-Integer-Literals（有理数和整数常量）"><a href="#Rational-and-Integer-Literals（有理数和整数常量）" class="headerlink" title="Rational and Integer Literals（有理数和整数常量）"></a>Rational and Integer Literals（有理数和整数常量）</h3><p>支持科学计数法。</p>
<p>字面值之间的计算并不会导致截断，比如<code>(2**800 + 1) - 2**800</code>将会得到1（类型为uint8），尽管中间结果已经超出了机器字长。<code>.5 * 8</code>将会得到4，尽管操作数中有小数。<code>5/2=2.5</code></p>
<p>位操作的两个操作数不允许小数参与，另外指数运算中，指数不能为小数，因为可能会产生无理数。</p>
<p>当字面值和非字面值进行运算的时候，字面值将会变成非字面值。</p>
<p>注意，在Solidity中没有浮点数类型，因为浮点数运算会导致精度问题，而在操作中所有的浮点数都可以被用<code>wei</code>来表示。</p>
<h3 id="String-Literals（字符串字面值）"><a href="#String-Literals（字符串字面值）" class="headerlink" title="String Literals（字符串字面值）"></a>String Literals（字符串字面值）</h3><p>可以用双引号或者单引号包裹，<code>&quot;foo&quot;</code>占3个字节，没有C语言中的<code>/0</code>。支持转义字符。</p>
<h3 id="Hexadecimal-Literals（十六进制字面值）"><a href="#Hexadecimal-Literals（十六进制字面值）" class="headerlink" title="Hexadecimal Literals（十六进制字面值）"></a>Hexadecimal Literals（十六进制字面值）</h3><p><code>hex&quot;001122FF&quot;</code>或者<code>hex&#39;001122FF&#39;</code></p>
<h3 id="Enums（枚举）"><a href="#Enums（枚举）" class="headerlink" title="Enums（枚举）"></a>Enums（枚举）</h3><p>可以转换为整数类型</p>
<h3 id="Function-Types（函数类型）"><a href="#Function-Types（函数类型）" class="headerlink" title="Function Types（函数类型）"></a>Function Types（函数类型）</h3><p>函数分为<code>internal</code>和<code>external</code>两种：内部的函数只能在当前合约内部调用。外部函数由地址和方法签名组成，只能被外部函数传入或者外部函数返回。</p>
<p>函数类型声明语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure>
<p>默认函数类型为<code>internal</code>。</p>
<p>有两种方式来访问当前合约的公开函数，一种是直接用名字，一种是<code>this.f</code>。前者会导致内部函数，后者会导致外部函数。</p>
<p>内部函数使用例子： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  // internal functions can be used in internal library functions because</span><br><span class="line">  // they will be part of the same code context</span><br><span class="line">  function map(uint[] memory self, function (uint) pure returns (uint) f)</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (uint[] memory r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = new uint[](self.length);</span><br><span class="line">    for (uint i = 0; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function reduce(</span><br><span class="line">    uint[] memory self,</span><br><span class="line">    function (uint, uint) pure returns (uint) f</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (uint r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = self[0];</span><br><span class="line">    for (uint i = 1; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function range(uint length) internal pure returns (uint[] memory r) &#123;</span><br><span class="line">    r = new uint[](length);</span><br><span class="line">    for (uint i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils for *;</span><br><span class="line">  function pyramid(uint l) public pure returns (uint) &#123;</span><br><span class="line">    return ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  function square(uint x) internal pure returns (uint) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  function sum(uint x, uint y) internal pure returns (uint) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部函数使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    function(bytes memory) external callback;</span><br><span class="line">  &#125;</span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  function query(bytes data, function(bytes memory) external callback) public &#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    NewRequest(requests.length - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  function reply(uint requestID, bytes response) public &#123;</span><br><span class="line">    // Here goes the check that the reply comes from a trusted source</span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(0x1234567); // known contract</span><br><span class="line">  function buySomething() &#123;</span><br><span class="line">    oracle.query(&quot;USD&quot;, this.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  function oracleResponse(bytes response) public &#123;</span><br><span class="line">    require(msg.sender == address(oracle));</span><br><span class="line">    // Use the data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>复杂类型。因为拷贝引用类型的变量耗费很高，所以我们需要考虑是将他们存放在<code>memory</code>（非持久化）还是<code>storage</code>（状态变量所存放的地方）里面。</p>
<h3 id="数据存储位置"><a href="#数据存储位置" class="headerlink" title="数据存储位置"></a>数据存储位置</h3><p>每个复杂类型如<code>Arrays</code>和<code>structs</code>都可以指明存储位置，<code>memory</code>或<code>storage</code>。</p>
<p>默认情况下，函数的参数和返回值为<code>memory</code>类型，局部变量为<code>storage</code>，状态变量强制为<code>storage</code>。外部函数的参数强制为<code>calldata</code>。</p>
<p><code>storage</code>和<code>memory</code>之间的相互赋值又或者是赋值给一个状态变量都会产生一个全新的拷贝。<code>storage</code>引用类型赋值给本地<code>storage</code>变量的仅仅是一个引用。<code>memory-stored reference type</code>之间的相互赋值并不会产生新的拷贝。</p>
<blockquote>
<p>总结：</p>
<ol>
<li><code>storage</code>引用类型和<code>storage</code>引用类型，为引用传递</li>
<li><code>storage</code>引用类型和<code>memory</code>引用类型，会产生拷贝</li>
<li><code>memory</code>引用类型和<code>memory</code>引用类型之间，为引用传递</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; // the data location of x is storage</span><br><span class="line"></span><br><span class="line">    // the data location of memoryArray is memory</span><br><span class="line">    function f(uint[] memoryArray) public &#123;</span><br><span class="line">        x = memoryArray; // works, copies the whole array to storage</span><br><span class="line">        var y = x; // works, assigns a pointer, data location of y is storage</span><br><span class="line">        y[7]; // fine, returns the 8th element</span><br><span class="line">        y.length = 2; // fine, modifies x through y</span><br><span class="line">        delete x; // fine, clears the array, also modifies y</span><br><span class="line">        // The following does not work; it would need to create a new temporary /</span><br><span class="line">        // unnamed array in storage, but storage is &quot;statically&quot; allocated:</span><br><span class="line">        // y = memoryArray;</span><br><span class="line">        // This does not work either, since it would &quot;reset&quot; the pointer, but there</span><br><span class="line">        // is no sensible location it could point to.</span><br><span class="line">        // delete y;</span><br><span class="line">        g(x); // calls g, handing over a reference to x</span><br><span class="line">        h(x); // calls h and creates an independent, temporary copy in memory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class="line">    function h(uint[] memoryArray) public &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>可以动态大小也可以固定大小。</p>
<p><code>bytes</code>和<code>string</code>为特殊的数组。<code>string</code>和<code>bytes</code>相同，但是目前不支持<code>length</code>和下标访问操作。</p>
<p>更推荐使用<code>bytes</code>，相比于<code>byte[]</code>。</p>
<p>可以将数组标记为<code>public</code>，然后<code>solidity</code>将会创建相应的<code>getter</code>，下标为<code>getter</code>的参数。</p>
<h3 id="分配内存数组"><a href="#分配内存数组" class="headerlink" title="分配内存数组"></a>分配内存数组</h3><p>不能像<code>storage</code>数组一样通过修改<code>length</code>字段来修改数组大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint len) public pure &#123;</span><br><span class="line">        uint[] memory a = new uint[](7);</span><br><span class="line">        bytes memory b = new bytes(len);</span><br><span class="line">        // Here we have a.length == 7 and b.length == len</span><br><span class="line">        a[6] = 8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Array-Literals-Inline-Arrays（数组字面值-行内数组）"><a href="#Array-Literals-Inline-Arrays（数组字面值-行内数组）" class="headerlink" title="Array Literals / Inline Arrays（数组字面值/行内数组）"></a>Array Literals / Inline Arrays（数组字面值/行内数组）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        g([uint(1), 2, 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    function g(uint[3] _data) public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>[1, 2, 3]</code>的类型为<code>uint8[3] memory</code>。无法将一个数组字面值赋值给一个动态大小数组。</p>
<p>成员有：</p>
<ul>
<li><code>length</code>：<code>storage</code>动态数组可以通过修改length来改变数组容量，但是<code>memory</code>不可以。越界访问并不会触发扩容，<code>memory</code>动态数组一旦被创建他们的大小是固定的。</li>
<li><code>push</code>：<code>storage</code>动态数组有<code>push</code>函数，返回新长度。</li>
</ul>
<h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>成员不能是自己。</p>
<h3 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h3><p>声明语法<code>mapping(_KeyType =&gt; _ValueType)</code>。其中<code>_KetType</code>可以是任意除了<code>mapping</code>的类型。<code>_ValueType</code>可以为任意类型。</p>
<p>实际是一个哈希表。</p>
<p><code>Mapping</code>变量只能为状态变量或者内部函数的<code>storage</code>引用类型。</p>
<h2 id="涉及左值的运算符"><a href="#涉及左值的运算符" class="headerlink" title="涉及左值的运算符"></a>涉及左值的运算符</h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><code>delete a</code>将<code>a</code>置成其零值，比如对于动态长度数组将会变为长度为0；固定长度的数组中的所有元素被重置；对于struct而言所有字段将会被重置。但是不会对mapping类型生效。</p>
<p><code>delete</code>操作就像赋值操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        delete x; // sets x to 0, does not affect data</span><br><span class="line">        delete data; // sets data to 0, does not affect x which still holds a copy</span><br><span class="line">        uint[] storage y = dataArray;</span><br><span class="line">        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also</span><br><span class="line">        // y is affected which is an alias to the storage object</span><br><span class="line">        // On the other hand: &quot;delete y&quot; is not valid, as assignments to local variables</span><br><span class="line">        // referencing storage objects can only be made from existing storage objects.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>如果一个运算符应用于不同类型的，那么编译器会尝试转换一个操作数类型为另一个操作数类型（赋值操作类似）。总体来说，两个值类型之间的隐式转换在不丢失信息的时候是可能的。</p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p><code>for (var i = 0; i &lt; 2000; i++) &#123; … &#125;</code>，该循环将永远不会停止，因为<code>i</code>将会被推断为<code>uint8</code>，而其不会超过2000。</p>
<h1 id="单位以及全局变量"><a href="#单位以及全局变量" class="headerlink" title="单位以及全局变量"></a>单位以及全局变量</h1><h2 id="Ether-Units"><a href="#Ether-Units" class="headerlink" title="Ether Units"></a>Ether Units</h2><p><code>wei</code>， <code>finney</code>， <code>szabo</code> ， <code>ether</code>，如果没有单位那么默认单位为<code>wei</code>。</p>
<h2 id="Time-Units"><a href="#Time-Units" class="headerlink" title="Time Units"></a>Time Units</h2><p><code>seconds</code>, <code>minutes</code>, <code>hours</code>, <code>days</code>, <code>weeks</code> 和 <code>years</code></p>
<ul>
<li><code>1 == 1 seconds</code></li>
<li><code>1 minutes == 60 seconds</code></li>
<li><code>1 hours == 60 minutes</code></li>
<li><code>1 days == 24 hours</code></li>
<li><code>1 weeks == 7 days</code></li>
<li><code>1 years == 365 days</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(uint start, uint daysAfter) public &#123;</span><br><span class="line">    if (now &gt;= start + daysAfter * 1 days) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区块和交易属性"><a href="#区块和交易属性" class="headerlink" title="区块和交易属性"></a>区块和交易属性</h3><ul>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>: hash of the given block - only works for 256 most recent blocks excluding current</li>
<li><code>block.coinbase</code> (<code>address</code>): current block miner’s address</li>
<li><code>block.difficulty</code> (<code>uint</code>): current block difficulty</li>
<li><code>block.gaslimit</code> (<code>uint</code>): current block gaslimit</li>
<li><code>block.number</code> (<code>uint</code>): current block number</li>
<li><code>block.timestamp</code> (<code>uint</code>): current block timestamp as seconds since unix epoch</li>
<li><code>msg.data</code> (<code>bytes</code>): complete calldata</li>
<li><code>msg.gas</code> (<code>uint</code>): remaining gas</li>
<li><code>msg.sender</code> (<code>address</code>): sender of the message (current call)</li>
<li><code>msg.sig</code> (<code>bytes4</code>): first four bytes of the calldata (i.e. function identifier)</li>
<li><code>msg.value</code> (<code>uint</code>): number of wei sent with the message</li>
<li><code>now</code> (<code>uint</code>): current block timestamp (alias for <code>block.timestamp</code>)</li>
<li><code>tx.gasprice</code> (<code>uint</code>): gas price of the transaction</li>
<li><code>tx.origin</code> (<code>address</code>): sender of the transaction (full call chain)</li>
</ul>
<blockquote>
<p>注意：<code>msg</code>的所有的成员会随每次外部函数调用而改变。只能获取最近的256个区块哈希。</p>
</blockquote>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><code>assert(bool condition)</code>:</p>
<p>throws if the condition is not met - to be used for internal errors. 用于内部错误。</p>
<p><code>require(bool condition)</code>:</p>
<p>throws if the condition is not met - to be used for errors in inputs or external components. 可以用于内部或者外部。</p>
<p><code>revert()</code>:</p>
<p>abort execution and revert state changes。终止执行，并回滚状态。</p>
<h3 id="数学和密码学函数"><a href="#数学和密码学函数" class="headerlink" title="数学和密码学函数"></a>数学和密码学函数</h3><ul>
<li><code>addmod(uint x, uint y, uint k) returns (uint)</code></li>
</ul>
<p>计算 <code>(x + y) % k</code> </p>
<ul>
<li><code>mulmod(uint x, uint y, uint k) returns (uint)</code></li>
</ul>
<p>计算<code>(x * y) % k</code> </p>
<ul>
<li><code>keccak256(...) returns (bytes32)</code></li>
</ul>
<p>计算<code>Ethereum-SHA-3 (Keccak-256) hash</code></p>
<ul>
<li><code>sha256(...) returns (bytes32)</code></li>
</ul>
<p>计算<code>SHA-256 hash</code></p>
<ul>
<li><code>sha3(...) returns (bytes32)</code></li>
</ul>
<p><code>keccak256</code>的别名</p>
<ul>
<li><code>ripemd160(...) returns (bytes20)</code></li>
</ul>
<p>计算<code>RIPEMD-160 hash</code></p>
<ul>
<li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code></li>
</ul>
<p>根据椭圆曲线签名得到的公钥恢复地址</p>
<h3 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h3><ul>
<li><code>&lt;address&gt;.balance</code> (<code>uint256</code>)</li>
</ul>
<ul>
<li><code>&lt;address&gt;.transfer(uint256 amount)</code></li>
</ul>
<p>若失败，抛出异常</p>
<ul>
<li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code></li>
</ul>
<p>若失败，返回false</p>
<ul>
<li><code>&lt;address&gt;.call(...) returns (bool)</code></li>
</ul>
<p>若失败，返回false</p>
<ul>
<li><code>&lt;address&gt;.callcode(...) returns (bool)</code></li>
</ul>
<p>不推荐使用，未来将会被移除</p>
<ul>
<li><code>&lt;address&gt;.delegatecall(...) returns (bool)</code></li>
</ul>
<h3 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关</h3><ul>
<li><code>this</code></li>
</ul>
<p>代表当前合约，可以被显示的转化成地址</p>
<ul>
<li><code>selfdestruct(address recipient)</code></li>
</ul>
<p>销毁当前合约，并将余额发送到指定地址</p>
<ul>
<li><code>suicide(address recipient)</code></li>
</ul>
<p><code>selfdestruct</code>的别名</p>
<h1 id="表达式和控制结构"><a href="#表达式和控制结构" class="headerlink" title="表达式和控制结构"></a>表达式和控制结构</h1><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p> <code>if</code>, <code>else</code>, <code>while</code>, <code>do</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>? :</code></p>
<p>条件中括号不能被省略。</p>
<p>条件中不允许非布尔值转化为布尔值。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="内部函数调用"><a href="#内部函数调用" class="headerlink" title="内部函数调用"></a>内部函数调用</h3><p>在EVM被翻译为<code>jump</code>指令。</p>
<h3 id="外部函数调用"><a href="#外部函数调用" class="headerlink" title="外部函数调用"></a>外部函数调用</h3><p>用法类似<code>c.g(2)</code>，其中<code>c</code>为一个合约实例， 这种情况下调用将会通过消息来调用，而不是通过<code>jump</code>。</p>
<p>注意在构造器中不能使用<code>this</code>来调用其他函数，因为当时合约还未被创建。</p>
<p>其他合约的方法通过外部调用来实现，在外部调用的时候，可以使用<code>.gas()</code>和<code>.value()</code>来说明发送的<code>Wei</code>数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    function info() public payable returns (uint ret) &#123; return 42; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    function setFeed(address addr) public &#123; feed = InfoFeed(addr); &#125;</span><br><span class="line">    function callFeed() public &#123; feed.info.value(10).gas(800)(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>payable</code>使得<code>.value()</code>生效</p>
<p><code>feed = InfoFeed(addr);</code>将地址强制转换成合约，并不会调用构造器。</p>
<p><code>feed.info.value(10).gas(800)();</code>发送了10wei，并且限制了最高消费800wei。这里注意如果没有最后的括号的话，那么函数将不会执行。</p>
<blockquote>
<p>警告：任何和另一个合约的交互都潜在的危险，尤其在那个合约的代码没有事先知晓的情况下。当前合约交过控制权到被调用合约，而这意味着他可以做任何事情。即使被调用的合约是继承于一个已知合约，但是继承合约仅仅需要满足正确的接口即可，但是他的实现却可以是任意的，因此会造成危险。另外，需要注意防止它调用了你系统中的其他合约或者甚至在第一个调用结束前又回到了调用者。这意味着被调用合约能够通过它的函数来修改调用者的状态。应该以如下形式书写合约，比如：在修改完合约状态之后再去调用外部函数，以此来避免被重入利用。</p>
</blockquote>
<h3 id="通过new来创建合约"><a href="#通过new来创建合约" class="headerlink" title="通过new来创建合约"></a>通过<code>new</code>来创建合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function D(uint a) public payable &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    D d = new D(4); // will be executed as part of C&#x27;s constructor</span><br><span class="line"></span><br><span class="line">    function createD(uint arg) public &#123;</span><br><span class="line">        D newD = new D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createAndEndowD(uint arg, uint amount) public payable &#123;</span><br><span class="line">        // Send ether along with the creation</span><br><span class="line">        D newD = (new D).value(amount)(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在创建合约的同时是能够发送以太币。</p>
<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function f() public pure returns (uint, bool, uint) &#123;</span><br><span class="line">        return (7, true, 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // Declares and assigns the variables. Specifying the type explicitly is not possible.</span><br><span class="line">        var (x, b, y) = f();</span><br><span class="line">        // Assigns to a pre-existing variable.</span><br><span class="line">        (x, y) = (2, 7);</span><br><span class="line">        // Common trick to swap values -- does not work for non-value storage types.</span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        // Components can be left out (also for variable declarations).</span><br><span class="line">        // If the tuple ends in an empty component,</span><br><span class="line">        // the rest of the values are discarded.</span><br><span class="line">        (data.length,) = f(); // Sets the length to 7</span><br><span class="line">        // The same can be done on the left side.</span><br><span class="line">        // If the tuple begins in an empty component, the beginning values are discarded.</span><br><span class="line">        (,data[3]) = f(); // Sets data[3] to 2</span><br><span class="line">        // Components can only be left out at the left-hand-side of assignments, with</span><br><span class="line">        // one exception:</span><br><span class="line">        (x,) = (1,);</span><br><span class="line">        // (1,) is the only way to specify a 1-component tuple, because (1) is</span><br><span class="line">        // equivalent to 1.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于Arrays和Structs的一些问题"><a href="#关于Arrays和Structs的一些问题" class="headerlink" title="关于Arrays和Structs的一些问题"></a>关于Arrays和Structs的一些问题</h3><p>对于一些像<code>Arrays</code>和<code>Structs</code>非值类型之间的赋值比较复杂。</p>
<p>向一个状态变量赋值总会产生一个新的拷贝。</p>
<p>只有当基本类型赋值给本地变量的情况下，才会产生新的拷贝。</p>
<p>如果一个类型为<code>struct</code>或者<code>arrays</code>的状态变量赋值给本地变量，那么本地变量将会持有状态变量的一个引用，再次被赋值并不会影响原状态变量，但是对其成员的修改将会影响原状态变量。</p>
<h2 id="作用域和声明"><a href="#作用域和声明" class="headerlink" title="作用域和声明"></a>作用域和声明</h2><p>刚被声明的变量初始值默认值从字节的角度来看都是0字节。</p>
<p>一个在函数内声明的变量，不论在什么位置，作用域都是整个函数，和JS类似，Solidity中并不存在块作用域，且也存在声明上移的机制。</p>
<h2 id="错误处理：Assert-Require-Revert-and-Exceptions"><a href="#错误处理：Assert-Require-Revert-and-Exceptions" class="headerlink" title="错误处理：Assert, Require, Revert and Exceptions"></a>错误处理：Assert, Require, Revert and Exceptions</h2><p>Solidity使用状态回滚来处理异常。</p>
<p>异常会进行向上冒泡，另外，需要注意的是对一个不存在账户调用函数将会返回成功，所以在外部调用之前应该先确保合约存在。</p>
<p><code>require</code>和<code>assert</code>的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    function sendHalf(address addr) public payable returns (uint balance) &#123;</span><br><span class="line">        require(msg.value % 2 == 0); // Only allow even numbers</span><br><span class="line">        uint balanceBeforeTransfer = this.balance;</span><br><span class="line">        addr.transfer(msg.value / 2);</span><br><span class="line">        // Since transfer throws an exception on failure and</span><br><span class="line">        // cannot call back here, there should be no way for us to</span><br><span class="line">        // still have half of the money.</span><br><span class="line">        assert(this.balance == balanceBeforeTransfer - msg.value / 2);</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会触发类似<code>assert</code>的异常的几种情况：</p>
<ol>
<li>访问一个变长/定长数组的越界下标或者负数下标</li>
<li>除法操作和取模操作对0进行(e.g. <code>5 / 0</code> or <code>23 % 0</code>)</li>
<li>试图移动负数位</li>
<li>试图将一个过大的数或者负数转换成枚举类型</li>
<li>试图调用一个未被赋值的函数</li>
<li><code>assert</code>检测条件返回失败</li>
</ol>
<p>会触发类似<code>require</code>的异常的几种情况：</p>
<ol>
<li>调用<code>throw</code></li>
<li>调用<code>require</code>并且判断的条件返回false</li>
<li>如果通过消息调用来调用一个函数，但它确并没有正确结束（可能是因为用尽gas，没有匹配的函数，或者其本身抛出了异常）。除非使用的是<code>call</code>, <code>send</code>, <code>delegatecall</code> 或 <code>callcode</code> ，他们将会返回false来代表失败</li>
<li>通过<code>new</code>创建了一个合约，但是创建并没有正确结束，可能情况和上一条类似</li>
<li>对一个没有代码的账户进行函数调用</li>
<li>如果你通过一个没有用<code>payable</code>修饰的public函数收到了以太币</li>
<li>如果你通过public getter函数收到了以太币</li>
<li>如果<code>.transfer()</code>失败了</li>
</ol>
<p><code>assert</code>类型的异常会消耗gas，而<code>require</code>类型的不会（从Metropolis版本后）</p>
<h1 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h1><h2 id="可见性和Getters"><a href="#可见性和Getters" class="headerlink" title="可见性和Getters"></a>可见性和Getters</h2><p>Solidity中有两种类型的函数调用：内部调用（并不会创建实际的EVM调用，也称为消息调用），外部调用。</p>
<p>Solidity中对于函数和状态变量有4种类型的可见性规则：</p>
<ul>
<li><code>external</code>：可以被外部合约和交易调用，在本合约内部调用的时候必须要这样使用<code>this.f()</code>。当接收大量数据的时候，很高效。</li>
<li><code>public</code>：既可以被内部调用又可以被消息调用。对于<code>public</code>的状态变量而言，会自动创建getter。</li>
<li><code>internal</code>：只能被当前合约或者子合约使用，不需要<code>this</code>关键字。</li>
<li><code>private</code>：只能被当前合约访问，但是子合约不行。</li>
</ul>
<blockquote>
<p>注意：合约中的任何东西对世界都是公开的，设置<code>private</code>仅仅是防止被外部访问和修改</p>
</blockquote>
<p>可见性修饰符，对于状态变量加在类型后面。对于函数而言，放在参数列表和返回值之间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a) private pure returns (uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) internal &#123; data = a; &#125;</span><br><span class="line">    uint public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Getter函数"><a href="#Getter函数" class="headerlink" title="Getter函数"></a>Getter函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    C c = new C();</span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint local = c.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于状态变量data而言，编译器会自动创建一个函数名字为<code>data</code>返回一个uint。这个函数在被内部调用的时候（即不用this的情况下）被解析为状态变量，而在被外部调用的时候，将被解析为函数。</p>
<p>接下来是一个更加复杂的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Complex &#123;</span><br><span class="line">    struct Data &#123;</span><br><span class="line">        uint a;</span><br><span class="line">        bytes3 b;</span><br><span class="line">        mapping (uint =&gt; uint) map;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping (uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) &#123;</span><br><span class="line">    a = data[arg1][arg2][arg3].a;</span><br><span class="line">    b = data[arg1][arg2][arg3].b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意结构体中的map字段会被忽略。</p>
<h2 id="函数修改器"><a href="#函数修改器" class="headerlink" title="函数修改器"></a>函数修改器</h2><p>被用来在函数执行之前自动检查条件。修改器是可以被继承的。</p>
<p>如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。</p>
<p>函数内可见的符号，在修改器中依旧是可见的。但是在修改器中引入的符号，在函数内却不可见，这是因为它们可能被重写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // This contract only defines a modifier but does not use</span><br><span class="line">    // it: it will be used in derived contracts.</span><br><span class="line">    // The function body is inserted where the special symbol</span><br><span class="line">    // `_;` in the definition of a modifier appears.</span><br><span class="line">    // This means that if the owner calls this function, the</span><br><span class="line">    // function is executed and otherwise, an exception is</span><br><span class="line">    // thrown.</span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    // This contract inherits the `onlyOwner` modifier from</span><br><span class="line">    // `owned` and applies it to the `close` function, which</span><br><span class="line">    // causes that calls to `close` only have an effect if</span><br><span class="line">    // they are made by the stored owner.</span><br><span class="line">    function close() public onlyOwner &#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    // Modifiers can receive arguments:</span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        if (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    // It is important to also provide the</span><br><span class="line">    // `payable` keyword here, otherwise the function will</span><br><span class="line">    // automatically reject all Ether sent to it.</span><br><span class="line">    function register() public payable costs(price) &#123;</span><br><span class="line">        registeredAddresses[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        require(!locked);</span><br><span class="line">        locked = true;	//在函数体执行前执行</span><br><span class="line">        _;  			//继续执行剩下的函数体</span><br><span class="line">        locked = false;	//在函数体执行之后执行</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// This function is protected by a mutex, which means that</span><br><span class="line">    /// reentrant calls from within `msg.sender.call` cannot call `f` again.</span><br><span class="line">    /// The `return 7` statement assigns 7 to the return value but still</span><br><span class="line">    /// executes the statement `locked = false` in the modifier.</span><br><span class="line">    function f() public noReentrancy returns (uint) &#123;</span><br><span class="line">        require(msg.sender.call());</span><br><span class="line">        return 7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常状态变量"><a href="#常状态变量" class="headerlink" title="常状态变量"></a>常状态变量</h2><p>状态变量可以被声明为常量，那么它将在编译期间就固定了。常状态变量不可以被访问<code>storage</code>和区块信息（比如  <code>now</code>, <code>this.balance</code> or <code>block.number</code>）和执行信息（如：msg.gas），以及调用外部合约的表达式初始化。那些会影响内存分配的表达式被允许，但是那些会影响其他内存对象的表达式不会被允许。内置函数如：<code>keccak256</code>, <code>sha256</code>, <code>ripemd160</code>, <code>ecrecover</code>, <code>addmod</code> 和 <code>mulmod</code> 被允许。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant x = 32**22 + 8;</span><br><span class="line">    string constant text = &quot;abc&quot;;</span><br><span class="line">    bytes32 constant myHash = keccak256(&quot;abc&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="View-Functions"><a href="#View-Functions" class="headerlink" title="View Functions"></a>View Functions</h3><p>当函数内不存在修改状态的行为的时候，可以被声明为<code>view</code></p>
<p>一下行为被认为是修改状态：</p>
<ol>
<li>修改状态变量</li>
<li>发出事件</li>
<li>创建其他合约</li>
<li>使用<code>selfdestruct</code></li>
<li>通过调用发送以太币</li>
<li>调用其他没有被<code>pure</code>或者<code>view</code>修饰的函数</li>
<li>使用底层调用</li>
<li>使用包含某些操作码的内联汇编</li>
</ol>
<blockquote>
<p>注意：</p>
<p><code>constant</code>是<code>view</code>的别名。</p>
<p>Getter函数会被标记为view。</p>
<p>编译器不会强制view方法不去修改状态。</p>
</blockquote>
<h3 id="Pure-Functions"><a href="#Pure-Functions" class="headerlink" title="Pure Functions"></a>Pure Functions</h3><p>当函数内不存在读取或者修改状态行为的时候，可以被声明为<code>pure</code>。</p>
<p>修改状态的行为上面已经讨论过，对于读取状态行为如下：</p>
<ol>
<li>读取一个状态变量</li>
<li>访问<code>this.balance</code> 或者<code>&lt;address&gt;.balance</code></li>
<li>访问 <code>block</code>, <code>tx</code>, <code>msg</code> 的成员（除了<code>msg.sig</code>和<code>msg.data</code>）</li>
<li>调用其他没有被<code>pure</code>修饰的函数</li>
<li>使用包含某些操作码的内联汇编</li>
</ol>
<blockquote>
<p>警告：编译器不会强制<code>pure</code>方法不去读取状态。</p>
</blockquote>
<h3 id="Fallback-Function"><a href="#Fallback-Function" class="headerlink" title="Fallback Function"></a>Fallback Function</h3><p>一个合约只能有一个未命名函数。这个函数不能有参数也不能有返回值。当没有一个其他函数匹配的时候（或者甚至没有任何数据提供），将会被执行。另外当账户收到以太币的时候（没有携带数据）这个函数也将会被执行。另外为了能够接受以太币，<code>fallback function</code>必须要有<code>payable</code>修饰，如果没有这样的函数存在那么将无法收到以太币，会抛出异常，并退回以太币。但是这样的账户可以接收挖矿奖励，或者作为<code>selfdestruct</code>的收款方。</p>
<p>虽然fallback function不能设置参数，但是还是可以通过<code>msg.data</code>来获取。</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>一个合约可以有多个同名的函数，但是可以有不同参数。</p>
<p>当调用重载函数的时候，当使用的参数能够一对一地隐式转换为某个函数的参数列表的时候，这个函数将作为候选函数，当有多个候选函数的时候，调用失败。</p>
<blockquote>
<p>注意：返回值类型不被重载考虑在内。</p>
</blockquote>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件能够充分利用EVM的日志功能，能够触发JS的回调函数。</p>
<p>事件能够被继承，当事件被调用的时候，将会被存储在区块链上的一个特殊的数据结构log中，这些数据与区块链共存亡。</p>
<p>日志配合JS的使用案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">    event Deposit(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        bytes32 indexed _id,</span><br><span class="line">        uint _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function deposit(bytes32 _id) public payable &#123;</span><br><span class="line">        // Any call to this function (even deeply nested) can</span><br><span class="line">        // be detected from the JavaScript API by filtering</span><br><span class="line">        // for `Deposit` to be called.</span><br><span class="line">        Deposit(msg.sender, _id, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi as generated by the compiler */;</span><br><span class="line">var ClientReceipt = web3.eth.contract(abi);</span><br><span class="line">var clientReceipt = ClientReceipt.at(&quot;0x1234...ab67&quot; /* address */);</span><br><span class="line"></span><br><span class="line">var event = clientReceipt.Deposit();</span><br><span class="line"></span><br><span class="line">// watch for changes</span><br><span class="line">event.watch(function(error, result)&#123;</span><br><span class="line">    // result will contain various information</span><br><span class="line">    // including the argumets given to the `Deposit`</span><br><span class="line">    // call.</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Or pass a callback to start watching immediately</span><br><span class="line">var event = clientReceipt.Deposit(function(error, result) &#123;</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>solidity支持多继承，包括多态。</p>
<p>当一个合约继承了多个合约之后，只有一个合约会在区块链上创建，那些基合约的代码将会被拷贝到子合约中。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Use `is` to derive from another contract. Derived</span><br><span class="line">// contracts can access all non-private members including</span><br><span class="line">// internal functions and state variables. These cannot be</span><br><span class="line">// accessed externally via `this`, though.</span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// These abstract contracts are only provided to make the</span><br><span class="line">// interface known to the compiler. Note the function</span><br><span class="line">// without body. If a contract does not implement all</span><br><span class="line">// functions it can only be used as an interface.</span><br><span class="line">contract Config &#123;</span><br><span class="line">    function lookup(uint id) public returns (address adr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NameReg &#123;</span><br><span class="line">    function register(bytes32 name) public;</span><br><span class="line">    function unregister() public;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// Multiple inheritance is possible. Note that `owned` is</span><br><span class="line">// also a base class of `mortal`, yet there is only a single</span><br><span class="line">// instance of `owned` (as for virtual inheritance in C++).</span><br><span class="line">contract named is owned, mortal &#123;</span><br><span class="line">    function named(bytes32 name) &#123;</span><br><span class="line">        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">        NameReg(config.lookup(1)).register(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Functions can be overridden by another function with the same name and</span><br><span class="line">    // the same number/types of inputs.  If the overriding function has different</span><br><span class="line">    // types of output parameters, that causes an error.</span><br><span class="line">    // Both local and message-based function calls take these overrides</span><br><span class="line">    // into account.</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) &#123;</span><br><span class="line">            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">            NameReg(config.lookup(1)).unregister();</span><br><span class="line">            // It is still possible to call a specific</span><br><span class="line">            // overridden function.</span><br><span class="line">            mortal.kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// If a constructor takes an argument, it needs to be</span><br><span class="line">// provided in the header (or modifier-invocation-style at</span><br><span class="line">// the constructor of the derived contract (see below)).</span><br><span class="line">contract PriceFeed is owned, mortal, named(&quot;GoldFeed&quot;) &#123;</span><br><span class="line">   function updateInfo(uint newInfo) public &#123;</span><br><span class="line">      if (msg.sender == owner) info = newInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function get() public view returns(uint r) &#123; return info; &#125;</span><br><span class="line"></span><br><span class="line">   uint info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果继承的父类的构造函数需要接受参数，那么在后面加上括号，传入参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 1 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 2 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用<code>Final.kill()</code>的时候将会按照<code>Final</code>，<code>Base2</code>，<code>Base1</code>，<code>motal</code>，<code>owned</code>的顺序来进行查找，所以最后执行的是<code>Base1.kill()</code></p>
<p>当需要调用父合约的方法的时候，可以使用<code>super</code></p>
<h3 id="为基合约设置参数"><a href="#为基合约设置参数" class="headerlink" title="为基合约设置参数"></a>为基合约设置参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function Base(uint _x) public &#123; x = _x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Derived is Base(7) &#123;</span><br><span class="line">    function Derived(uint _y) Base(_y * _y) public &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一共有两种方式，第一种为在列表中直接设置，这种适合参数为常数的情况下，第二种方式类似修改器，作为子合约构造方法的一部分，这种方式适合基合约的参数需要根据子基类而定。</p>
<h3 id="多继承的钻石问题"><a href="#多继承的钻石问题" class="headerlink" title="多继承的钻石问题"></a>多继承的钻石问题</h3><p>在<code>is</code>后应该按照从基合约往子合约的顺序排列。</p>
<p>下面是一个错误实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// This will not compile</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract X &#123;&#125;</span><br><span class="line">contract A is X &#123;&#125;</span><br><span class="line">contract C is A, X &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>C应该声明为<code>contract C is X, A &#123;&#125;</code></p>
<h3 id="继承相同名称不同类型的成员"><a href="#继承相同名称不同类型的成员" class="headerlink" title="继承相同名称不同类型的成员"></a>继承相同名称不同类型的成员</h3><p>当继承导致函数和修改器重名，将会被认为是错误。当事件和修改器重名的时候，也同样会被认为是错误。另外还有函数和事件重名的情况。</p>
<h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h2><p>当合约中存在未实现函数的时候，该合约就会被认为是抽象合约。抽象合约不能被编译，只能用来作为基合约。继承了抽象合约但是没有实现其抽象方法，那么该合约也是抽象合约。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>合约中所有的函数都是抽象的时候，该合约被称为接口。接口有如下几个限制：</p>
<ol>
<li>不能继承其他合约或者接口</li>
<li>不能定义构造器</li>
<li>不能定义变量</li>
<li>不能定义结构体</li>
<li>不能定义枚举变量</li>
</ol>
<h2 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h2><p>Libraries和合约很像，但是他们目的是仅仅在特定地点部署一次，并且他们的代码是通过EVM的<code>DELEGATECALL</code> 来重用（Homestead之后为<code>CALLCODE</code> ）。这意味着当库函数被调用的时候，使用的是调用者的上下文环境，即可以访问调用者的storage。因为Library是源码中独立的一块。如果库函数不修改状态的话，那么他们可以被直接调用（比如：不使用<code>DELEGATECALL</code>），因为库是无状态的。</p>
<p>库可以被看做调用者的隐式基合约。他们在继承结构中并不显式可见，但是调用库函数仿佛就像调用一个显式的基合约（比如：<code>L.f()</code>其中L是库的名字）。另外，库的<code>internal</code>函数们对所有合约可见。</p>
<p>外部库函数的例子，以下实现另一个集合工具类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Set &#123;</span><br><span class="line">  // We define a new struct datatype that will be used to</span><br><span class="line">  // hold its data in the calling contract.</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  // Note that the first parameter is of type &quot;storage</span><br><span class="line">  // reference&quot; and thus only its storage address and not</span><br><span class="line">  // its contents is passed as part of the call.  This is a</span><br><span class="line">  // special feature of library functions.  It is idiomatic</span><br><span class="line">  // to call the first parameter `self`, if the function can</span><br><span class="line">  // be seen as a method of that object.</span><br><span class="line">  // 注意第一个参数是`storage reference`类型因此只有它的地址而不是值被传递。这是库函数的一个特性</span><br><span class="line">  // 如果该函数可以被看做是第一个参数的函数，那么我们一般把其命名为self</span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">          return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // The library functions can be called without a</span><br><span class="line">        // specific instance of the library, since the</span><br><span class="line">        // &quot;instance&quot; will be the current contract.</span><br><span class="line">        // 库函数可以不需要被一个实例所调用，因为当前合约即为那个实例</span><br><span class="line">        require(Set.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    // In this contract, we can also directly access knownValues.flags, if we want.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个内部库函数的使用例子，下面自定义了一个大数类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line">    struct bigint &#123;</span><br><span class="line">        uint[] limbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fromUint(uint x) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](1);</span><br><span class="line">        r.limbs[0] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(bigint _a, bigint _b) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">        uint carry = 0;</span><br><span class="line">        for (uint i = 0; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">            uint a = limb(_a, i);</span><br><span class="line">            uint b = limb(_b, i);</span><br><span class="line">            r.limbs[i] = a + b + carry;</span><br><span class="line">            if (a + b &lt; a || (a + b == uint(-1) &amp;&amp; carry &gt; 0))</span><br><span class="line">                carry = 1;</span><br><span class="line">            else</span><br><span class="line">                carry = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &gt; 0) &#123;</span><br><span class="line">            // too bad, we have to add a limb</span><br><span class="line">            uint[] memory newLimbs = new uint[](r.limbs.length + 1);</span><br><span class="line">            for (i = 0; i &lt; r.limbs.length; ++i)</span><br><span class="line">                newLimbs[i] = r.limbs[i];</span><br><span class="line">            newLimbs[i] = carry;</span><br><span class="line">            r.limbs = newLimbs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function limb(bigint _a, uint _limb) internal pure returns (uint) &#123;</span><br><span class="line">        return _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function max(uint a, uint b) private pure returns (uint) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using BigInt for BigInt.bigint;</span><br><span class="line"></span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        var x = BigInt.fromUint(7);</span><br><span class="line">        var y = BigInt.fromUint(uint(-1));</span><br><span class="line">        var z = x.add(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Library和合约的不同点在于：</p>
<ol>
<li>没有状态变量</li>
<li>不能继承或者被继承</li>
<li>不能接受以太币</li>
</ol>
<h2 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For</h2><p> <code>using A for B;</code>用来将库<code>A</code>中的函数绑定到<code>B</code>上，那么B在调用A的函数的时候，方法的第一个参数默认就是B变量。 <code>using A for *;</code>将A上的函数绑定到所有类型上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">// This is the same code as before, just without comments</span><br><span class="line">library Set &#123;</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">        return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Set for Set.Data; // this is the crucial change</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // Here, all variables of type Set.Data have</span><br><span class="line">        // corresponding member functions.</span><br><span class="line">        // The following function call is identical to</span><br><span class="line">        // `Set.insert(knownValues, value)`</span><br><span class="line">        require(knownValues.insert(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kaiktang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">kaiktang</p>
  <div class="site-description" itemprop="description">学而后知不足</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:tomkklalala@qq.com" title="E-Mail → mailto:tomkklalala@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kaiktang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://kaiktang.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
