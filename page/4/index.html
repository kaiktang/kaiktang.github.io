<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kaiktang.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null,"activeClass":"disqus"},"algolia":{"appID":"FBQ33HXA0Q","apiKey":"5a256d1a0d5075a6a17b29fbae8cdbdc","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="学而后知不足">
<meta property="og:type" content="website">
<meta property="og:title" content="TomKK&#39;s blogs">
<meta property="og:url" content="http://kaiktang.github.io/page/4/index.html">
<meta property="og:site_name" content="TomKK&#39;s blogs">
<meta property="og:description" content="学而后知不足">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TomKK&#39;s blogs">
<meta name="twitter:description" content="学而后知不足">

<link rel="canonical" href="http://kaiktang.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>TomKK's blogs</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8714a47efb513991b4862eafeadb6a3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TomKK's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/03/01/go语言线程通信学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/03/01/go语言线程通信学习/" class="post-title-link" itemprop="url">go语言线程通信学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-01 13:53:46" itemprop="dateCreated datePublished" datetime="2018-03-01T13:53:46+08:00">2018-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-06 15:08:36" itemprop="dateModified" datetime="2019-01-06T15:08:36+08:00">2019-01-06</time>
              </span>

          
            <span id="/2018/03/01/go语言线程通信学习/" class="post-meta-item leancloud_visitors" data-flag-title="go语言线程通信学习" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/03/01/go语言线程通信学习/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/01/go语言线程通信学习/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h1><blockquote>
<p><code>goroutine</code>只是由官方实现的超级“线程池”而已。每个实例4-5KB的栈内存占用和由于实现机制而大幅减少的创建和销毁开销，是制造Go号称的高并发的根本原因。另外<code>goroutine</code>的简单易用，也在语言层面上给予了开发者巨大的便利。</p>
<p><code>goroutine</code>奉行通过通信来共享内存，而不是共享内存来通信。</p>
</blockquote>
<h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><p>通过<code>go</code>关键字调用。</p>
<p>用来启动这个协程的函数不会得到任何的返回值。</p>
<p>所有的协程都会共享同一个线程除非将 GOMAXPROCS 设置为一个大于 1 的数。当 GOMAXPROCS 大于 1 时，会有一个线程池管理许多的线程。</p>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><code>Channel</code>是<code>goroutine</code>沟通的桥梁，通道的发送/接收操作在对方准备好之前是阻塞的</p>
<p>通过<code>make</code>创建，<code>close</code>关闭</p>
<p><code>Channel</code>是引用类型</p>
<p>发送者可以 <code>close</code> 一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：当没有值可以接收并且 <code>channel</code>已经被关闭，那么经过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>
<p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p>
<p>可以使用<code>for range</code>来迭代不断操作<code>channel</code>，直到显式调用<code>close</code>关闭通道</p>
<p>可以设置单向或双向通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> send_only <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>        <span class="comment">// channel can only send data</span></span><br><span class="line"><span class="keyword">var</span> recv_only &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>        <span class="comment">// channel can only receive data</span></span><br></pre></td></tr></table></figure>
<p>可以设置缓存大小，在未被填满前不会发生阻塞，变为异步，元素会按照发送的顺序被接收，即：在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> u:= &lt;- ch1:</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch2:</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// no value ready to be received</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可处理一个或多个<code>channel</code>的发送与接收</p>
<p><code>default</code>语句可选。</p>
<p>没有<code>fallthrough</code>行为。</p>
<ul>
<li>如果都阻塞了，会等待直到其中一个可以处理</li>
<li>如果多个可以处理，随机选择一个</li>
<li>如果没有通道操作可以处理并且写了 <code>default</code> 语句，它就会执行：<code>default</code> 永远是可运行的（这就是准备好了，可以执行）</li>
<li>如果没有 case，select 就会一直阻塞</li>
</ul>
<p>在任何一个case中执行<code>break</code>或者<code>return</code>将会终止整个<code>select</code></p>
<p>可以设置超时，比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> resp := &lt;-ch</span><br><span class="line">    <span class="comment">// use resp and reply</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeoutNs):</span><br><span class="line">    <span class="comment">// call timed out</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="疑问1"><a href="#疑问1" class="headerlink" title="疑问1"></a>疑问1</h4><blockquote>
<p>管道设了缓存之后，有什么区别？</p>
</blockquote>
<p>向带缓存的<code>channel</code>中发送数据的时候，只有在缓冲区满的时候写者才会阻塞。而当缓冲区的为空的时候，读者才会阻塞。联想到了《计算机网络》里面的“滑动窗口协议”，窗口值（缓冲区）为1的时候，能够保证数据流的有序性，当窗口值（缓冲区）大于1时，就变成了异步操作，吞吐量会增加</p>
<h4 id="疑问2"><a href="#疑问2" class="headerlink" title="疑问2"></a>疑问2</h4><blockquote>
<p>select有什么用？是怎样使用的？</p>
</blockquote>
<p><code>select</code> 语句使得一个 <code>goroutine</code> 在多个通讯操作上等待。</p>
<p><code>select</code> 会阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x: <span class="comment">//写入后等待读取</span></span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c) <span class="comment">//不断读取</span></span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="疑问3"><a href="#疑问3" class="headerlink" title="疑问3"></a>疑问3</h4><blockquote>
<p>不设置缓冲的channel和设置缓冲为1的channel有区别么？</p>
</blockquote>
<p>有区别，区别在于向放入第一个元素之后，不设置缓冲的channel将被阻塞无法继续进行，而设置缓冲为1的channel将可以继续执行剩下的操作，直到试图将channel中的元素扩增为2时，会发生阻塞</p>
<h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><blockquote>
<p>提供了一些基本的同步原语，用于并发控制</p>
<p>参考链接：<a href="http://www.cnblogs.com/golove/p/5918082.html" target="_blank" rel="noopener">http://www.cnblogs.com/golove/p/5918082.html</a></p>
</blockquote>
<p><code>sync.Once</code>：实现多次调用一次执行。只有第一次调用才会执行，之后如果要再次执行需要重新创建一个新的对象</p>
<p><code>sync.WaitGroup</code>：直到所有注册的并发任务都执行结束了，才继续执行。通过<code>sync.Add(n)</code>来增加计数器的值，通过<code>sync.Done()</code>将计数器的值减一</p>
<p><code>sync.Mutex</code>：信号量。提供<code>Lock</code>和<code>Unlock</code>两个方法，分别对应加锁和解锁。可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁</p>
<p><code>sync.RWMutex</code>：读写锁。在互斥锁的基础上，还能够提供写锁定，但是不锁定读的功能</p>
<p><code>sync.Cond</code>：条件等待。通过<code>Wait</code>让协程等待，通过<code>Signal</code>让一个等待的协程恢复，通过<code>Broadcast</code>让所有等待的协程恢复</p>
<h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><ul>
<li><p><code>Goexit</code></p>
<p>退出当前执行的goroutine，但是<code>defer</code>函数还会继续调用</p>
</li>
<li><p><code>Gosched</code></p>
<p>让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
</li>
<li><p><code>NumCPU</code></p>
<p>返回 CPU 核数量</p>
</li>
<li><p><code>NumGoroutine</code></p>
<p>返回正在执行和排队的任务总数</p>
</li>
<li><p><code>GOMAXPROCS</code></p>
<p>用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
</li>
</ul>
<h1 id="GoLang特色"><a href="#GoLang特色" class="headerlink" title="GoLang特色"></a>GoLang特色</h1><ul>
<li>部署简单，仅仅依赖glibc，不用考虑各种包和库的依赖关系。目标机器上只需要有一个基本的操作系统就能够部署。</li>
<li>天生支持高并发，通过<code>goroutine</code>和<code>channel</code>能够让书写并发程序更简单，大多数情况不需要考虑上锁</li>
<li>提供了丰富的内置工具，比如<code>gofmt</code></li>
<li>可以直接包含C代码，能够调用丰富的C库</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/02/09/学习以太坊白皮书/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/09/学习以太坊白皮书/" class="post-title-link" itemprop="url">学习以太坊白皮书</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-09 23:19:56" itemprop="dateCreated datePublished" datetime="2018-02-09T23:19:56+08:00">2018-02-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-02-11 14:17:45" itemprop="dateModified" datetime="2018-02-11T14:17:45+08:00">2018-02-11</time>
              </span>

          
            <span id="/2018/02/09/学习以太坊白皮书/" class="post-meta-item leancloud_visitors" data-flag-title="学习以太坊白皮书" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/02/09/学习以太坊白皮书/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/02/09/学习以太坊白皮书/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<a href="https://github.com/ethereum/wiki/wiki/White-Paper" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/White-Paper</a></p>
</blockquote>
<h1 id="以太坊账户"><a href="#以太坊账户" class="headerlink" title="以太坊账户"></a>以太坊账户</h1><p>在以太坊中状态是由账户组成的，每个账户都有一个20字节的地址。一个以太坊账户包含4个字段：</p>
<ol>
<li><code>nonce</code>：一个计数器用来确保每笔交易只会被处理一次</li>
<li><code>balance</code>：当前账户的以太币余额</li>
<li><code>合约代码</code></li>
<li><code>storage</code></li>
</ol>
<p>一共分为两种账户：<code>外部账户</code>和<code>合约账户</code>。一个外部账户没有代码，但是可以通过发送信息来创建或签名一个交易。在合约账户中，每次其收到消息它的代码都会被执行，进行对内部<code>storage</code>的读写操作或者发送其他信息或者创建另一个合约。</p>
<h1 id="消息和交易"><a href="#消息和交易" class="headerlink" title="消息和交易"></a>消息和交易</h1><p><code>交易</code>在以太坊中指代的是被前面的数据包，其中包含的是外部账户发送的消息。<code>交易</code>包含着：</p>
<ul>
<li>消息的接受者</li>
<li>发送者签名</li>
<li>发送的以太币数额</li>
<li>可选的数据字段</li>
<li><code>STARTGAS</code>，代表着此交易允许的最大计算步骤数</li>
<li><code>GASPRICE</code>：代表发送者愿意为每个计算步骤支付的费用</li>
</ul>
<p>数据字段默认没有作用，但是虚拟机中的合约可以访问它。</p>
<p>在以太坊中通常每步计算耗费 1 gas，但是更耗费资源的计算会耗费更多。存储方面，每字节收费 5 gas。</p>
<p><img src="https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/ethertransition.png" alt="以太坊状态转移"></p>
<p>合约能够向其他合约发送<code>消息</code>。消息只存在于以太坊执行环境中。一个<code>消息</code>包含：</p>
<ul>
<li>消息的发送者（隐式）</li>
<li>消息的接受者</li>
<li>消息附带发送的以太币</li>
<li>可选的数据字段</li>
<li><code>STARTGAS</code></li>
</ul>
<p><code>消息</code>类似<code>交易</code>但是是由<code>合约</code>产生而非外部账户。当合约执行到<code>call</code>操作码的时候，将会产生一个消息，以此让接受者账户执行其代码。所以合约账户之间可以和外部账户一样交互。</p>
<p>注意交易或者合约设置的<code>gas</code>应用于所有操作以及其他子操作。比如：一个外部账户A发给了B 1000 gas，然后自己消耗了600，向C发送消息，C消耗了300，此时B将只剩下 100 gas。</p>
<p>以太坊的状态转移函数，<code>APPLY(S, TX) —&gt; S&#39;</code>定义如下：</p>
<ol>
<li>检查交易是否正确组织（各个字段是否正确），签名是否有效，<code>nonce</code>是否发送者账户的中的<code>nonce</code>。如果检查出错，返回错误。</li>
<li>计算交易费用<code>STARTGAS × GASPRICE</code>，送发送者账户余额中减去费用，并增加发送者<code>nonce</code>值，如果余额不足，则返回错误。</li>
<li>初始化<code>GAS = STARTGAS</code>，并减去因为交易存储消耗的费用。</li>
<li>从发送者账户转账到接受者账户，如果接受账户还不存在，就创建。如果接受者账户是一个合约账户，那么将会执行合约代码，要么正常结束要么用尽gas而终止。</li>
<li>如果因为发送者余额不足或者合约代码耗尽gas而终止，将导致所有状态回滚，但是交易收取的费用还是会被扣除加到矿工账户上。</li>
<li>否则，退回剩余的gas到发送者，然后向矿工支付费用。</li>
</ol>
<h1 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h1><p>以太坊合约中的代码底层是一种基于栈的字节码语言，被称为<code>以太坊虚拟机码</code>或者<code>EVM code</code>。操作可以访问三种类型的存储数据的空间：</p>
<ul>
<li><code>stack</code>：后进先出的栈</li>
<li><code>memory</code>：一个无限可拓展的字节数组</li>
<li><code>storage</code>：一个键值存储。不像<code>stack</code>和<code>memory</code>每次计算结束都会被重置，<code>storage</code>会持久保存数据。</li>
</ul>
<p>代码可以访问消息中附带的以太币金额、发送者和数据字段，还有区块头部信息，也可以返回一个字节数组作为输出。</p>
<p><code>EVM code</code>的执行模式相当简单。当以太坊虚拟机运行时，它的完整的计算状态可以被这样一个元素所定义（<code>block_state</code>, <code>transaction</code>, <code>message</code>, <code>code</code>, <code>memory</code>, <code>stack</code>, <code>pc</code>, <code>gas</code>），其中<code>block_state</code>是全局状态包含了所有的账户信息。在每轮执行的开始，通过<code>pc(program counter)</code>找到当前指令，然后每个指令都有他们各自的方式去影响这个元组。比如：<code>ADD</code>操作就会弹出栈中的两个元素然后将他们的和再压回栈中，消耗 1 gas，并且将<code>pc</code>加1。而<code>SSTORE操作的话会弹出栈中两个元素然后掺入第二个元素到合约的</code>storage`的第一个元素指定的位置。尽管通过即时编译来优化以太坊虚拟机执行的方法有很多，但以太坊的基本实现可以在几百行代码中完成。</p>
<h1 id="区块链和挖矿"><a href="#区块链和挖矿" class="headerlink" title="区块链和挖矿"></a>区块链和挖矿</h1><p><img src="https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/apply_block_diagram.png" alt="以太坊区块链"></p>
<p>以太坊和比特币主要的不同在区块链结构上：不同于比特币，以太坊区块包含了一份交易列表以及最近状态的拷贝。除此之外，和比特币一样，区块号和难度值也存在。以太坊中的基本的区块验证算法如下：</p>
<ol>
<li>检查引用的上一个区块是否存在且合法</li>
<li>检查当前区块的时间戳是否比上一个区块的更大并且在15分钟以内</li>
<li>检查<code>block number</code>，<code>difficulty</code>，<code>transaction root</code>，<code>uncle root</code>和<code>gas limit</code>是否合法</li>
<li>检查工作量证明是否有效</li>
<li>让<code>S[0]</code>等于上一个区块的最后一个状态</li>
<li>假设<code>TX</code>代表区块的交易列表，若有n个交易，那么对于所有的<code>i</code>到<code>n-1</code>，设置<code>S[i+1] = APPLY(S[i], TX[i])。如果任意一个应用返回了错误或者</code>gas<code>消耗总量超出了</code>GASLIMIT`，返回错误</li>
<li>让<code>S_FINAL</code>等于<code>S[n]</code>，但是加入了向矿工支付的回报的状态</li>
<li>检查<code>S_FINAL</code>的<code>merkle tree</code>的根是否等于最终被检验区块头部提供的<code>state root</code>。如果相等，那么当前区块验证有效，反之无效</li>
</ol>
<p>这种方法看起来很低效，因为每个区块都需要存储所有的状态，但是实际上与比特币相比还是相当高效的。这是因为状态是存储在树结构中的，并且相邻区块之间树上只有少部分需要被修改。因此数据可以一次存储而多次引用（通过子树的hash）一种特殊的被称作<code>Patricia tree</code>（关于MPT树，我的<a href="http://tomkklalala.github.io/2018/02/06/%E7%90%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8AMerkle%20Patricia%20Trie/" target="_blank" rel="noopener">另一篇文章</a>）被用来完成这个，<code>Patricia tree</code>在<code>merkle tree</code>的基础上除了修改外，还允许进行高效地插入和删除操作。另外因为当前块的状态链是在上一个块基础上的延续，所以用户并不需要存储所有的区块链历史。如果比特币采用这种策略的话，将会节省大概5-20倍的空间。</p>
<blockquote>
<p>注：相当于整个状态链s[i]存放的是MPT树的树根，然后底层的数据都共享的levelDB中存储的节点。曾经有疑问关于levelDB中如果删除或者修改某个节点MPT树的实现是向数据库中插入新的节点然后修改父节点的引用，那么那些老节点不就变成幽灵节点浪费了空间么？现在看来因为整个链条上保存了状态的变化历史，所以如果如果通过过去的state root还是可以访问到那些所谓的幽灵节点的。</p>
</blockquote>
<p>一个常见的问题是“那么合约代码在什么时候在硬件上被执行呢？”。答案很简单：执行合约代码的过程是状态转移函数的一部分（即上文的<code>APPLY</code>函数），而状态转移函数又是区块验证算法的一部分，所以如果一个交易被打包进了区块B，那么这笔交易催生的合约代码迟早将会被所有节点执行，因为它们迟早会去下载并验证区块B。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="GHOST实现的修改"><a href="#GHOST实现的修改" class="headerlink" title="GHOST实现的修改"></a>GHOST实现的修改</h2><p><code>GHOST协议</code>（Greedy Heaviest Observed Subtree）背后的动机是：区块链拥有越少确认次数的将会导致安全性的降低，这是因为非常高的失效率——因为新生成的区块需要一定时间去向网络中广播，如果矿工A挖到了一个区块，而在这个区块传播到矿工B处之前，矿工B恰巧也挖到了一个新区块，那么最终矿工B的努力将浪费，并不会对网络的安全性做出贡献。另外，还存在一个集权的问题：非常容易出现因为算力的失衡造成超级矿场的出现，因为钱都被大矿场抢走了，而小矿场没有油水。</p>
<p>而在以太坊中GHOST协议中在计算最长链工作量证明的时候不仅仅是当前块的父块和祖先块被计入其中，而且还包含了当前块祖先的失效块后代们（以太坊中称其为“叔叔”）。这解决了上文中的第一个问题。而对于第二个问题，GHOST协议规定失效块也将获得奖励：一个失效块将获得87.5%的基础回报，而将其打包进区块的“侄子”区块将获得剩下的12.5%的回报。当然，交易手续费轮不到叔块们。</p>
<p>以太坊实现了一个简化的GHOST，它只有7个规则，如下：</p>
<ul>
<li>一个区块必须声明一个父区块，而且必须声明0个或者多个叔块</li>
<li>一个被区块B打包进来的叔块必须满足以下几个属性：<ul>
<li>它必须是区块B的前第K个祖先的直接孩子（其中，2&lt;=k&lt;=7）</li>
<li>它不能是B的祖先</li>
<li>它必须要有合法的区块头，但并不要求它之前被验证过</li>
<li>同一个叔块不能被多个区块打包</li>
</ul>
</li>
<li>区块B内的每个叔块，矿工得到额外的3.125%的矿工费，而叔块的矿工将获得93.75%的标准矿工费</li>
</ul>
<p>以太坊的规定中只有7代以内的叔块可以被打包进来，这样规定有这样两个原因：</p>
<ol>
<li>若不加限制，将会导致为验证叔块是否合法添加过多的复杂度。</li>
<li>若不加限制，将会降低矿工们在主链上挖矿的积极性</li>
</ol>
<h2 id="交易费"><a href="#交易费" class="headerlink" title="交易费"></a>交易费</h2><p>因为交易将会消耗网络资源，所以需要监管机制来防止滥用，而典型方法就是加入交易费。对于比特币的缴费的收取采取的是发送者资源设置交易费，而矿工们则类似守门员来设置自己愿意接受的最低价格。这个方法在比特币中收效很好，因为这由“市场供需关系”决定的价格。然而在现实中因为每笔交易需要网络中所有的节点去处理，所以交易处理的大部分消费是由第三方所承担的，而不是矿工。</p>
<blockquote>
<p>这一小节还是比较迷惑，它是想说明基于市场的其实也不差但是以太坊的实现更加稳定？</p>
</blockquote>
<h2 id="计算和图灵完备"><a href="#计算和图灵完备" class="headerlink" title="计算和图灵完备"></a>计算和图灵完备</h2><p>因为以太坊支持图灵完备的编程语言，包含无限循环。因为在计算机科学中众所周知没有有一个特定的方法能够检测程序是否会停机，所以可能存在攻击者通过让矿工或者其他全节点们进入死循环而宕机的可能么？</p>
<p>正如之前状态转换那节所说的，我们的解决方案是通过让一个交易事先设置一个其所被允许的最大的计算步骤，当实际执行超过了这个值，那么状态将会回滚，但是交易费还是需要缴纳。消息也是采用的同样的机制。以下是几个例子来说明：</p>
<ul>
<li>攻击者创建了一个拥有无限循环的合约，然后发起交易让矿工激活合约代码。矿工将会执行该无限循环直至其用光gas，然后收取交易费，回滚状态。</li>
<li>攻击者试图通过创建一个长时间的循环以此来让矿工持续工作，而当其结束的时候可能已经产生了很多新的区块了，此时该块将会被丢弃，那么矿工也就不能收取交易费了。但是这种情况的前提是，攻击者先声明自己的<code>STARTGAS</code>，因此矿工可以事先预估将要耗费的时间。</li>
<li>攻击者设置一个合约有类似这样的代码<code>send(A,contract.storage[A]);contract.storage[A] = 0;</code>但是发送合约的时候仅仅提供了只够执行第一步的gas，即他试图取钱但是不减少余额【不明白这样算什么攻击？他还是要付手续费的啊】这种情形下，也不用担心，因为当gas用完后，状态会回滚。</li>
<li>略</li>
</ul>
<p>下面介绍了为什么不使用非图灵完备的语言，结论是因为非图灵完备语言比图灵完备语言更难管控。</p>
<h2 id="货币和发行"><a href="#货币和发行" class="headerlink" title="货币和发行"></a>货币和发行</h2><p>以太币的面额如下：</p>
<ul>
<li>1：<code>wei</code></li>
<li>$${10^{12}}$$：<code>szabo</code></li>
<li>$${10^{15}}$$：<code>finney</code></li>
<li>$$10^{18}$$：<code>ether</code></li>
</ul>
<h2 id="挖矿中心化"><a href="#挖矿中心化" class="headerlink" title="挖矿中心化"></a>挖矿中心化</h2><p>比特币的挖矿算法非常容易导致两种形式的中心化：</p>
<ul>
<li>首先，整个挖矿生态系统已经被专用挖矿集成芯片所支配，这意味着比特币挖矿不再是高度去中心化的，因为想要参与挖矿你必须先投入几百万美元买矿机。</li>
</ul>
<ul>
<li>第二，大多数矿工依附于中心化的矿场，不需成为全节点。那么这个问题可以说更糟糕：目前算力最强的三个矿场控制了大约50%的算力，尽管51%攻击可以通过矿工迁移来避免。</li>
</ul>
<p>以太坊使用的挖矿算法需要矿工从状态中获取随机数据，计算从前N个区块中随机选取的一些交易，然后返回结果哈希。这样设计有两个好处：</p>
<ul>
<li>第一，以太坊合约可能包含任意种类的计算，所以只能通过CPU来计算，而不会出现专用挖矿集成芯片</li>
<li>第二，挖矿需要能够访问整个区块链，所以强迫矿工存储整个区块链并且至少能够有能力验证每笔交易。这样就不必存在中心化的矿场。尽管矿场依旧可以起到让收入分配的随机型更平等的作用，但是这种功能在p2p矿场中也能被实现，而不需要中心化。</li>
</ul>
<p>这个算法最大的特点是允许任何人投入大量合约去针对特定的专用矿机。因为存在着矿机生产商们之间的利益竞争会驱使他们互相攻击。因此这种模式并非完全采用技术来解决问题，还有经济学上的考虑。</p>
<h2 id="可拓展性"><a href="#可拓展性" class="headerlink" title="可拓展性"></a>可拓展性</h2><p>一个通常的担忧是关于可拓展新问题。像比特币一样，以太坊的每个交易都需要备每个网络中的节点所处理。对于比特币，目前整个区块链的大小大概在15GB，每小时增长1MB。如果比特币网络处理像Visa一样的2000笔交易每秒的话，那么增长速度将变为每3秒增长1MB（每小时1GB，每年8TB）。以太坊也会有这样的担忧，而且由于以太坊上除了货币外还有众多应用可能这样的担忧更加严重。但是，在以太坊中全节点是不需要存储所有的区块历史的，只需要保存状态即可。</p>
<p>巨大的区块链大小将存在导致中心化的风险。假如说，区块链的大小增长到了100TB，那么就很可能只有少数大型企业能够运行全节点，而其他普通用户只能使用SPV轻钱包。在这种情况下，就存在着全节点们密谋一起作弊的可能（比如将所有的矿工费都修改为给他们）。而轻节点们无法快速的检测这种行为。</p>
<p>以太坊采用两种策略来处理这个问题：</p>
<ul>
<li>第一，因为以太坊的挖矿算法要求所有节点都必须为全节点，所以这能够保证网络中全节点的数量。</li>
<li>第二，更重要的是，我们把处理完每笔交易的中间状态也包含进了区块链。这样只要有一个诚实的节点存在，那么就能够通过s[0]到s[n]的推导验证最终的结果是否正确。</li>
</ul>
<p>如果恶意矿工发布不完全的区块信息，以至于没有足够的信息去验证区块的合法性，那么验证节点会对交易发起质疑，轻节点也将对相应区块取消信任，直到另一个矿工或者验证节点提供正确的证据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/02/06/理解以太坊Merkle Patricia Trie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/02/06/理解以太坊Merkle Patricia Trie/" class="post-title-link" itemprop="url">理解以太坊Merkle-patricia-tree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-06 21:16:18" itemprop="dateCreated datePublished" datetime="2018-02-06T21:16:18+08:00">2018-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-07 17:01:28" itemprop="dateModified" datetime="2019-01-07T17:01:28+08:00">2019-01-07</time>
              </span>

          
            <span id="/2018/02/06/理解以太坊Merkle Patricia Trie/" class="post-meta-item leancloud_visitors" data-flag-title="理解以太坊Merkle-patricia-tree" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/02/06/理解以太坊Merkle Patricia Trie/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/02/06/理解以太坊Merkle Patricia Trie/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述　"></a>概述　</h1><p>Merkle Patricia Tree(简称MPT树，实际上是一种trie前缀树)是以太坊中的一种加密认证的数据结构，可以用来存储所有的(key，value)对。在以太坊区块链中的一个区块包含一个区块头部，一个交易列表和一个叔块（uncle block）列表。在区块头部中包含一个交易根哈希，它被用来验证那个交易列表。虽然交易是通过对等方式作为简单列表发送的，但是它们会被组合成一个称为<code>trie</code>的特殊数据结构来计算根哈希。它可以用来验证区块，也可以作为一个通过<code>key</code>获取<code>value</code>的一个数据结构。这意味着交易列表在本地是以<code>trie</code>的形式存储的，另外当客户端请求区块链的时候会将其序列化为列表发送。而客户端在收到列表后将交易列表重新构造成<code>trie</code>的形式以此来验证根哈希。值得注意的是，以太坊使用<code>RLP（recursive length prefix encoding）</code>编码了<code>trie</code>中的所有条目。</p>
<p><code>trie</code>也被称作<code>radix tree</code>，以太坊对其做了一些改进以提高效率。在一个普通的<code>radix tree</code>中，一个<code>key</code>其实代表了为获取<code>key</code>对应的<code>value</code>所需的树的访问路径。具体来说，就是从树根开始，<code>key</code>中的每个字符就代表了下个要访问的子节点，遍历完整个<code>key</code>将会得到对应的<code>value</code>。假设限定一个<code>key</code>的取值范围为一个包含N个字符的字符表，那么这意味着树中每个节点最多有N个孩子节点，而树的最大深度对应<code>key</code>的最大长度。</p>
<p><code>Radix tree</code>非常棒，因为对于那些有相同前缀的<code>key</code>在树中将会存储的很接近。并且也不会像散列表一样出现<code>key</code>的碰撞。</p>
<p><img src="前缀树实例1.png" alt="共用前缀"></p>
<p>但是对于一个和其他节点没有公共前缀的长<code>key</code>而言，为了得到它相应的<code>value</code>你必须遍历（存储）相当多的节点，并且在整个遍历路径中没有存储其他的<code>value</code>。可以看到下图这棵树非常的不平衡。</p>
<p><img src="前缀树实例2.png" alt="弊端"></p>
<h2 id="基础的Radix-Tries"><a href="#基础的Radix-Tries" class="headerlink" title="基础的Radix Tries"></a>基础的Radix Tries</h2><p>对于<code>radix tries</code>的更新和删除函数非常简单，可以大致被定义为如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">类似孩子兄弟表示法，每一层都是一个长度为17的列表</span></span><br><span class="line"><span class="string">	* 叶子节点为前16个元素为空的数组，第17个元素存放value(如果存在的话)</span></span><br><span class="line"><span class="string">	* 分支节点的前16个元素为指向下一层数组的哈希，第17个元素存放value(如果存在的话)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">数据库中存放的为(key, value)对，其中value是一个数组代表某字母下该层的所有节点，key为value的哈希</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">@param node：当前访问节点的哈希值</span></span><br><span class="line"><span class="string">@param path：当前访问的key，即访问路径</span></span><br><span class="line"><span class="string">@param value：需要替换的新值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(node,path,value)</span>:</span></span><br><span class="line">    <span class="comment">#如果当前路径已经到了终点，那么应该修改列表的最后一个值，即newnode[-1]</span></span><br><span class="line">    <span class="keyword">if</span> path == <span class="string">''</span>:</span><br><span class="line">    	<span class="comment">#从数据库中根据node哈希找到其对应的节点数据结构(一个长度为17的列表)</span></span><br><span class="line">        <span class="comment">#如果node哈希为空则创建一个长度为17的空列表作为当前节点</span></span><br><span class="line">        curnode = db.get(node) <span class="keyword">if</span> node <span class="keyword">else</span> [ NULL ] * <span class="number">17</span></span><br><span class="line">        newnode = curnode.copy()</span><br><span class="line">        <span class="comment">#修改最后一个元素为新的值</span></span><br><span class="line">        newnode[<span class="number">-1</span>] = value</span><br><span class="line">    <span class="comment">#如果访问路径还没有到终点，那么通过递归继续向下访问</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#根据node哈希，得到当前节点</span></span><br><span class="line">        curnode = db.get(node) <span class="keyword">if</span> node <span class="keyword">else</span> [ NULL ] * <span class="number">17</span></span><br><span class="line">        newnode = curnode.copy()</span><br><span class="line">        <span class="comment">#由于当前非访问的终点，所以意味着会有修改在当前节点的下层发生</span></span><br><span class="line">        <span class="comment">#所以意味着下层数据会发生改变，从而导致当前节点path[0]位置所存储的下层hash也会发生改变</span></span><br><span class="line">        <span class="comment">#所以trie树的根哈希可以作为整个结构的签名，因为其对结构变动非常敏感，牵一发而动全身</span></span><br><span class="line">        <span class="comment">#故应该更新newnode节点（列表）中path[0]字符所对应的哈希</span></span><br><span class="line">        newindex = update(curnode[path[<span class="number">0</span>]],path[<span class="number">1</span>:],value)</span><br><span class="line">        newnode[path[<span class="number">0</span>]] = newindex</span><br><span class="line">    <span class="comment">#将修改后的(key=修改后节点的哈希，value=修改后节点(列表）存入数据库</span></span><br><span class="line">    db.put(hash(newnode),newnode)</span><br><span class="line">    <span class="keyword">return</span> hash(newnode)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">@param node：当前访问节点的哈希值</span></span><br><span class="line"><span class="string">@param path：当前访问的key，即访问路径</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(node,path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> NULL:</span><br><span class="line">        <span class="keyword">return</span> NULL</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        curnode = db.get(node)</span><br><span class="line">        newnode = curnode.copy()</span><br><span class="line">        <span class="comment">#访问路径的终点，则将最后一位设置为NULL表示删除</span></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">''</span>:</span><br><span class="line">            newnode[<span class="number">-1</span>] = NULL</span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            newindex = delete(curnode[path[<span class="number">0</span>]],path[<span class="number">1</span>:])</span><br><span class="line">            newnode[path[<span class="number">0</span>]] = newindex</span><br><span class="line">		<span class="comment">#统计newnode中非NULL节点的个数</span></span><br><span class="line">        <span class="comment">#即判断是否为叶子节点</span></span><br><span class="line">        <span class="comment">#若为叶子节点，那么不再数据库中存储</span></span><br><span class="line">        if len(filter(x -&gt; x is not NULL, newnode)) == 0:</span><br><span class="line">            <span class="keyword">return</span> NULL</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#若非叶子节点，那么在数据库中存储修改后的节点</span></span><br><span class="line">            db.put(hash(newnode),newnode)</span><br><span class="line">            <span class="keyword">return</span> hash(newnode)</span><br></pre></td></tr></table></figure>
<p>可以看到，通过这种形式的数据结构，可以实现：</p>
<p>为了让树加密安全。每个节点通过哈希来引用而非一般C语言实现中的32位或64位指针，访问的时候根据哈希去<code>leveldb</code>数据库查询。通过这种模式，树的根哈希将成为整个数据结构密码学上的指纹（类似，Merkle）。</p>
<p>如果一棵<code>trie</code>的树根是公开的，那么任何人可以通过提供一对(key, value)来证明其是确实在<code>trie</code>中存在的，而不能伪造。</p>
<p>上面所述的实现，每次访问的都是访问<code>path</code>中一个<code>nibble</code>即以4个bit，1个十六进制的字符为步长，所以大多数节点都是一个长度为17的数组，这些数组被称为<code>分支节点</code>。</p>
<h1 id="Merkle-Patricia-Trie"><a href="#Merkle-Patricia-Trie" class="headerlink" title="Merkle Patricia Trie"></a>Merkle Patricia Trie</h1><p>基本的<code>radix tries</code>有一个主要的局限：<strong>低效</strong>。</p>
<p>比如你想要存放一对（key, value），而其中的<code>key</code>长度为64个字符（以<code>etherem state trie</code>为例，64指的是byte32中nibble的数目），所以你将需要超过1KB（64×16=1024）的额外空间去为每个字符存储一层节点，并且每个查找或者删除操作都将会需要64步，而即将介绍的<code>The Patricia trie</code>将会解决这个问题。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p><code>Merkle Patricia tries</code>通过增加整个数据结构的复杂性来解决低效问题：</p>
<p><code>Merkle Patricia tries</code>中的节点可能是以下类型之一</p>
<ol>
<li><code>空白节点 NULL</code>：即空节点。</li>
<li><code>叶节点 leaf</code>：一个保存着两个元素的节点  <code>[ encodedPath, value ]</code>。</li>
<li><code>拓展节点 extension</code>：一个保存着两个元素的节点  <code>[ encodedPath, key ]</code>。</li>
<li><code>分支节点 branch</code>：长度为17的数组，前16个节点对应了16个可能16进制值，最后一个元素存放的                                   是<code>key</code>终止于该节点的值  <code>[ v0 ... v15, vt ]</code></li>
</ol>
<p>对于一个64位长的字符路径，在遍历途中不可避免的会遇到这样一种情况：遇到某一层只有一个分支。要求这种层除了要访问的索引外，其他索引位置均存放空值是很浪费的。所以我们通过设置<code>[ encodedPath, key ]</code>形式的拓展节点来加速访问的过程，其中<code>encodedPath</code>包含了部分被跳过的路径（使用的压缩方法下面会介绍），而<code>key</code>用来去数据库中查找下一层节点。</p>
<p>对于一个叶子节点（ <code>[ encodedPath, value ]</code>）来说，可以使用<code>encodedPath</code>中第一个<code>nibble</code>中的标识位来指示。在这种情况下，<code>value</code>即为最终要查询的值。</p>
<p>然而，上述的优化带来了一些歧义。</p>
<p>在以<code>nibble</code>为步长来遍历路径的时候，我们可能最终遍历奇数次，但是因为所有的数据都以字节格式存储，所以<code>encodedPath</code>中存放的<code>nibble</code>必定为偶数，而如果被压缩的路径为奇数的话就需要填充长度。比如，对于<code>nibble &lt;01&gt;</code>你很难很难区分开来究竟跳过的路径是<code>&lt;0&gt;</code>还是<code>&lt;01&gt;</code>，因为它们俩实际存储都为<code>nibble &lt;01&gt;</code>。所以为了指定奇数长度，需要在路径前面加上一个标志位。</p>
<h3 id="使用可选终止符的十六进制序列的紧凑编码"><a href="#使用可选终止符的十六进制序列的紧凑编码" class="headerlink" title="使用可选终止符的十六进制序列的紧凑编码"></a>使用可选终止符的十六进制序列的紧凑编码</h3><p>标识后面路径长度的奇偶性的标志位以及标识叶子节点还是拓展节点的标志位均在<code>encodedPath</code>的第一个<code>nibble</code>中，一共有如下几种可能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hex char    bits    |    node type partial     path length</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">   0        0000    |       extension              even        </span><br><span class="line">   1        0001    |       extension              odd         </span><br><span class="line">   2        0010    |   terminating (leaf)         even        </span><br><span class="line">   3        0011    |   terminating (leaf)         odd</span><br></pre></td></tr></table></figure>
<p>对于偶数剩余长度（即hex char为0和2的情况）下，总会有另一个<code>0</code>作为填充<code>nibble</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compact_encode</span><span class="params">(hexarray)</span>:</span></span><br><span class="line">    <span class="comment">#确定节点类型标志位，判断是否为叶子节点，是则term为1，否则为0</span></span><br><span class="line">    <span class="comment">#这里写死以16代表真实值，而非哈希</span></span><br><span class="line">    term = <span class="number">1</span> <span class="keyword">if</span> hexarray[<span class="number">-1</span>] == <span class="number">16</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#若为叶子节点，则取出前面的</span></span><br><span class="line">    <span class="keyword">if</span> term: hexarray = hexarray[:<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">#确定长度标志位，奇数为1，偶数为0</span></span><br><span class="line">    oddlen = len(hexarray) % <span class="number">2</span></span><br><span class="line">    <span class="comment">#将类型标识位和奇偶标志位组合</span></span><br><span class="line">    flags = <span class="number">2</span> * term + oddlen</span><br><span class="line">    <span class="keyword">if</span> oddlen:</span><br><span class="line">        hexarray = [flags] + hexarray</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#如果是偶数长度，则另外加上填充的0</span></span><br><span class="line">        hexarray = [flags] + [<span class="number">0</span>] + hexarray</span><br><span class="line">    // hexarray now has an even length whose first nibble <span class="keyword">is</span> the flags.</span><br><span class="line">    o = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(hexarray),<span class="number">2</span>):</span><br><span class="line">        o += chr(<span class="number">16</span> * hexarray[i] + hexarray[i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> o</span><br></pre></td></tr></table></figure>
<p>一些示例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> [ 1, 2, 3, 4, 5, <span class="built_in">hash</span>]  ---&gt; 奇数长度拓展节点</span></span><br><span class="line">'11 23 45'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [ 0, 1, 2, 3, 4, 5, <span class="built_in">hash</span>]  ---&gt; 偶数长度拓展节点</span></span><br><span class="line">'00 01 23 45'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [ 0, f, 1, c, b, 8, 10]  ---&gt; 偶数长度叶节点</span></span><br><span class="line">'20 0f 1c b8'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [ f, 1, c, b, 8, 10]  ---&gt; 奇数长度叶节点</span></span><br><span class="line">'3f 1c b8'</span><br></pre></td></tr></table></figure>
<p>下面是获取一个<code>Merkle Patricia trie</code>节点的拓展代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_helper</span><span class="params">(node,path)</span>:</span></span><br><span class="line">  	<span class="comment">#如果path为空，那么node中存放的就是对应的要找的value</span></span><br><span class="line">    <span class="keyword">if</span> path == []: <span class="keyword">return</span> node</span><br><span class="line">    <span class="keyword">if</span> node = <span class="string">''</span>: <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="comment">#下面这行代码没懂</span></span><br><span class="line">    curnode = rlp.decode(node <span class="keyword">if</span> len(node) &lt; <span class="number">32</span> <span class="keyword">else</span> db.get(node))</span><br><span class="line">    <span class="comment">#判断是否是拓展节点或叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> len(curnode) == <span class="number">2</span>:</span><br><span class="line">        (k2, v2) = curnode</span><br><span class="line">        k2 = compact_decode(k2)</span><br><span class="line">        <span class="keyword">if</span> k2 == path[:len(k2)]:</span><br><span class="line">            <span class="keyword">return</span> get(v2, path[len(k2):])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    <span class="keyword">elif</span> len(curnode) == <span class="number">17</span>:</span><br><span class="line">        <span class="keyword">return</span> get_helper(curnode[path[<span class="number">0</span>]],path[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(node,path)</span>:</span></span><br><span class="line">    path2 = []</span><br><span class="line">    <span class="comment">#将path中的存放的字符，以nibble为单位拆分</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(path)):</span><br><span class="line">        path2.push(int(ord(path[i]) / <span class="number">16</span>))</span><br><span class="line">        path2.push(ord(path[i]) % <span class="number">16</span>)</span><br><span class="line">    path2.push(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> get_helper(node,path2)</span><br></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假设我们现在希望一个包含四个<code>path/value</code>对的<code>trie</code>：<code>(&#39;do&#39;, &#39;verb&#39;)</code>, <code>(&#39;dog&#39;, &#39;puppy&#39;)</code>, <code>(&#39;doge&#39;, &#39;coin&#39;)</code>, <code>(&#39;horse&#39;, &#39;stallion&#39;)</code>。</p>
<p>首先，我们先将<code>path</code>转换成以<code>nibble</code>形式表示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;0x64 0x6f&gt; : 'verb'</span><br><span class="line">&lt;0x64 0x6f 0x67&gt; : 'puppy'</span><br><span class="line">&lt;0x64 0x6f 0x67 0x65&gt; : 'coin'</span><br><span class="line">&lt;0x68 0x6f 0x72 0x73 0x65&gt; : 'stallion'</span><br></pre></td></tr></table></figure>
<p>现在，我们在底层数据库存储一下<code>key/value</code>对来构建这样一个<code>trie</code>结构</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rootHash: [ &lt;6&gt;, hashA ]</span><br><span class="line">hashA:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashB, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashC, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt; ]</span><br><span class="line">hashC:    [ &lt;20 6f 72 73 65&gt;, 'stallion' ]</span><br><span class="line">hashB:    [ &lt;00 6f&gt;, hashD ]</span><br><span class="line">hashD:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashE, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, 'verb' ]</span><br><span class="line">hashE:    [ &lt;17&gt;, hashF ]</span><br><span class="line">hashF:    [ &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, hashG, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, &lt;&gt;, 'puppy' ]</span><br><span class="line">hashG:    [ &lt;35&gt;, 'coin' ]</span><br></pre></td></tr></table></figure>
<p><img src="MPT树压缩示意图.png" alt="MPT树压缩示意图"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>与普通的<code>radix trie</code>相比，MPT树能够有效的减少树的深度，增加<code>trie</code>的平衡性。而且通过哈希值来进行节点的链接有助于提高树的安全性和可验证性。</p>
<h1 id="在以太坊中的Tries"><a href="#在以太坊中的Tries" class="headerlink" title="在以太坊中的Tries"></a>在以太坊中的Tries</h1><p>在以太坊中所有的<code>merkle tries</code>都是使用的<code>Merkle Patricia Trie</code>。</p>
<p>在区块头部保存有三个根分别对应于三个<code>trie</code>：</p>
<ol>
<li>stateRoot</li>
<li>transactionRoot</li>
<li>recepitsRoot</li>
</ol>
<h2 id="State-Trie"><a href="#State-Trie" class="headerlink" title="State Trie"></a>State Trie</h2><p>存在一个全局的<code>state trie</code>并且持续更新。在其中，<code>path</code>始终是<code>sha(ethereumAddress)而value</code>总是<code>rlp(ethereumAccount)</code>。具体的，一个<code>ethereumAccount</code>是一个包含4个元素的数组：[<code>nonce</code>, <code>balance</code>, <code>storageRoot</code>, <code>codeHash</code>]，值得注意的是这里<code>storageRoot</code>是另一棵<code>patricia trie</code>的根。</p>
<h2 id="Storage-Trie"><a href="#Storage-Trie" class="headerlink" title="Storage Trie"></a>Storage Trie</h2><p><code>Storage trie</code>是所有合约地址存放的地方。每个账户有一个单独的<code>storage trie</code>。而在其中的<code>path</code>有点复杂但是他们依赖于<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getstorageat" target="_blank" rel="noopener">这个</a>。</p>
<h2 id="Transaction-Trie"><a href="#Transaction-Trie" class="headerlink" title="Transaction Trie"></a>Transaction Trie</h2><p>每个区块都单独有一棵<code>transaction trie</code>。在其中的<code>path</code>为<code>rlp(transactionIndex)</code>。其中<code>transactionIndex</code>是交易在这个去区块中的索引，其顺序主要由矿工决定，所以这个数据直到挖矿之后才能知道。当一个区块被“挖”了以后，这棵<code>transaction trie</code>将再也不会改变。</p>
<h2 id="Receipts-Trie"><a href="#Receipts-Trie" class="headerlink" title="Receipts Trie"></a>Receipts Trie</h2><p>每个去区块都有其自己的<code>receipts trie</code>。这里的<code>path</code>为<code>rlp(transactionIndex)</code>。其中<code>transactionIndex</code>是交易在这个去区块中的索引。永远不会更改。</p>
<blockquote>
<p><strong>参考文献</strong></p>
<p><a href="https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/" target="_blank" rel="noopener">https://easythereentropy.wordpress.com/2014/06/04/understanding-the-ethereum-trie/</a></p>
<p><a href="https://github.com/ethereum/wiki/wiki/Patricia-Tree" target="_blank" rel="noopener">https://github.com/ethereum/wiki/wiki/Patricia-Tree</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/01/21/学习比特币/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/21/学习比特币/" class="post-title-link" itemprop="url">学习比特币</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-01-21 11:28:12" itemprop="dateCreated datePublished" datetime="2018-01-21T11:28:12+08:00">2018-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-07 17:10:33" itemprop="dateModified" datetime="2019-01-07T17:10:33+08:00">2019-01-07</time>
              </span>

          
            <span id="/2018/01/21/学习比特币/" class="post-meta-item leancloud_visitors" data-flag-title="学习比特币" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/01/21/学习比特币/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/21/学习比特币/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="比特币基本概念"><a href="#比特币基本概念" class="headerlink" title="比特币基本概念"></a>比特币基本概念</h1><p>区块链的一个典型应用就是比特币。本质是一个数字资产的公开分布式账本的P2P网络。该账本的正确性和安全性由矿工组成的子网保证，并由矿工审核和记录所有的交易，以获取比特币作为奖励。</p>
<h2 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h2><blockquote>
<p><a href="http://www.infoq.com/cn/articles/bitcoin-and-block-chain-part01" target="_blank" rel="noopener">揭秘比特币和区块链（一）：什么是区块链？</a></p>
<p><a href="http://www.infoq.com/cn/articles/bitcoin-and-block-chain-part02" target="_blank" rel="noopener">揭秘比特币和区块链（二）：什么是工作量证明？</a></p>
<p><a href="http://www.infoq.com/cn/articles/bitcoin-and-block-chain-part03" target="_blank" rel="noopener">揭秘比特币和区块链（三）：比特币的私钥、公钥与地址</a></p>
<p><a href="http://www.infoq.com/cn/articles/bitcoin-and-block-chain-part04" target="_blank" rel="noopener">揭秘比特币和区块链（四）：比特币的交易</a></p>
<p><a href="http://www.360doc.com/content/17/0518/20/30659864_655093247.shtml" target="_blank" rel="noopener">揭秘比特币和区块链（五）：深入理解比特币交易的脚本</a></p>
</blockquote>
<h2 id="PoW-Proof-of-Work"><a href="#PoW-Proof-of-Work" class="headerlink" title="PoW(Proof of Work)"></a>PoW(Proof of Work)</h2><p>PoW也被称为挖矿，例如BItcoin中不断尝试哈希值的过程，实际是花费较昂的计算资源。</p>
<p>在产生下一个区块的过程中，奖励总数给第一个解决数学难题的矿工。</p>
<p>矿工为了解决数学难题，不断改进矿机，增大算力，提高称为第一个找到下一个区块者的概率。</p>
<p>这种方式<strong>很浪费资源，因为大家希望得到奖励，所以不会捣乱。</strong></p>
<h2 id="PoS-Proof-of-Stake"><a href="#PoS-Proof-of-Stake" class="headerlink" title="PoS(Proof of Stake)"></a>PoS(Proof of Stake)</h2><p>在PoS模式中，根据代币的持有数量，产生下一个区块的创建者具有某种程度的确定性。</p>
<p>PoS系统并没有区块奖励。因此矿工只拿到交易费。</p>
<p>PoS模式的代币产生基本不需要消耗算力，效率比PoW高得多。</p>
<p>这种方式下，<strong>持有代币最多的那个人，定期会获得利息，为了保护自己的财产，所以也不会捣乱。</strong></p>
<h2 id="钱包地址"><a href="#钱包地址" class="headerlink" title="钱包地址"></a>钱包地址</h2><p>钱包地址应该是该用户公钥的一个<code>hash</code>，为什么不直接用公钥呢，是因为它太长了，存放在区块（1M）中影响交易量。</p>
<p>每个人可以有多个钱包，因为只要有一个私钥就能够导出一个公钥来，所以追踪一个财产是比较困难的，需要知道他所有的钱包地址。</p>
<h2 id="交易UTXO"><a href="#交易UTXO" class="headerlink" title="交易UTXO"></a>交易UTXO</h2><p>交易包含以下三项</p>
<ul>
<li>交易的输入（UTXO指针）</li>
<li>交易的输出（UTXO）</li>
<li>解锁脚本（私钥签名、公钥）</li>
</ul>
<p>UTXO（Unspent Transaction Output）代表了一个未被消费的交易输出。比如：</p>
<blockquote>
<p>A通过挖矿得到了12.5个比特币，UTXO池（数据库）中会记录着A得到的这12.5个比特币的UTXO，记为UTXO1。然后A将转账给B和C各5个比特币，并转给自己2.5个比特币。这里有几点需要说明，首先当A的这个转账的交易发出后，数据库中UTXO1将被删除，继而产生新的记录分别记为，UTXO2（对应转给B的5个比特币），UTXO3（对应转给C的5个比特币），UTXO4（对应转给A的2.5个比特币）。这里为什么需要转给A自己2.5个比特币呢，那是因为如果这次交易中这UTXO1所代表的12.5个比特币最终都会被花掉（因为UTXO1作废了），如果不把余额转给自己，那么这将作为打包区块的矿工的小费进入他名下。而矿工会优先确认小费高的那个区块交易。</p>
</blockquote>
<p>一个用户的余额是根据众多的他的UTXO计算出来的。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>每个区块中的记录第一个交易是<code>coinbase</code>即代表刚从“矿山”里挖出来的“金矿”，其实就是奖励给第一个算出合格哈希的矿工的比特币，每笔交易中流转的比特币最终都能回溯到，它被挖出来的那次<code>coinbase</code>，所以比特币难以造假。</p>
<p>经过6个以上区块确认的交易才是安全确认的。</p>
<blockquote>
<p>举个例子，有一些挖矿者先收到block A，另一些挖矿者先收到的是block B。那些收到block A的挖矿者将要继续沿着他们的分支挖矿，而其他人沿着Block B的分支挖矿（目前来看同一份钱被花了两次）。我们假设在B分支上的挖矿者先成功挖到下一个block，当他们收到这个消息后，在A分支的人会注意到现在B分支是最长的，于是就会转换到B的分支。在A分支上的工作就会迅速的停止，这样每个人就会都在同一个顺序的blockchain上工作了。所有在block A里面的待定交易将会继续保持待定状态，随后会在B分支上被放到新的block里，这样，所有的交易最终还是会被验证的。</p>
</blockquote>
<p><del>假设交易中，买家给了卖家比特币来购买商品，但是使用的确是分叉链中产生的UTXO，如果卖家心比较大，直接发货了，之后如果原来那条分叉链被抛弃，那么整条链条中基于被抛弃分叉链所产生的UTXO都将失效的，即卖家收到的钱又回到了买家手里。</del></p>
<p><del>这么理解应该是错的，因为UTXO是一个数据结构，即使在分叉链中产生的UTXO应该都是一样的。</del></p>
<p><img src="https://pic1.zhimg.com/80/v2-7676302038a33c5527b88961eec0673d_hd.jpg" alt="UTXO数据结构"></p>
<p><del>卖家真正担心不应该是诚实节点造成的分叉，而应该是恶意节点来篡改记录。</del>那么恶意节点可能如何来篡改呢？</p>
<blockquote>
<p>比如一个恶意的买家，先向卖家付了钱，卖家在交易被确认一次后就马上把货物给了买家。买家在收到货物后想要把刚花出去的这笔钱再花一遍，听起来好像很不可能但是这确实是有可能的。只要这个买家掌握了大量的算力，以更快的速度去确认交易，让包含自己第二次交易的链的长度超过第一次交易（用的同一笔钱）所在链的长度，那么根据约定第二次交易将会被网络采纳，即卖家得到的钱将无效，即他的那条UTXO将不被其他节点承认。这个双花犯罪的关键在于追赶的速度（之所以一定为追赶，因为必定要先付款给卖家再作假赶超）。要避免这个双花的问题的话，就让卖家默认等到确认6次以后再发货，这时恶意买家已经落后6个区块了（比之前假设的确认1一次就发货的难度大得多），想要追赶在理论上是不可行的，或者说不划算的，这样这笔钱才能说真正的到了卖家口袋里。</p>
</blockquote>
<p>最终结论，两种担心都是存在的。之前那种<code>所有的交易在链1和链2里面都存在，所以对于用户而言UTXO列表都是一样的</code>，这个前提中，是可能存在某个交易在链1里面出现了，但是在链2里面没有出现的情况。因为不同矿工打包的规则是不同的，在同一个交易列表中，不同矿工可能选择不同的交易来打包，而谁算的最快那就用谁选的交易来打包。所以在临时分叉的情况下，可能存在这种情况</p>
<blockquote>
<p>某个交易发出后，被采用链1（临时状态）的节点打包进了链条，但是却没有被链2所打包确认，这时这笔交易目前还不是安全的，因为如果这时链1被抛弃，那么这笔交易将依旧没被确认。</p>
</blockquote>
<h2 id="拜占庭将军问题（Byzantine-Generals-Problem）"><a href="#拜占庭将军问题（Byzantine-Generals-Problem）" class="headerlink" title="拜占庭将军问题（Byzantine Generals Problem）"></a>拜占庭将军问题（Byzantine Generals Problem）</h2><blockquote>
<p><strong>结论：</strong>若叛徒数为m，当且仅当将军总数n&gt;=3m+1时才有解</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>拜占庭帝国派出10只军队，去包围进攻一个强大的敌人</li>
<li>至少6只军队同时进攻才能攻下敌国</li>
</ul>
<h3 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h3><p>一些将军可能是叛徒，会发布假的（相反的）进攻意向</p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>将军们需要找到一种共识机制（即要么全部进攻，要不全部不进攻，免得打败仗，这里容易误解为一定要达成进攻意见），可以远程协商，赢取战斗</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li>每个节点给所有的其它节点发送消息</li>
<li>每个节点根据接收到的所有消息来决定最终的策略</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>每个节点需要向全网节点发送大量消息，可能造成网络延时</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设这里叛将只有一个，忠将有3个。A是总将军。信号0代表不进攻，信号1代表进攻。</p>
<p><strong>情况一：</strong>叛徒为B，忠臣为A，C，D</p>
<p>A(忠)发起进攻提议，即 A发给B，C，D信号1</p>
<p>B收到后，捣乱，发给A，C，D信号0，企图让部分将军不出兵，导致战斗失利</p>
<p>C收到后，向A，B，D如实发送信号1，代表自己收到的命令是1</p>
<p>D同理</p>
<p>最终</p>
<table>
<thead>
<tr>
<th style="text-align:center">临近将军节点</th>
<th style="text-align:center">B收到的信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>对于B，因为是叛徒，则其肯定不会发起进攻，即使收到了三个1</p>
<table>
<thead>
<tr>
<th style="text-align:center">临近将军节点</th>
<th style="text-align:center">C收到的信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>对于C进攻2票，故选择进攻。</p>
<p>A，D同理。最终会有半数以上（3位）的将军发起进攻。</p>
<p><strong>情况二：</strong>总将军A为叛徒，B，C，D为忠臣。A试图让军队少于半数选择进攻。</p>
<p>A(叛)向B发出进攻信号1，向C和D发出信号0</p>
<p>B收到后，发给A，C，D信号1</p>
<p>C收到后，向A，B，D如实发送信号0，代表自己收到的命令是0</p>
<p>D同理</p>
<p>最终</p>
<table>
<thead>
<tr>
<th style="text-align:center">临近将军节点</th>
<th style="text-align:center">B收到的信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">临近将军节点</th>
<th style="text-align:center">C收到的信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">临近将军节点</th>
<th style="text-align:center">D收到的信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>最终没有一个将军会发起进攻，叛徒依旧没有得逞。</p>
<h2 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h2><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公钥用于加密，私钥用于解密</p>
<p>公钥可以通过私钥生成，私钥可以推导出公钥</p>
<p>从公钥无法推导出私钥</p>
<p>相同输入每次加密得到的结果不同</p>
<p><strong>优点：</strong>解决了密钥传输过程中的安全性问题</p>
<p><strong>不足：</strong>虽然解决了信息安全传输不被窃听的问题，但是无法验证“该消息确实是发送方发送的”，有可能是中间人截获了信息然后篡改了内容，再发送的（只需要获取接受者公钥即可）。</p>
<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><p>对于存放用户密码的场景，简单的hash可能会收到彩虹表攻击（就是预先计算好一些列的哈希值，然后进行对比），而此时可以通过加盐来加大破解的成本。</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><img src="2018-01-23_21-35-53.png" alt="数字签名示意图"></p>
<p>通过数字签名中的私钥加密摘要的过程，可以保证接受者可以判断消息是否来自发送方，且没有被篡改过。</p>
<h3 id="证书授权中心CA（Certificate-Authority）"><a href="#证书授权中心CA（Certificate-Authority）" class="headerlink" title="证书授权中心CA（Certificate Authority）"></a>证书授权中心CA（Certificate Authority）</h3><p><strong>为了解决这样一种情况：</strong>在获取公钥的过程中，被攻击者截获，然后把他的公钥发给了接受者，那么接受者将会把消息发给攻击者了。</p>
<ul>
<li>CA解决了电子商务中公钥的可信度问题</li>
<li>负责证明“我确实是我”的问题</li>
<li>CA是受信任的第三方，公钥的合法性检验</li>
<li>CA证书的内容<ul>
<li>证书持有人的公钥</li>
<li>证书授权中心名称</li>
<li>证书有效期</li>
<li>证书授权中心的数字签名</li>
</ul>
</li>
</ul>
<p>前提是大家都信任这个CA（第三方的公司），大家都事先有CA的公钥。发送者将自己的公钥存放在CA里，CA用他的私钥进行签名，然后发送者将这个CA发给接受者，接受者通过CA的公钥去查看证书内的内容，即可取出发送者的公钥，以及其中的实体名称。因为CA是通过私钥签名的所以这个实体和公钥的绑定关系，所以无法伪造。</p>
<p><strong>CA证书使用场景-HTTPS</strong></p>
<ul>
<li>客户端通过https向服务器发送安全连接请求</li>
<li>服务器用私钥加密网页内容，连同CA证书一并发给客户端</li>
<li>客户端会根据CA证书验证CA是否合法<ul>
<li>如果验证失败，客户端弹出警告信息</li>
<li>如果验证通过，客户端使用CA证书中的公钥向服务器发送加密信息</li>
</ul>
</li>
<li>像Chrome访问https报红，是因为在Chrome里面预先存储了一些CA，然后获取到的新CA不在这个列表里面，所以会警告，只要把这个新的CA导入到浏览器里面就不会再警告了。</li>
</ul>
<h2 id="未花费交易输出UTXO-Unspent-TranXtion-Output"><a href="#未花费交易输出UTXO-Unspent-TranXtion-Output" class="headerlink" title="未花费交易输出UTXO-Unspent TranXtion Output"></a>未花费交易输出UTXO-Unspent TranXtion Output</h2><ul>
<li>UTXO，用比特币拥有者的公钥锁定（加密）的一个数字</li>
<li>UTXO == 比特币</li>
<li>比特币系统里没有比特币，只有UTXO</li>
<li>比特币系统里没有账户，只有UTXO（公钥锁定）</li>
<li>比特币系统里没有余额，只有UTXO（账户余额只是比特币钱包的概念）</li>
<li>UTXO存在全节点的数据库里</li>
<li>转账将消耗属于你自己的UTXO，同时生成新的UTXO，并用接受者的公钥锁定。</li>
</ul>
<h2 id="交易验证-基于栈的脚本语言"><a href="#交易验证-基于栈的脚本语言" class="headerlink" title="交易验证-基于栈的脚本语言"></a>交易验证-基于栈的脚本语言</h2><ul>
<li><p>栈（stack</p>
</li>
<li><p>交易验证</p>
<ul>
<li>对栈的操作：OP_DUP（复制粘贴栈顶元素），碰到数字就压栈</li>
<li>逻辑运算符：OP_EQUALVERIFY（比较栈顶的两个元素是否相等，如果不等，整个脚本就执行失败了，如果相等，脚本会继续执行）</li>
<li>加解密运算符：OP_HASH160（对栈顶元素计算SHA256/RipeMD160），OP_CHECKSIG（验证签名）</li>
<li>算数运算符：OP_ADD，OP_SUB，OP_MUL，OP_DIV</li>
</ul>
</li>
<li><p>锁定脚本</p>
<ul>
<li>OP_DUP OP_HASH160 &lt;<strong>发送者</strong>公钥哈希&gt; OP_EQUALVERIFY OP_CHECKSIG</li>
<li>在锁定的时候的接受者，即为解锁消费时候的发送者，这里是站在解锁消费的角度上来看</li>
</ul>
</li>
<li><p>解锁脚本</p>
<ul>
<li>&lt;发送者签名&gt; &lt;发送者公钥&gt;（提供自己的签名和公钥来证明我确实是我）</li>
</ul>
</li>
<li><p>交易验证：<strong>运行解锁脚本 + 锁定脚本</strong> =&gt; True</p>
</li>
<li><p><a href="https://pic1.zhimg.com/80/v2-7676302038a33c5527b88961eec0673d_hd.jpg" target="_blank" rel="noopener">揭秘比特币和区块链（五）：深入理解比特币交易的脚本</a></p>
<blockquote>
<p>疑问：验证发送者公钥哈希是否多余？</p>
<p>答：不是的，因为如果没有这一步，任何人只要根据自己的私钥生成一个签名和公钥都可以通过验证。通过验证公钥哈希，首先可以确定目前的发送者的公钥和当初UTXO生成时指定的接收者的公钥是相同的。然后再来判断你是否还能提供跟进一步的签名。</p>
</blockquote>
</li>
</ul>
<h2 id="交易的传播"><a href="#交易的传播" class="headerlink" title="交易的传播"></a>交易的传播</h2><ul>
<li>交易包含两部分，n输入和m输出，n&gt;=0，m&gt;0<ul>
<li>输入 == 要被花费的UTXO + 解锁脚本</li>
<li>输出 == UTXO（币值 + 锁定脚本）</li>
</ul>
</li>
<li>钱包软件生成交易，并向邻近节点传播</li>
<li>节点对收到的交易进行验证，并丢弃不合法交易<ul>
<li>交易的size要小于区块size的上限</li>
<li>交易输入UTXO是存在的</li>
<li>交易输入UTXO没有被其他交易引用-防止双花（Double Spending）</li>
<li>输入总金额 &gt; 输出总金额</li>
<li>解锁脚本验证</li>
</ul>
</li>
<li>将合格的交易加入到本地的Transaction数据库中，并将合法交易转给邻近节点</li>
</ul>
<h2 id="区块的生成"><a href="#区块的生成" class="headerlink" title="区块的生成"></a>区块的生成</h2><ul>
<li><p>矿工在挖块前要组建区块</p>
<ul>
<li><p>将<code>coinbase</code>交易打包进区块</p>
</li>
<li><p>将交易池中高优先级的交易打包进区块</p>
<ul>
<li>优先级 = 交易的额度 * UTXO的深度 / 交易的size</li>
<li>在优先级中加入UTXO的深度可以防止连续的交易（大额来回转账）造成的粉尘攻击</li>
</ul>
</li>
<li><p>创建区块的头部</p>
<p>| 版本号  | 前一个区块的哈希 | Merkel树根 | 时间戳  | 难度值  | Nonce |<br>| :–: | :——: | :——: | :–: | :–: | :—: |<br>|      |          |          |      |      |       |</p>
</li>
<li><p>挖矿成功后，将计算出来的随机数<code>nonce</code>填入区块头部，向邻近节点传播</p>
</li>
</ul>
</li>
</ul>
<h2 id="区块的验证链接"><a href="#区块的验证链接" class="headerlink" title="区块的验证链接"></a>区块的验证链接</h2><ul>
<li>相邻节点收到新区块后，立即做一下检查<ul>
<li>验证POW的nonce值是否符合难度值</li>
<li>检查时间戳是否小于当前时间2小时</li>
<li>检查Merkle树根是否正确</li>
<li>检查区块size要小于区块size的上限</li>
<li>第一笔交易必须是<code>coinbase</code></li>
<li>验证每个交易</li>
</ul>
</li>
</ul>
<h2 id="Merkle-Tree结构"><a href="#Merkle-Tree结构" class="headerlink" title="Merkle Tree结构"></a>Merkle Tree结构</h2><p><img src="2018-01-24_21-48-29.png" alt="Merkle Tree"></p>
<ul>
<li>特点<ul>
<li>全二叉树（如果叶子节点为单数则复制最后一个交易）</li>
</ul>
</li>
<li>作用<ul>
<li>防止数据篡改（叶子节点的改变会影响到根 ）</li>
<li>快速验证某个交易是否存在</li>
<li>节点存储Hash值</li>
<li>从叶子节点构造树</li>
</ul>
</li>
</ul>
<h2 id="钱包地址的生成"><a href="#钱包地址的生成" class="headerlink" title="钱包地址的生成"></a>钱包地址的生成</h2><p><img src="2018-01-25_21-22-47.png" alt="钱包地址的生成"></p>
<h1 id="区块链分叉"><a href="#区块链分叉" class="headerlink" title="区块链分叉"></a>区块链分叉</h1><h2 id="软分叉"><a href="#软分叉" class="headerlink" title="软分叉"></a>软分叉</h2><p><img src="2018-01-25_11-59-02.png" alt="软分叉"></p>
<ul>
<li>由比特币交易的数据结构改变引起，但区块的数据结构未改变</li>
<li>老节点接收新旧格式的区块，新节点只接受新区块<ul>
<li>矿工激活软分叉<code>MASF-Miner Acivated Soft Fork</code></li>
<li>用户激活软分叉<code>UASF-User Activated Soft Fork</code><ul>
<li>Core团队新发明，应对矿工的不合作</li>
<li>隔离见证<code>Segwit-Segregation Witness</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="硬分叉"><a href="#硬分叉" class="headerlink" title="硬分叉"></a>硬分叉</h2><p><img src="2018-01-25_12-02-14.png" alt="硬分叉"></p>
<ul>
<li>由于交易结构的变化，或区块的结构的变化引起的</li>
<li>新旧节点相互拒绝对方的区块</li>
<li>产生两个币种，如BCC</li>
</ul>
<h2 id="临时分叉"><a href="#临时分叉" class="headerlink" title="临时分叉"></a>临时分叉</h2><ul>
<li>仅发生于几乎同时爆块的情况</li>
<li>分叉是暂时的</li>
<li>根据公示机制，矿工最终切换到最长链上挖矿</li>
<li>短链上的交易全部无效，包括矿工费</li>
</ul>
<h2 id="隔离见证"><a href="#隔离见证" class="headerlink" title="隔离见证"></a>隔离见证</h2><ul>
<li>隔离见证<ul>
<li>安全隐患、黑客通过改变交易签名信息改变交易ID</li>
<li>将签名部分从交易中移除，从而间接扩容</li>
</ul>
</li>
<li>香港共识</li>
<li>纽约共识</li>
</ul>
<h2 id="比特币私钥格式WIF-Wallet-Import-Format"><a href="#比特币私钥格式WIF-Wallet-Import-Format" class="headerlink" title="比特币私钥格式WIF-Wallet Import Format"></a>比特币私钥格式WIF-Wallet Import Format</h2><ul>
<li>WIF私钥格式更短，标准格式私钥256个bit，16进制长度 = 256 / 4 = 64字符<ul>
<li>经过Base65编码，表示长度更短</li>
<li>未压缩格式私钥：5开头，大小为<strong>51</strong>字节，第一位存放版本信息</li>
<li>压缩格式私钥（指生成压缩格式公钥的私钥）：K或L开头，大小为52字节，第一位放版本信息，多出的最后一个字节存放是否压缩信息</li>
</ul>
</li>
<li>WIF格式可以自动侦测地址错误（方便钱包筛选）<ul>
<li>通过私钥的哈希值产生校验码</li>
</ul>
</li>
</ul>
<h2 id="公钥-压缩格式-amp-非压缩格式"><a href="#公钥-压缩格式-amp-非压缩格式" class="headerlink" title="公钥-压缩格式&amp;非压缩格式"></a>公钥-压缩格式&amp;非压缩格式</h2><ul>
<li>公钥由X和Y轴的值组成</li>
<li>未压缩的公钥以<code>04</code>开头</li>
<li>压缩公钥以<code>02/03</code>开头</li>
</ul>
<h2 id="轻钱包-amp-SPV验证机制"><a href="#轻钱包-amp-SPV验证机制" class="headerlink" title="轻钱包&amp;SPV验证机制"></a>轻钱包&amp;SPV验证机制</h2><ul>
<li><p>轻钱包是比特币的非全节点，存储空间限制</p>
<ul>
<li><p>只下载<code>block header</code>，size很小只有80字节，区块本身大小1M，1.8M</p>
<p>| 版本号  | 前区块哈希 | Merkle树根 | 时间戳  | 难度值  | Nonce |<br>| :–: | :—: | :——: | :–: | :–: | :—: |<br>|      |       |          |      |      |       |</p>
</li>
<li><p>向邻近全节点发送请求得到UTXO信息</p>
</li>
</ul>
</li>
<li><p>简单支付验证SPV - <code>Simplified Payment Verification</code></p>
<ul>
<li>非全节点支付验证，判断交易是否已经在区块链中，多少确认数</li>
<li>向邻近全节点发送请求关于特定比特币地址和交易的信息</li>
<li>邻近全节点向钱包返回<code>Mekle Path</code>验证路径和相应的<code>block header</code></li>
<li>钱包根据<code>Merkle Path</code>计算出<code>Mekle Root</code>，验证是否匹配<code>Block header</code>里的<code>Merkle Root</code>值</li>
<li>确认响应的<code>Block header</code>的深度是否大于6</li>
</ul>
</li>
</ul>
<h2 id="私钥的生成建议"><a href="#私钥的生成建议" class="headerlink" title="私钥的生成建议"></a>私钥的生成建议</h2><p>可以选用一串中文<code>C</code>和一串英文<code>E</code>，分别利用MD5进行hash，得到两个128bit的哈希字符串<code>H(C)</code>和<code>H(E)</code>，然后首尾相连（正好256bit）<code>H(C)+H(E)</code>，再将最后的 8位替换成某人的生日</p>
<h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h2><p><a href="http://www.infoq.com/cn/articles/bitcoin-and-block-chain-part02" target="_blank" rel="noopener">揭秘比特币和区块链（二）：什么是工作量证明？</a></p>
<p><strong>区块头部</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">版本号</th>
<th style="text-align:center">前区块哈希</th>
<th style="text-align:center">Merkle树根</th>
<th style="text-align:center">时间戳</th>
<th style="text-align:center">难度值</th>
<th style="text-align:center">Nonce</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4字节</td>
<td style="text-align:center">32字节</td>
<td style="text-align:center">32字节</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">4字节</td>
</tr>
</tbody>
</table>
<p>为了使区块头部哈希的结果值小于目标值，会不断修改尝试不同的<code>nonce</code>值，但是随着难度值的升高而且<code>nonce</code>值长度的限制，所以很可能遍历完所有的$$2^{32}$$个数都没有成功，这时矿工会调整交易的顺序或者<code>coinbase</code>里的<code>extranonce</code>以此来影响<code>Merkle tree root</code>的哈希值。以此来改变区块头部哈希的值，再来新的一轮尝试。 </p>
<h1 id="区块链安全"><a href="#区块链安全" class="headerlink" title="区块链安全"></a>区块链安全</h1><h2 id="可塑性攻击"><a href="#可塑性攻击" class="headerlink" title="可塑性攻击"></a>可塑性攻击</h2><p>存在多个可被验证的交易签名，这样修改交易签名引起交易的哈希值改变，即TXID改变，而这样会导致原TXID无法找到。</p>
<p><code>隔离见证</code>：</p>
<ul>
<li>将可伪造的签名部分移除交易数据结构，在另一个地方存放签名</li>
<li>改变签名不影响TXID的变化</li>
</ul>
<blockquote>
<p>攻击者先去交易所提币，然后侦听数据包并截获交易所给自己账户转钱的区块数据包，并把其中关于自己的交易的签名修改了，那么会导致生成交易的ID和交易所里面记录的交易ID不同，于是这个被修改的区块就会先被主链所接受而拒绝交易所发出的区块，因为这笔交易已经被记录过了。这时，攻击者会联系交易所说自己并没有收到钱，是交易所的系统故障了要求重发，于是攻击者就获得了两份的比特币。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/01/11/学习Linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/11/学习Linux/" class="post-title-link" itemprop="url">学习Linux</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-01-11 17:08:40" itemprop="dateCreated datePublished" datetime="2018-01-11T17:08:40+08:00">2018-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2018-01-28 22:10:48" itemprop="dateModified" datetime="2018-01-28T22:10:48+08:00">2018-01-28</time>
              </span>

          
            <span id="/2018/01/11/学习Linux/" class="post-meta-item leancloud_visitors" data-flag-title="学习Linux" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/01/11/学习Linux/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/11/学习Linux/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件权限与目录配置"><a href="#文件权限与目录配置" class="headerlink" title="文件权限与目录配置"></a>文件权限与目录配置</h1><p><img src="https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/img/centos7_0210filepermission_2.gif" alt="文件属性"></p>
<p><strong>第一栏</strong></p>
<p><code>所有者（owner）</code>、<code>群组（group）</code>、<code>其他（others）</code>概念</p>
<p>一个用户可以加入多个群组</p>
<p>进入一个目录需要<code>x</code>执行权限</p>
<p>用数字表示权限：<code>r:4   w:2   x:1</code></p>
<p><strong>第二栏</strong></p>
<p>表示有多少文件名连接到此<code>i-node</code></p>
<h2 id="修改文件属性与权限"><a href="#修改文件属性与权限" class="headerlink" title="修改文件属性与权限"></a>修改文件属性与权限</h2><ul>
<li><code>chgrp</code></li>
<li><code>chown</code></li>
<li><code>chmod</code><ul>
<li><code>| chmod | u g o a | +（加入） -（除去） =（设置） | r w x | 文件或目录 |</code></li>
<li><code>o</code>：other</li>
<li><code>a</code>：all</li>
<li>如：<code># chmod  u=rwx,go=rx  .bashrc</code></li>
</ul>
</li>
</ul>
<h2 id="目录配置"><a href="#目录配置" class="headerlink" title="目录配置"></a>目录配置</h2><p><code>/usr</code>：放置可分享与不可变动的数据。所有系统的默认的软件都会放置在此</p>
<p><code>/usr/local</code>：系统管理员在本机自行安装自己下载的软件，建议安装到此目录，便于管理。</p>
<p><code>/var</code>：主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如MySQL数据库的文件等等</p>
<h2 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# ls [-aAdfFhilnrRSt] 文件名或目录名称..</span><br><span class="line">[root@study ~]# ls [--color=&#123;never,auto,always&#125;] 文件名或目录名称..</span><br><span class="line">[root@study ~]# ls [--full-time] 文件名或目录名称..</span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</span><br><span class="line">-A  ：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录</span><br><span class="line">-d  ：仅列出目录本身，而不是列出目录内的文件数据（常用）</span><br><span class="line">-f  ：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）</span><br><span class="line">-F  ：根据文件、目录等信息，给予附加数据结构，例如：</span><br><span class="line">      *:代表可可执行文件； /:代表目录； =:代表 socket 文件； &amp;#124;:代表 FIFO 文件；</span><br><span class="line">-h  ：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；</span><br><span class="line">-i  ：列出 inode 号码，inode 的意义下一章将会介绍；</span><br><span class="line">-l  ：长数据串行出，包含文件的属性与权限等等数据；（常用）</span><br><span class="line">-n  ：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）</span><br><span class="line">-r  ：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；</span><br><span class="line">-R  ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；</span><br><span class="line">-S  ：以文件大小大小排序，而不是用文件名排序；</span><br><span class="line">-t  ：依时间排序，而不是用文件名。</span><br><span class="line">--color=never  ：不要依据文件特性给予颜色显示；</span><br><span class="line">--color=always ：显示颜色</span><br><span class="line">--color=auto   ：让系统自行依据设置来判断是否给予颜色</span><br><span class="line">--full-time    ：以完整时间模式 （包含年、月、日、时、分） 输出</span><br><span class="line">--time=&#123;atime,ctime&#125; ：输出 access 时间或改变权限属性时间 （ctime）</span><br><span class="line">                       而非内容变更时间 （modification time）</span><br></pre></td></tr></table></figure>
<h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# cp [-adfilprsu] 来源文件（source） 目标文件（destination）</span><br><span class="line">[root@study ~]# cp [options] source1 source2 source3 .... directory</span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；（常用）</span><br><span class="line">-d  ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；</span><br><span class="line">-f  ：为强制（force）的意思，若目标文件已经存在且无法打开，则移除后再尝试一次；</span><br><span class="line">-i  ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</span><br><span class="line">-l  ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；</span><br><span class="line">-p  ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</span><br><span class="line">-r  ：递回持续复制，用于目录的复制行为；（常用）</span><br><span class="line">-s  ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；</span><br><span class="line">-u  ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。</span><br><span class="line">--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。</span><br><span class="line">最后需要注意的，如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</span><br></pre></td></tr></table></figure>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# rm [-fir] 文件或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-f  ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</span><br><span class="line">-i  ：互动模式，在删除前会询问使用者是否动作</span><br><span class="line">-r  ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</span><br></pre></td></tr></table></figure>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# mv [-fiu] source destination</span><br><span class="line">[root@study ~]# mv [options] source1 source2 source3 .... directory</span><br><span class="line">选项与参数：</span><br><span class="line">-f  ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</span><br><span class="line">-i  ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</span><br><span class="line">-u  ：若目标文件已经存在，且 source 比较新，才会更新 （update）</span><br></pre></td></tr></table></figure>
<h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# cat [-AbEnTv]</span><br><span class="line">选项与参数：</span><br><span class="line">-A  ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</span><br><span class="line">-b  ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</span><br><span class="line">-E  ：将结尾的断行字符 $ 显示出来；</span><br><span class="line">-n  ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；</span><br><span class="line">-T  ：将 [tab] 按键以 ^I 显示出来；</span><br><span class="line">-v  ：列出一些看不出来的特殊字符</span><br></pre></td></tr></table></figure>
<h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>与<code>cat</code>相反，反向显示</p>
<h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# nl [-bnw] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-b  ：指定行号指定的方式，主要有两种：</span><br><span class="line">      -b a ：表示不论是否为空行，也同样列出行号（类似 cat -n）；</span><br><span class="line">      -b t ：如果有空行，空的那一行不要列出行号（默认值）；</span><br><span class="line">-n  ：列出行号表示的方法，主要有三种：</span><br><span class="line">      -n ln ：行号在屏幕的最左方显示；</span><br><span class="line">      -n rn ：行号在自己字段的最右方显示，且不加 0 ；</span><br><span class="line">      -n rz ：行号在自己字段的最右方显示，且加 0 ；</span><br><span class="line">-w  ：行号字段的占用的字符数。</span><br></pre></td></tr></table></figure>
<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><ul>
<li>空白键 （space）：代表向下翻一页；</li>
<li>Enter ：代表向下翻“一行”；</li>
<li>/字串 ：代表在这个显示的内容当中，向下搜寻“字串”这个关键字；</li>
<li>:f ：立刻显示出文件名以及目前显示的行数；</li>
<li>q ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><ul>
<li>空白键 ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>/字串 ：向下搜寻“字串”的功能；</li>
<li>?字串 ：向上搜寻“字串”的功能；</li>
<li>n ：重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li>N ：反向的重复前一个搜寻 （与 / 或 ? 有关！）</li>
<li>g ：前进到这个数据的第一行去；</li>
<li>G ：前进到这个数据的最后一行去 （注意大小写）；</li>
<li>q ：离开 less 这个程序；</li>
</ul>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# head [-n number] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-n  ：后面接数字，代表显示几行的意思</span><br></pre></td></tr></table></figure>
<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# tail [-n number] 文件</span><br><span class="line">选项与参数：</span><br><span class="line">-n  ：后面接数字，代表显示几行的意思</span><br><span class="line">-f  ：表示持续侦测后面所接的文件名，要等到按下[ctrl]-c才会结束tail的侦测</span><br></pre></td></tr></table></figure>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p><code>$变量名</code>或者<code>${变量名}</code>用来引用变量</p>
<p><code>$(命令)</code>返回命令执行结果</p>
<p>给变量赋值：变量名=值【后面的值中如果使用双引号包裹那么将会解引用其中出现的变量，如果单引号包裹那么将原样引用】</p>
<p>给变量追加值：变量名=$变量名+追加的内容</p>
<p>$RANDOM：返回0~32767 的一个随机数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/01/10/学习GoLang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/10/学习GoLang/" class="post-title-link" itemprop="url">学习GoLang</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-01-10 16:48:47" itemprop="dateCreated datePublished" datetime="2018-01-10T16:48:47+08:00">2018-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-07 17:34:46" itemprop="dateModified" datetime="2019-01-07T17:34:46+08:00">2019-01-07</time>
              </span>

          
            <span id="/2018/01/10/学习GoLang/" class="post-meta-item leancloud_visitors" data-flag-title="学习GoLang" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/01/10/学习GoLang/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/10/学习GoLang/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="文件代码的一般顺序"><a href="#文件代码的一般顺序" class="headerlink" title="文件代码的一般顺序"></a>文件代码的一般顺序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前程序的包名</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入其他的包</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量的定义</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量的声明与赋值</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"TomKK"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般类型变量的声明</span></span><br><span class="line"><span class="keyword">type</span> num <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//结构的声明</span></span><br><span class="line"><span class="keyword">type</span> gopher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口的声明</span></span><br><span class="line"><span class="keyword">type</span> golang <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   fmt.Println(pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可读性更强</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>type <code>alias</code> typename</p>
<blockquote>
<p>这里严格来说不能称为别名，而是底层数据结构相同的自定义类型，在进行类型转化的时候还是需要进行显示转换。</p>
</blockquote>
<h2 id="变量组声明"><a href="#变量组声明" class="headerlink" title="变量组声明"></a>变量组声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	c = <span class="number">1</span></span><br><span class="line">	d = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	e <span class="keyword">int</span></span><br><span class="line">	f <span class="keyword">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="布尔类型：bool"><a href="#布尔类型：bool" class="headerlink" title="布尔类型：bool"></a>布尔类型：bool</h3><ul>
<li>长度：1字节</li>
<li>不可以使用数字代表true或者false</li>
</ul>
<h3 id="整型：int-uint"><a href="#整型：int-uint" class="headerlink" title="整型：int/uint"></a>整型：int/uint</h3><ul>
<li>根据运行平台，可能为32位或64位</li>
</ul>
<h3 id="8位整型：int8-uint8"><a href="#8位整型：int8-uint8" class="headerlink" title="8位整型：int8/uint8"></a>8位整型：int8/uint8</h3><ul>
<li>长度：1字节</li>
</ul>
<h3 id="字节型：byte"><a href="#字节型：byte" class="headerlink" title="字节型：byte"></a>字节型：byte</h3><ul>
<li>uint8别名</li>
</ul>
<h3 id="16位整型：int16-uint16"><a href="#16位整型：int16-uint16" class="headerlink" title="16位整型：int16/uint16"></a>16位整型：int16/uint16</h3><h3 id="32位整型：int32-rune-uint32"><a href="#32位整型：int32-rune-uint32" class="headerlink" title="32位整型：int32(rune)/uint32"></a>32位整型：int32(rune)/uint32</h3><h3 id="64位整型：int64-uint64"><a href="#64位整型：int64-uint64" class="headerlink" title="64位整型：int64/uint64"></a>64位整型：int64/uint64</h3><h3 id="浮点型：float32-float64"><a href="#浮点型：float32-float64" class="headerlink" title="浮点型：float32/float64"></a>浮点型：float32/float64</h3><ul>
<li>长度：4/8字节</li>
<li>小数位：精确到7/15小数位</li>
</ul>
<h3 id="复数：complex64-complex128"><a href="#复数：complex64-complex128" class="headerlink" title="复数：complex64/complex128"></a>复数：complex64/complex128</h3><ul>
<li>长度：8/16字节</li>
</ul>
<h3 id="足够保存指针的32位或64位整数型：uintptr"><a href="#足够保存指针的32位或64位整数型：uintptr" class="headerlink" title="足够保存指针的32位或64位整数型：uintptr"></a>足够保存指针的32位或64位整数型：uintptr</h3><ul>
<li>随操作系统而改变</li>
</ul>
<h3 id="其他值类型：array-struct-string"><a href="#其他值类型：array-struct-string" class="headerlink" title="其他值类型：array, struct, string"></a>其他值类型：array, struct, string</h3><h3 id="伪引用类型：slice-map-chan"><a href="#伪引用类型：slice-map-chan" class="headerlink" title="伪引用类型：slice, map, chan"></a>伪引用类型：slice, map, chan</h3><p><a href="http://www.tapirgames.com/blog/golang-has-no-reference-values" target="_blank" rel="noopener">参考博文</a></p>
<h3 id="接口类型：interface"><a href="#接口类型：interface" class="headerlink" title="接口类型：interface"></a>接口类型：interface</h3><h3 id="函数类型：func"><a href="#函数类型：func" class="headerlink" title="函数类型：func"></a>函数类型：func</h3><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>普通类型可以通过<code>type(变量)</code>来进行显式强制转换</p>
<p>对于接口类型向上转型的话，应该通过<code>comma-ok类型断言</code>或者<code>type switch</code>来进行操作</p>
<h2 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h2><ul>
<li>支持自动推断类型</li>
<li>类型安全，不存在类型隐式转换，只能强制转换，如<ul>
<li><code>var a float32 = 1.1</code></li>
<li><code>b := int(a)</code></li>
</ul>
</li>
<li><code>b := 1</code>，最简的声明并赋值变量的形式。不能用于全局变量。</li>
<li>全局变量的声明可以使用<code>var ( )</code>方式简写</li>
<li>全局变量的声明不可以省略<code>var</code>，但是可以使用并行方式</li>
<li>所有变量都可以使用类型推断</li>
<li>局部变量不可以使用<code>var( )</code>方式简写，只能使用并行方式。</li>
<li>并行方式：<code>var a, b, c int = 1, 2, 3</code></li>
<li><code>a, _, c, d := 1, 2, 3, 4</code> </li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p><code>iota</code>是常量计数器，从0开始，组中经过一个常量会自动递增1，通过初始化规则与<code>iota</code>可以达到枚举的效果。每遇到一个<code>const</code>关键字，<code>iota</code>就会重置为0。</p>
<blockquote>
<p>初始化规则：在定义常量组的时候，如果不提供初始值，则表示将使用上行的表达式</p>
</blockquote>
<p>比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">	a = <span class="string">'A'</span></span><br><span class="line">	b</span><br><span class="line">	c = <span class="literal">iota</span></span><br><span class="line">	d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 a = 65, b = 65, c = 2, d = 3</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>一元运算符：<code>^</code> <code>!</code></p>
<p>二元运算符：</p>
<ul>
<li><code>*</code> <code>/</code> <code>%</code> <code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&amp;</code> <code>&amp;^</code></li>
<li><code>+</code> <code>-</code> <code>|</code> <code>^</code></li>
<li><code>==</code> <code>!=</code> <code>&lt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>&gt;</code></li>
<li><code>&lt;-</code> （专门用于channel）</li>
<li><code>&amp;&amp;</code> <code>||</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 6：0110</span><br><span class="line">11：1011</span><br><span class="line">———————-----</span><br><span class="line">&amp;   0010 = 2</span><br><span class="line">|   1111 = 15</span><br><span class="line">^   1101 = 13</span><br><span class="line">&amp;^  0100 = 4  [为1则置0]</span><br></pre></td></tr></table></figure>
<h2 id="new、make操作"><a href="#new、make操作" class="headerlink" title="new、make操作"></a>new、make操作</h2><p><code>new(T)</code>分配了零值填充的<code>T</code>类型的内存空间，并且返回其地址，即一个<code>*T</code>类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型<code>T</code>的零值。</p>
<p>内建函数<code>make(T, args)</code>与<code>new(T)</code>有着不同的功能，make只能创建<code>slice</code>、<code>map</code>和<code>channel</code>，并且返回一个有初始值(非零)的<code>T</code>类型，而不是<code>*T</code>。</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>直接采用<code>.</code>来操作指针目标对象的成员。</p>
<p>通过<code>&amp;</code>取变量地址，使用<code>*</code>通过指针间接访问目标对象</p>
<p>默认值为<code>nil</code>而非<code>null</code></p>
<h2 id="递增递减语句"><a href="#递增递减语句" class="headerlink" title="递增递减语句"></a>递增递减语句</h2><p>只能<code>a++</code>或<code>a-—</code>这么单独作为语句使用，而不能作为表达式使用。</p>
<blockquote>
<p>注意：没有++a</p>
</blockquote>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p><code>if</code>后没有括号</p>
<p><code>if</code>左大括号需要和<code>if</code>同一行</p>
<p>在<code>if</code>后支持初始化操作，如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a, b:=<span class="number">1</span>, <span class="number">2</span>; a&gt;<span class="number">1</span> &amp;&amp; b&gt;<span class="number">1</span> &#123;</span><br><span class="line">  <span class="comment">//这里a, b的作用域只有if语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>if</code> 的便捷语句定义的变量同样可以在任何对应的 <code>else</code> 块中使用。</p>
<h2 id="循环语句for"><a href="#循环语句for" class="headerlink" title="循环语句for"></a>循环语句for</h2><p>只有一个循环语句关键字<code>for</code>，但是支持三种形式</p>
<blockquote>
<p>形式一：无限循环，在循环体内手动<code>break</code>退出循环</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'A'</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="string">'C'</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">	a++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>形式二：类似<code>while</code></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'A'</span></span><br><span class="line"><span class="keyword">for</span> a &gt; <span class="string">'C'</span> &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	a++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>形式三：类似其他语言的<code>for</code>语句的形式</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a := <span class="number">1</span>; a &lt; <span class="number">5</span>; a++ &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择语句switch"><a href="#选择语句switch" class="headerlink" title="选择语句switch"></a>选择语句switch</h2><p>可以使用<strong>任何类型或表达式</strong>作为<strong>条件语句</strong></p>
<p>不需要写<code>break</code>，默认不会继续执行接下来的<code>case</code></p>
<p>如果希望执行下一个<code>case</code>，需要使用<code>fallthrough</code>语句</p>
<p>支持一个初始化表达式（可以是并行方式）。<strong>右侧需要跟上分号</strong></p>
<p>左大括号必须和条件语句在同一行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> a := <span class="number">1</span>; &#123;</span><br><span class="line"><span class="keyword">case</span> a == <span class="number">1</span>:</span><br><span class="line">	fmt.Println(<span class="string">"a==1"</span>)</span><br><span class="line"><span class="keyword">case</span> a == <span class="number">2</span>:</span><br><span class="line">	fmt.Println(<span class="string">"a==2"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">"None"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳转语句goto-break-continue"><a href="#跳转语句goto-break-continue" class="headerlink" title="跳转语句goto, break, continue"></a>跳转语句goto, break, continue</h2><p>三个语法都可以配合标签使用</p>
<p>标签名区分大小写，若不使用会造成编译错误</p>
<p><code>break</code>和<code>continue</code>配合标签可以用于多层循环的跳出</p>
<h2 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h2><p>Go的数组是值语义。一个数组变量表示整个数组，它不是指向第一个元素的指针（不像 C 语言的数组）。 当一个数组变量被赋值或者被传递的时候，实际上会复制整个数组。（为了避免复制数组，你可以传递一个指向数组的指针，但是数组指针并不是数组，却依然可以直接使用索引访问。）</p>
<p>定义数组的格式：<code>var &lt;varName&gt; [n]&lt;type&gt;, n&gt; = 0</code></p>
<p>数组的长度也是类型的一部分，因此具有不同长度的数组为不同类型</p>
<p>数组在Go中为值类型，不同于java中的引用类型</p>
<p>数组之间可以进行<code>==</code>或者<code>!=</code>进行比较，但是不可以比大小</p>
<p>Go支持多维数组</p>
<p>使用<code>new</code>来创建数组，返回一个指向数组的指针。</p>
<p>不论是数组本身还是一个指向数组的指针都可以通过<code>[ ]</code>运算符来进行读取某个位置的元素</p>
<blockquote>
<p>静态初始化</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// [1, 2]</span></span><br><span class="line">a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;    <span class="comment">// [1, 0]</span></span><br><span class="line">a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">5</span>&#125;  <span class="comment">// [0, 5]</span></span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;   <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>&#125;  <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>多维数组</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := [<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切片Slice"><a href="#切片Slice" class="headerlink" title="切片Slice"></a>切片Slice</h2><p><img src="2018-01-11_10-13-16.png" alt="slice本质"></p>
<p>本身并不是数组，指向底层的数组</p>
<p>作为变长数组的替代方案，可以关联底层数组的局部或全部</p>
<p>为引用类型</p>
<p>可以直接创建或从底层数组获取生成</p>
<p>使用<code>len()</code>获取元素个数，<code>cap()</code>获取容量</p>
<p>一般使用<code>make()</code>创建</p>
<p>如果多个<code>slice</code>指向相同底层数组，其中一个的值改变会影响全部</p>
<p><code>make([]T, len, cap)</code>，其中<code>cap</code>可以省略，则和<code>len</code>的值相同</p>
<p><code>len</code>表示存数的元素个数，<code>cap</code>表示容量</p>
<p>从Go1.2开始<code>slice</code>支持三个参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">slice = array[<span class="number">2</span>:<span class="number">4</span>:<span class="number">7</span>] <span class="comment">//长度2，容量5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span> <span class="comment">//定义slice</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">6</span>) <span class="comment">//定义slice</span></span><br><span class="line"></span><br><span class="line">a  := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">s3 := a[<span class="number">2</span>:<span class="number">6</span>] <span class="comment">//截取数组，左闭右开 [3, 4, 5, 6], 长度为4，容量为6</span></span><br><span class="line">s4 := a[<span class="number">2</span>:]  <span class="comment">//等价上一种</span></span><br><span class="line">s5 := a[:<span class="number">4</span>]  <span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line">s6 := s4[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//[2, 3] reslice的索引以被索引的切片为基准</span></span><br><span class="line">s7 := a[:]    <span class="comment">//表示0~length</span></span><br><span class="line"></span><br><span class="line">s6 := <span class="built_in">append</span>(s6, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Reslice"><a href="#Reslice" class="headerlink" title="Reslice"></a>Reslice</h3><p><code>reslice</code>时索引以被<code>slice</code>的切片为准</p>
<p>索引不可以超过被<code>slice</code>的切片的容量<code>cap()</code></p>
<p>索引越界不会触发底层数组的重新分配而是引发错误</p>
<h3 id="Append"><a href="#Append" class="headerlink" title="Append"></a>Append</h3><p>可以在<code>slice</code>尾部追加元素</p>
<p>可以将一个<code>slice</code>追加在另一个<code>slice</code>尾部</p>
<p>如果最终长度未超过追加到<code>slice</code>的容量则返回原始<code>slice</code></p>
<p>如果超过追加的<code>slice</code>的容量则将重新分配数组并拷贝原始数据</p>
<h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><blockquote>
<p>用于覆盖目标的部分元素，第一个参数是目标，第二个参数为源，可以指定覆盖哪部分</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">a1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a2 := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(a1, a2)</span><br><span class="line"></span><br><span class="line">fmt.Println(a1) <span class="comment">// [4 5 6]</span></span><br><span class="line"></span><br><span class="line">a3 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a4 := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(a4, a3)</span><br><span class="line"></span><br><span class="line">fmt.Println(a4) <span class="comment">// [1 2 3 7 8 9]</span></span><br><span class="line"></span><br><span class="line">a5 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">a6 := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">copy</span>(a6[<span class="number">4</span>:<span class="number">6</span>], a5[<span class="number">1</span>:<span class="number">3</span>]) <span class="comment">//指定覆盖的位置</span></span><br><span class="line"></span><br><span class="line">fmt.Println(a6) <span class="comment">// [4 5 6 7 2 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="疑问1"><a href="#疑问1" class="headerlink" title="疑问1"></a>疑问1</h3><blockquote>
<p>从数组中截取中间部分的某个切片，得到的切片的容量是如何确定的？</p>
</blockquote>
<h4 id="实验以及结论"><a href="#实验以及结论" class="headerlink" title="实验以及结论"></a>实验以及结论</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">s1 := b[<span class="number">7</span>:<span class="number">9</span>] <span class="comment">//[8 9] 长度：2 容量：3</span></span><br><span class="line">s2 := b[:<span class="number">2</span>]  <span class="comment">//[1 2] 长度：2 容量：10</span></span><br><span class="line">s3 := b[<span class="number">5</span>:]  <span class="comment">//[6 7 8 9 10] 长度：5 容量：5</span></span><br></pre></td></tr></table></figure>
<p>结论：容量都是从切片开始索引处到原数组的末尾</p>
<h3 id="疑问2"><a href="#疑问2" class="headerlink" title="疑问2"></a>疑问2</h3><blockquote>
<p>从数组中截取中间部分的某个切片，如果在末尾添加元素（不超过切片容量和超过切片容量）则元数组会有什么变化？</p>
</blockquote>
<h4 id="实验以及结论-1"><a href="#实验以及结论-1" class="headerlink" title="实验以及结论"></a>实验以及结论</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">s1 := b[<span class="number">7</span>:<span class="number">9</span>] <span class="comment">//[8 9] 长度：2 容量：3</span></span><br><span class="line">fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">11</span>) <span class="comment">//[8 9 11] 长度：3 容量：3</span></span><br><span class="line">fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">fmt.Println(b) <span class="comment">//未超过切片容量时添加元素，[1 2 3 4 5 6 7 8 9 11]</span></span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">12</span>) <span class="comment">//超过切片容量时添加元素，[1 2 3 4 5 6 7 8 9 11]</span></span><br></pre></td></tr></table></figure>
<p>结论：</p>
<p>切片在添加元素后不超过其容量的情况下，将会修改底层原数组元素，且添加进去的元素值将会替换底层原数组对应位置的值。</p>
<p>当切片添加元素后超过其容量的情况下，将不会修改底层原数组的元素。</p>
<p>注意在长度为2，容量为3的情况下，分两次添加，一次添加一个，第一次添加将会修改原数组；而一次性添加两个元素则不会修改。</p>
<h3 id="疑问3"><a href="#疑问3" class="headerlink" title="疑问3"></a>疑问3</h3><blockquote>
<p><code>reslice</code>后的容量如何确定？</p>
</blockquote>
<h4 id="实验以及结论-2"><a href="#实验以及结论-2" class="headerlink" title="实验以及结论"></a>实验以及结论</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line">s3 := b[<span class="number">5</span>:] 	<span class="comment">//[6 7 8 9 10] 长度：5 容量：5</span></span><br><span class="line"></span><br><span class="line">s4 := s3[<span class="number">2</span>:<span class="number">4</span>]  	<span class="comment">//[8 9] 长度：2 容量：3</span></span><br><span class="line">s5 := s3[:<span class="number">4</span>]   	<span class="comment">//[6 7 8 9] 长度：4 容量：5</span></span><br><span class="line">s6 := s3[<span class="number">2</span>:]   	<span class="comment">//[8 9 10] 长度：3 容量：3</span></span><br></pre></td></tr></table></figure>
<p>结论：根据原切片来定</p>
<h3 id="疑问4"><a href="#疑问4" class="headerlink" title="疑问4"></a>疑问4</h3><blockquote>
<p>既然说<code>silce</code>是引用类型，那么在函数中向<code>slice</code>添加元素（没有发生扩容的情况下）为什么在外部不会影响？代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">package</span> main</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="keyword">import</span> (</span><br><span class="line">&gt; 	<span class="string">"fmt"</span></span><br><span class="line">&gt; )</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&gt; 	s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br><span class="line">&gt; <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&gt; 	s := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">&gt; 	</span><br><span class="line">&gt; 	Add(s)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 	fmt.Println(s) <span class="comment">//输出[0, 0, 0]</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>结论：</p>
<p>其实<code>slice</code>是一个“伪引用类型”，其定义为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">	array *internalArray </span><br><span class="line">	<span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以当将<code>slice</code>作为参数传入函数的时候，应该是值拷贝，但是内部指针指向的数组还是没变，之后通过<code>append</code>向底层数组中成功添加元素（假设此时没有发生扩容），此时注意虽然内部数组发生了改变，但是<strong><code>len</code>字段修改的是副本，并不会影响外部实际的切片变量</strong>。</p>
<p><strong>验证代码：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   s = <span class="built_in">append</span>(s, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   s := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">   Add(s)</span><br><span class="line">   fmt.Println(s) </span><br><span class="line">   <span class="comment">//强制输出底层数组的内容</span></span><br><span class="line">   fmt.Println(s[:<span class="built_in">cap</span>(s)]) <span class="comment">//输出[0 0 0 1 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m:=<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>:<span class="string">"a"</span>, <span class="number">2</span>:<span class="string">"b"</span>&#125; <span class="comment">//静态初始化</span></span><br><span class="line">m:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">4</span>) <span class="comment">//动态初始化</span></span><br></pre></td></tr></table></figure>
<p>类似其他语言中的哈希表或字典</p>
<p>线程不安全</p>
<p>删除元素：<code>delete(m, key)</code></p>
<p>通过双赋值检测某个键存在：<code>elem, ok = m[key]</code></p>
<p>key必须支持==或!=比较运算的类型，不可以是函数、map或slice</p>
<p>Map查找比线性搜索快很多，但是比使用索引访问数据的类型慢100倍</p>
<p>Map使用<code>make()</code>创建，支持<code>:=</code>这种简写方式</p>
<p><code>make([keyType]valueType, cap)</code>，<code>cap</code>表示容量，可省略</p>
<p>超出容量时会自动扩容，但尽量提供一个合理的初始值</p>
<p>使用<code>len()</code>获取元素个数</p>
<p>键值对不存在的时候自动添加，使用<code>delete()</code>删除某键值对</p>
<p>使用<code>for range</code>对<code>map</code>和<code>slice</code>进行迭代操作，其中的两个迭代变量都只是一个副本，修改它不会影响原容器，如果需要影响则需要通过索引(key)，如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> myMap&#123; &#125; <span class="comment">//key 和 value</span></span><br><span class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> mySlice&#123; &#125; <span class="comment">//index 和 value</span></span><br></pre></td></tr></table></figure>
<h2 id="函数function"><a href="#函数function" class="headerlink" title="函数function"></a>函数function</h2><p>Go函数不支持嵌套、重载和默认参数</p>
<p>但支持：</p>
<ul>
<li>无需声明原型</li>
<li>不定长度变参<code>func f(a ...int) {}</code></li>
<li>多返回值</li>
<li>命名返回值参数</li>
<li>匿名函数</li>
<li>闭包，和js一样，支持高阶函数</li>
</ul>
<p>定义函数使用关键字<code>func</code>，且做大括号不能另起一行</p>
<p>函数也可以作为一中类型使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收参数a,b,c均为int型，可以省略部分类型声明</span></span><br><span class="line"><span class="comment">//命名返回值参数d,e则不需要显示的返回d,e</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">(a, b, c <span class="keyword">int</span>)</span> <span class="params">(d, e <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p><a href="https://blog.go-zh.org/defer-panic-and-recover" target="_blank" rel="noopener">参考博文</a></p>
<p>延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。</p>
<p>defer 语句会延迟函数的执行直到上层函数返回。</p>
<p>延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。</p>
<p>即使函数发生严重错误也会执行</p>
<p>支持匿名函数的调用</p>
<p>常用于资源的清理、文件关闭、解锁以及记录时间的等操作</p>
<p>通过与匿名函数配合可在<code>return</code>之后修改函数计算结果，利用闭包或者通过指针</p>
<p>如果函数体内某个变量作为<code>defer</code>是匿名函数的参数，则在定义defer时即以及获取了拷贝，否则则是引用某个变量的地址</p>
<p><code>go</code>没有异常机制，但有<code>panic/recover</code>模式来处理错误</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 使用defer来恢复错误返回值</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">"recover"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"panic in A"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>panic</code>可以在任何地方引发，但<code>recover</code>只有在<code>defer</code>调用的函数中有效</p>
<h2 id="结构struct"><a href="#结构struct" class="headerlink" title="结构struct"></a>结构struct</h2><p><code>go</code>中的<code>struct</code>与C中的非常类似，并且<code>go</code>中没有<code>class</code></p>
<p>使用<code>type &lt;name&gt; struct {}</code>定义结构，名称遵循可见性规则</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">p := &amp;person&#123; <span class="comment">//在创建时直接取地址</span></span><br><span class="line">  <span class="string">"TomKK"</span>,</span><br><span class="line">  <span class="number">20</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为函数参数时为值拷贝，如果需要修改外部的实参，可以通过指针</p>
<p>支持匿名结构体作为字段，但是这种结构初始化的时候不能使用字面值直接初始化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age <span class="keyword">int</span></span><br><span class="line">	Contact <span class="keyword">struct</span>&#123;</span><br><span class="line">		tel <span class="keyword">string</span></span><br><span class="line">		addr <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := person&#123;</span><br><span class="line">  Name:<span class="string">"TomKK"</span>,</span><br><span class="line">  Age:<span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line">a.Contact.addr = <span class="string">"中国"</span></span><br><span class="line">a.Contact.tel = <span class="string">"110"</span></span><br></pre></td></tr></table></figure>
<p>支持指向自身的指针类型成员</p>
<p>支持匿名结构，可用作成员或定义成员变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a := &amp;<span class="keyword">struct</span> &#123; <span class="comment">//匿名结构</span></span><br><span class="line">  Age <span class="keyword">int</span></span><br><span class="line">  Name <span class="keyword">string</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">  <span class="number">20</span>,</span><br><span class="line">  <span class="string">"Tomkk"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名结构也可以用于<code>map</code>的值</p>
<p>可以使用字面值对结构进行初始化</p>
<p>允许直接通过指针来读写结构成员，不需要解引用后再访问</p>
<p>相同类型的成员可以进行拷贝赋值</p>
<p>支持<code>==</code>与<code>!=</code>比较运算符，但不支持<code>&gt;</code>或<code>&lt;</code></p>
<p>支持匿名字段，本质上是定义了以某个类型名为名称的字段</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">   <span class="keyword">string</span></span><br><span class="line">   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := person&#123;</span><br><span class="line">   <span class="string">"TomKK"</span>,</span><br><span class="line">   <span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(a.<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>嵌入结构作为匿名字段看起来像继承，但不是继承可以使用匿名字段指针</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	human</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">	Contact <span class="keyword">struct</span> &#123;</span><br><span class="line">		tel  <span class="keyword">string</span></span><br><span class="line">		addr <span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := person&#123;</span><br><span class="line">    Name:  <span class="string">"TomKK"</span>,</span><br><span class="line">    Age:   <span class="number">22</span>,</span><br><span class="line">    human: human&#123;Gender: <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">a.Contact.addr = <span class="string">"中国"</span></span><br><span class="line">a.Contact.tel = <span class="string">"110"</span></span><br><span class="line"><span class="comment">//在嵌入的类名称不冲突的情况下，可以直接 对象.属性来访问嵌入的结构的属性，如果有名称相同的情况下，则使用 父结构.子结构.属性 的方式调用</span></span><br></pre></td></tr></table></figure>
<h2 id="方法method"><a href="#方法method" class="headerlink" title="方法method"></a>方法method</h2><p>通过显式说明<code>receiver</code>来实现与某个类型的组合</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver *person)</span> <span class="title">Print</span><span class="params">()</span></span>&#123; <span class="comment">//将Print绑定到person结构上</span></span><br><span class="line">   fmt.Println(receiver.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过相同包内的类型别名可以将任意类型绑定</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> INT <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver INT)</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"INT"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能为同一个包内的类型定义方法</p>
<p><code>receiver</code>可以是类型的值或者指针，而且</p>
<blockquote>
<p>如果一个method的receiver是*T,你可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method。即实例变量调用指针方法不需要取地址。</p>
<p>如果一个method的receiver是T，你可以在一个<em>T类型的变量P上面调用这个method，而不需要 </em>P去调用这个method。即指针变量调用实例方法不需要解引用。</p>
<p>即指针拥有所有的method，但是变量只拥有receiver为变量的method</p>
</blockquote>
<p>不存在方法重载</p>
<p>可以使用值或指针来调用方法，编译器会自动完成转换</p>
<p>从某种意义上来说，方法是函数的语法糖，因为<code>receiver</code>其实就是方法所接收的第一个参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i INT</span><br><span class="line">i.Print() <span class="comment">//method value</span></span><br><span class="line">(*INT).Print(&amp;i) <span class="comment">//method expression</span></span><br></pre></td></tr></table></figure>
<p>如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法</p>
<p>类型别名不会拥有底层类型所附带的方法</p>
<p>方法可以调用结构中的非公开字段，访问权限是包级别的，即私有意味着只有本包可以访问。</p>
<h2 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h2><p>接口是一个或多个方法签名的集合</p>
<p>只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显式声明实现了哪个接口，这称为<code>structural typing</code></p>
<p>接口只有方法声明，没有实现，没有数据字段</p>
<p>接口可以匿名嵌入其他接口，或嵌入到接口中</p>
<p>将对象复制给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针。即发生多态赋值之时是值传递，修改原值无法影响接口。</p>
<p>只有当接口存储的类型和对象都为<code>nil</code>时，接口才等于<code>nil</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line">a = p</span><br><span class="line">fmt.Println(a == <span class="literal">nil</span>)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>接口调用不会做<code>receiver</code>的自动转换。在进行类似“多态”的赋值操作时，编译器会检查实现类的实现方式中采用的<code>receiver</code>，只要有一个实现方法采用了<code>指针receiver</code>，那么多态赋值的时候就必须采用指针的形式。如果均没有采用<code>指针receiver</code>，那么可以既可以使用指针也可以使用对象。如果声明的<code>receiver</code>不是指针，那么就算以指针赋值接口也无法在方法内部修改变量的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">	connect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PhoneConnector <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone *PhoneConnector)</span> <span class="title">connect</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(phone.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  	<span class="comment">//这里定义了一个对象</span></span><br><span class="line">	<span class="keyword">var</span> phone = PhoneConnector&#123;<span class="string">"TomKK"</span>&#125;</span><br><span class="line">  	<span class="comment">//尽管方法中声明的是接收指针receiver，但是这里进行了自动转换</span></span><br><span class="line">	phone.connect()</span><br><span class="line">	<span class="keyword">var</span> usb USB</span><br><span class="line">  	<span class="comment">//这里就不能直接 usb = phone 了，因为接口不会做receiver自动转换</span></span><br><span class="line">	usb = &amp;phone</span><br><span class="line">	usb.connect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口同样支持匿名字段方法</p>
<p>接口也可实现类似OOP中的多态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">	connect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PhoneConnector <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(phone PhoneConnector)</span> <span class="title">connect</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">"PhoneConnector"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> usb USB</span><br><span class="line">	usb = PhoneConnector&#123;&#125;</span><br><span class="line">	usb.connect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>空接口可以作为任何类型数据的容器</p>
<p><code>Type Assertion（Comma-ok断言）</code>语法：value, ok := element.(T)。element必须是接口类型的变量，T是普通类型。如果断言失败，ok为false，否则ok为true并且value为变量的值。</p>
<p><code>Type switch</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">case</span> []<span class="keyword">byte</span>:</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Printf(<span class="string">"unknown type\n"</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射reflection"><a href="#反射reflection" class="headerlink" title="反射reflection"></a>反射reflection</h2><p>反射可以大大提高程序的灵活性，使得<code>interface{}</code>有更大的发挥余地</p>
<p>反射使用<code>TypeOf</code>和<code>ValueOf</code>函数从接口中获取目标对象信息</p>
<p>反射会将匿名字段作为独立字段（匿名字段本质）</p>
<p>想要利用反射修改对象状态，前提是<code>interface.data</code>是<code>settable</code>，即<code>pointer-interface</code></p>
<p>通过反射可以“动态”调用方</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name     <span class="keyword">string</span></span><br><span class="line">	Password <span class="keyword">string</span></span><br><span class="line">	Id       <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this User)</span> <span class="title">Hello</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"hello,"</span>, name, <span class="string">" I'm "</span>, this.Name)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(i)</span><br><span class="line">	fmt.Println(<span class="string">"Type name:"</span>, t.Name())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> k := t.Kind(); k != reflect.Struct &#123;</span><br><span class="line">		fmt.Println(<span class="string">"The input type is not struct"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(i)</span><br><span class="line">	fmt.Println(<span class="string">"Fields:"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		f := t.Field(i)</span><br><span class="line">		value := v.Field(i).Interface()</span><br><span class="line">		fmt.Printf(<span class="string">"%-10s: %v = %v\n"</span>, f.Name, f.Type, value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"Methods:"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ &#123;</span><br><span class="line">		m := t.Method(i)</span><br><span class="line">		fmt.Printf(<span class="string">"%-10s: %v \n"</span>, m.Name, m.Type)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m := v.MethodByName(<span class="string">"Hello"</span>)</span><br><span class="line">	args := []reflect.Value&#123;reflect.ValueOf(<span class="string">"James"</span>)&#125;</span><br><span class="line">	result := m.Call(args)</span><br><span class="line">	fmt.Println(<span class="string">"result :"</span>, result[<span class="number">0</span>].Interface())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发Concurrency"><a href="#并发Concurrency" class="headerlink" title="并发Concurrency"></a>并发Concurrency</h2><blockquote>
<p><code>goroutine</code>只是由官方实现的超级“线程池”而已。每个实例4-5KB的栈内存占用和由于实现机制而大幅减少的创建和销毁开销，是制造Go号称的高并发的根本原因。另外<code>goroutine</code>的简单易用，也在语言层面上给予了开发者巨大的便利。</p>
<p><code>goroutine</code>奉行通过通信来共享内存，而不是共享内存来通信。</p>
</blockquote>
<h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p><code>Channel</code>是<code>goroutine</code>沟通的桥梁，通道的发送/接收操作在对方准备好之前是阻塞的</p>
<p>通过<code>make</code>创建，<code>close</code>关闭</p>
<p><code>Channel</code>是引用类型</p>
<p>发送者可以 <code>close</code> 一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：当没有值可以接收并且 <code>channel</code>已经被关闭，那么经过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>
<p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p>
<p>可以使用<code>for range</code>来迭代不断操作<code>channel</code>，直到显式调用<code>close</code>关闭通道</p>
<p>可以设置单向或双向通道</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> send_only <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>        <span class="comment">// channel can only send data</span></span><br><span class="line"><span class="keyword">var</span> recv_only &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>        <span class="comment">// channel can only receive data</span></span><br></pre></td></tr></table></figure>
<p>可以设置缓存大小，在未被填满前不会发生阻塞，变为异步，元素会按照发送的顺序被接收，即：在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> u:= &lt;- ch1:</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">case</span> v:= &lt;- ch2:</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// no value ready to be received</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可处理一个或多个<code>channel</code>的发送与接收</p>
<p><code>default</code>语句可选。</p>
<p>没有<code>fallthrough</code>行为。</p>
<ul>
<li>如果都阻塞了，会等待直到其中一个可以处理</li>
<li>如果多个可以处理，随机选择一个</li>
<li>如果没有通道操作可以处理并且写了 <code>default</code> 语句，它就会执行：<code>default</code> 永远是可运行的（这就是准备好了，可以执行）</li>
<li>如果没有 case，select 就会一直阻塞</li>
</ul>
<p>在任何一个case中执行<code>break</code>或者<code>return</code>将会终止整个<code>select</code></p>
<p>可以设置超时，比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> resp := &lt;-ch</span><br><span class="line">    <span class="comment">// use resp and reply</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeoutNs):</span><br><span class="line">    <span class="comment">// call timed out</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="疑问1-1"><a href="#疑问1-1" class="headerlink" title="疑问1"></a>疑问1</h4><blockquote>
<p>管道设了缓存之后，有什么区别？</p>
</blockquote>
<p>向带缓存的<code>channel</code>中发送数据的时候，只有在缓冲区满的时候写者才会阻塞。而当缓冲区的为空的时候，读者才会阻塞。联想到了《计算机网络》里面的“滑动窗口协议”，窗口值（缓冲区）为1的时候，能够保证数据流的有序性，当窗口值（缓冲区）大于1时，就变成了异步操作，吞吐量会增加</p>
<h4 id="疑问2-1"><a href="#疑问2-1" class="headerlink" title="疑问2"></a>疑问2</h4><blockquote>
<p>select有什么用？机制是什么样的？</p>
</blockquote>
<p><code>select</code> 语句使得一个 <code>goroutine</code> 在多个通讯操作上等待。</p>
<p><code>select</code> 会阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x: <span class="comment">//写入后等待读取</span></span><br><span class="line">			x, y = y, x+y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c) <span class="comment">//不断读取</span></span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="疑问3-1"><a href="#疑问3-1" class="headerlink" title="疑问3"></a>疑问3</h4><blockquote>
<p>不设置缓冲的channel和设置缓冲为1的channel有区别么？</p>
</blockquote>
<p>有区别，区别在于向放入第一个元素之后，不设置缓冲的channel将被阻塞无法继续进行，而设置缓冲为1的channel将可以继续执行剩下的操作，直到试图将channel中的元素扩增为2时，会发生阻塞</p>
<h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><blockquote>
<p>提供了一些基本的同步原语，用于并发控制</p>
<p>参考链接：<a href="http://www.cnblogs.com/golove/p/5918082.html" target="_blank" rel="noopener">http://www.cnblogs.com/golove/p/5918082.html</a></p>
</blockquote>
<p><code>sync.Once</code>：实现多次调用一次执行。只有第一次调用才会执行，之后如果要再次执行需要重新创建一个新的对象</p>
<p><code>sync.WaitGroup</code>：直到所有注册的并发任务都执行结束了，才继续执行。通过<code>sync.Add(n)</code>来增加计数器的值，通过<code>sync.Done()</code>将计数器的值减一</p>
<p><code>sync.Mutex</code>：信号量。提供<code>Lock</code>和<code>Unlock</code>两个方法，分别对应加锁和解锁。可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁</p>
<p><code>sync.RWMutex</code>：读写锁。在互斥锁的基础上，还能够提供写锁定，但是不锁定读的功能</p>
<p><code>sync.Cond</code>：条件等待。通过<code>Wait</code>让协程等待，通过<code>Signal</code>让一个等待的协程恢复，通过<code>Broadcast</code>让所有等待的协程恢复</p>
<h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><ul>
<li><p><code>Goexit</code></p>
<p>退出当前执行的goroutine，但是<code>defer</code>函数还会继续调用</p>
</li>
<li><p><code>Gosched</code></p>
<p>让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
</li>
<li><p><code>NumCPU</code></p>
<p>返回 CPU 核数量</p>
</li>
<li><p><code>NumGoroutine</code></p>
<p>返回正在执行和排队的任务总数</p>
</li>
<li><p><code>GOMAXPROCS</code></p>
<p>用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
</li>
</ul>
<h2 id="一些容易出错的地方"><a href="#一些容易出错的地方" class="headerlink" title="一些容易出错的地方"></a>一些容易出错的地方</h2><h3 id="slice自动扩容导致指针值改变"><a href="#slice自动扩容导致指针值改变" class="headerlink" title="slice自动扩容导致指针值改变"></a>slice自动扩容导致指针值改变</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAppend</span><span class="params">(s []<span class="keyword">int</span>, v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	myAppend(s, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(s) <span class="comment">//输出 []</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为<code>slice</code>是引用类型，所以本以为在函数内修改其的值后，也会导致外部改变，但是最终输出确为空。这是因为在函数内<code>append</code>过程中导致了<code>slice</code>的重新分配底层的数组，这会导致<code>内部的s</code>的指向改变，而外部不受影响。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>创建的时候就估计容量，避免在函数内发生扩容</li>
<li>需要向<code>slice</code>中添加元素的函数每次调用返回切片的引用更新外部切片变量</li>
<li>传入切片的指针</li>
</ol>
<h3 id="使用部分slice导致内部使用的数组一直无法释放"><a href="#使用部分slice导致内部使用的数组一直无法释放" class="headerlink" title="使用部分slice导致内部使用的数组一直无法释放"></a>使用部分slice导致内部使用的数组一直无法释放</h3><p>整个数组将被保存在内存中，直到它不再被引用。 有时候可能会因为一个小的内存引用导致保存所有的数据。</p>
<p>例如， <code>FindDigits</code> 函数加载整个文件到内存，然后搜索第一个连续的数字，最后结果以切片方式返回。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> digitRegexp = regexp.MustCompile(<span class="string">"[0-9]+"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">   <span class="comment">// 一直不会被释放</span></span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">return</span> digitRegexp.Find(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的行为和描述类似，返回的 <code>[]byte</code> 指向保存整个文件的数组。因为切片引用了原始的数组， 导致 GC 不能释放数组的空间；只用到少数几个字节却导致整个文件的内容都一直保存在内存里。</p>
<p>要修复整个问题，可以将感兴趣的数据复制到一个新的切片中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyDigits</span><span class="params">(filename <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    b, _ := ioutil.ReadFile(filename)</span><br><span class="line">    b = digitRegexp.Find(b)</span><br><span class="line">    c := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(b))</span><br><span class="line">    <span class="built_in">copy</span>(c, b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Go语言中没有真正的引用类型"><a href="#Go语言中没有真正的引用类型" class="headerlink" title="Go语言中没有真正的引用类型"></a>Go语言中没有真正的引用类型</h3><p>号称引用类型的<code>slice</code>，<code>map</code>，<code>channel</code>其实都是一个指针的包装类。</p>
<p>所以像用<code>type struct</code>关键字定义的一些类型，如果进行参数传递，并且需要能够将修改在外部体现的时候，应该传递指针。比如<code>sync.WaitGroup</code>、<code>slice</code>变量。</p>
<h3 id="引用别的包"><a href="#引用别的包" class="headerlink" title="引用别的包"></a>引用别的包</h3><p>总是忘记加上包前缀</p>
<h3 id="使用goroutine时"><a href="#使用goroutine时" class="headerlink" title="使用goroutine时"></a>使用goroutine时</h3><p>注意传递的<code>sync.WaitGroup</code>变量应该是指针。</p>
<p>加锁之后一定要解锁，中间不能包含可能的<code>return</code>分支。</p>
<h1 id="Go-tour爬虫习题"><a href="#Go-tour爬虫习题" class="headerlink" title="Go tour爬虫习题"></a>Go tour爬虫习题</h1><p>题目地址：<a href="https://tour.go-zh.org/concurrency/10" target="_blank" rel="noopener">https://tour.go-zh.org/concurrency/10</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Record <span class="keyword">struct</span> &#123;</span><br><span class="line">   stored <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">   mux    sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> record Record</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。</span></span><br><span class="line">   Fetch(url <span class="keyword">string</span>) (body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">   result := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">   wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">   wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> crawl(url, depth, fetcher, result, &amp;wg)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      wg.Wait()</span><br><span class="line">      <span class="built_in">close</span>(result)</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> s := <span class="keyword">range</span> result &#123;</span><br><span class="line">      fmt.Println(s)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher, result <span class="keyword">chan</span> <span class="keyword">string</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//防止并发下，多个线程同时检测到某个url未爬取</span></span><br><span class="line">   record.mux.Lock()</span><br><span class="line">   <span class="keyword">if</span> _, exists := record.stored[url]; exists &#123;</span><br><span class="line">      record.mux.Unlock()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   record.mux.Unlock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   body, urls, err := fetcher.Fetch(url)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      result &lt;- fmt.Sprintf(<span class="string">"not found: %s"</span>, url)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   record.stored[url] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">   result &lt;- fmt.Sprintf(<span class="string">"found: %s %q"</span>, url, body)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">      wg.Add(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">go</span> crawl(u, depth<span class="number">-1</span>, fetcher, result, wg)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   record.stored = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line">   record.mux = sync.Mutex&#123;&#125;</span><br><span class="line">   Crawl(<span class="string">"http://golang.org/"</span>, <span class="number">4</span>, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher 是返回若干结果的 Fetcher。</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">   body <span class="keyword">string</span></span><br><span class="line">   urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span> <span class="title">Fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">      <span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher 是填充后的 fakeFetcher。</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line">   <span class="string">"http://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line">      <span class="string">"The Go Programming Language"</span>,</span><br><span class="line">      []<span class="keyword">string</span>&#123;</span><br><span class="line">         <span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">         <span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"http://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line">      <span class="string">"Packages"</span>,</span><br><span class="line">      []<span class="keyword">string</span>&#123;</span><br><span class="line">         <span class="string">"http://golang.org/"</span>,</span><br><span class="line">         <span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line">         <span class="string">"http://golang.org/pkg/fmt/"</span>,</span><br><span class="line">         <span class="string">"http://golang.org/pkg/os/"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"http://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line">      <span class="string">"Package fmt"</span>,</span><br><span class="line">      []<span class="keyword">string</span>&#123;</span><br><span class="line">         <span class="string">"http://golang.org/"</span>,</span><br><span class="line">         <span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"http://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line">      <span class="string">"Package os"</span>,</span><br><span class="line">      []<span class="keyword">string</span>&#123;</span><br><span class="line">         <span class="string">"http://golang.org/"</span>,</span><br><span class="line">         <span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于go-generate"><a href="#关于go-generate" class="headerlink" title="关于go generate"></a>关于go generate</h1><p><a href="http://www.cnblogs.com/majianguo/p/6653919.html" target="_blank" rel="noopener">参考博文</a></p>
<h1 id="Go程序初始化过程"><a href="#Go程序初始化过程" class="headerlink" title="Go程序初始化过程"></a>Go程序初始化过程</h1><p>程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对<code>main</code>包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话），最后执行<code>main</code>函数。</p>
<p><img src="https://github.com/astaxie/build-web-application-with-golang/raw/master/zh/images/2.3.init.png?raw=true" alt="main函数引入包初始化流程"></p>
<h1 id="Go反射机制剖析"><a href="#Go反射机制剖析" class="headerlink" title="Go反射机制剖析"></a>Go反射机制剖析</h1><p><a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener">参考博文</a></p>
<p>go语言中接口变量的实现机制为，内部保存了一对值（接口变量实际存放的那个原始变量，前者的类型描述），正是基于此机制，才能使用<code>type assertion</code>来对接口变量进行向下转型的判断类型。</p>
<h2 id="反射的第一个法则：interface-—-gt-reflect-Value"><a href="#反射的第一个法则：interface-—-gt-reflect-Value" class="headerlink" title="反射的第一个法则：interface{}—&gt; reflect.Value"></a>反射的第一个法则：<code>interface{}</code>—&gt; <code>reflect.Value</code></h2><p>首先，需要知道<code>reflect</code>包中的两个类型：<code>Type</code>和<code>Value</code>，通过这两个类型来访问接口值。然后还有两个方法<code>reflect.TypeOf</code>和<code>reflect.ValueOf</code>，以此从接口变量中获取<code>Type</code>和<code>Value</code>值，其实如果获得了<code>Value</code>值，就可以通过它来获得<code>Type</code>值</p>
<p><code>Type</code>和<code>Value</code>都有一个<code>Kind()</code>方法，返回一个表示类型的常量。</p>
<p><code>Value</code>有一个<code>Type()</code>方法，返回<code>Value</code>变量的类型</p>
<p><code>Value</code>有类型<code>Uint</code>, <code>Float64</code>, <code>Slice</code>等的方法，返回其内部存储的值</p>
<p>反射库中的<code>Value</code>变量的<code>getter</code>和<code>setter</code>方法使用的是同类型变量中值域最大的那种，如对于所有的有符号整数采用的是<code>Int64</code>，所以<code>Int()</code>方法返回的值的类型也是<code>Int64</code>，所以有时可能需要做一下强制类型转换。</p>
<p><code>Kind()</code>作用于自定义类型的时候，返回的是真实的被包装的类型，而不是类型”别名”，但是<code>Type</code>返回的是”别名”</p>
<h2 id="反射的第二个法则：-reflect-Value-—-gt-interface"><a href="#反射的第二个法则：-reflect-Value-—-gt-interface" class="headerlink" title="反射的第二个法则： reflect.Value —&gt;interface{}"></a>反射的第二个法则： <code>reflect.Value</code> —&gt;<code>interface{}</code></h2><p>可以使用<code>Interface()</code>方法收集类型和值的信息，将一个<code>Refect.Value</code>恢复为其原始值。其方法签名为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的是一个空接口类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>所以有时需要进行<code>type assertion</code>针对于<code>fmt</code>包中的方法，无需进行显式转换，因为其内部代我们进行了转换。</p>
<p>总而言之：<code>Interface()</code>是<code>ValueOf()</code>的逆方法，值在<code>interface{}</code>和<code>reflect.Value</code>在之间转换。</p>
<h2 id="反射的第三个法则：如果要修改反射对象的值，那么要求值为settable的"><a href="#反射的第三个法则：如果要修改反射对象的值，那么要求值为settable的" class="headerlink" title="反射的第三个法则：如果要修改反射对象的值，那么要求值为settable的"></a>反射的第三个法则：如果要修改反射对象的值，那么要求值为<code>settable</code>的</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure>
<p>以上代码会报错<code>panic: reflect.Value.SetFloat using unaddressable value</code>，这是因为变量<code>v</code>是非<code>settable</code>的。并不是所有的反射对象都是<code>settable</code></p>
<p><code>CanSet()</code>方法返回一个变量的<code>settability</code>。</p>
<blockquote>
<p><strong>什么是<code>settability</code>呢？</strong></p>
<p>Settability is a bit like addressability, but stricter. It’s the property that a reflection object can modify the actual storage that was used to create the reflection object. Settability is determined by whether the reflection object holds the original item.</p>
</blockquote>
<p>即反射对象是否能够修改原始变量的值，而不是原始变量的拷贝。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">"type of p:"</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">"settability of p:"</span>, p.CanSet())</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//type of p: *float64</span></span><br><span class="line"><span class="comment">//settability of p: false</span></span><br></pre></td></tr></table></figure>
<p>依旧无法修改，这是因为这里反应的是指针p的<code>settability</code>而不是p所指向的那个真实对象的<code>settability</code>。为了得到指针p所指向的对象，通过<code>Elem()</code>方法，其返回值的<code>settability</code>就是为true的了。</p>
<p>另外，需要指出的是只有导出的字段才可以被修改，即首字母大写的。</p>
<p>这里涉及的反射的应用还很少，反射还可以用于管道的发送和接收，分配内存，使用切片和map，调用方法和函数等。</p>
<h1 id="Web编程"><a href="#Web编程" class="headerlink" title="Web编程"></a>Web编程</h1><h2 id="路由注册的内部实现"><a href="#路由注册的内部实现" class="headerlink" title="路由注册的内部实现"></a>路由注册的内部实现</h2><p><strong>一个简单的web程序如下</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"net/http"</span></span><br><span class="line">   <span class="string">"strings"</span></span><br><span class="line">   <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   r.ParseForm()  <span class="comment">//解析参数，默认是不会解析的</span></span><br><span class="line">   fmt.Println(r.Form)  <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">   fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">   fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">   fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">      fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">      fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">" "</span>))</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Fprintf(w, <span class="string">"Hello astaxie!"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   http.HandleFunc(<span class="string">"/"</span>, sayhelloName) <span class="comment">//设置访问的路由</span></span><br><span class="line">   err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>sayhelloName</code>为一个<code>Handler</code>，通过路由将对应的url映射到相应注册的<code>Handler</code>上，服务器内部定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu sync.RWMutex   <span class="comment">//锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class="line">	m  <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry  <span class="comment">// 路由规则，一个string对应一个mux实体，这里的string就是注册的路由表达式</span></span><br><span class="line">	hosts <span class="keyword">bool</span> <span class="comment">// 是否在任意的规则中带有host信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由规则中的<code>muxEntry</code>定义为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	explicit <span class="keyword">bool</span>   <span class="comment">// 是否精确匹配</span></span><br><span class="line">	h        Handler <span class="comment">// 这个路由表达式对应哪个handler</span></span><br><span class="line">	pattern  <span class="keyword">string</span>  <span class="comment">//匹配字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到服务器内部是以<code>Handler</code>这个类型来存储处理函数的，而其是一个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)  <span class="comment">// 路由实现器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即只有实现了<code>ServeHTTP(ResponseWriter, *Request)</code>的类型才可以被服务器存储为处理函数，而我们写的<code>func sayhelloName(w http.ResponseWriter, r *http.Request)</code>并没有实现这个方法，所以我们需要为其添加<code>ServeHTTP</code>，因为go语言可以为任何类型添加方法（自认为这里采用了适配器模式），先将这两个函数（<code>ServeHTTP</code>、<code>sayhelloName</code>）的共性提取——将形如<code>func(ResponseWriter, *Request)</code>的函数定义为一个新类型<code>HandlerFunc</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br></pre></td></tr></table></figure>
<p>这样就可以将<code>func sayhelloName(w http.ResponseWriter, r *http.Request)</code>强制转换成<code>HandlerFunc</code>类型，然后为<code>HandlerFunc</code>添加<code>ServeHTTP</code>方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP calls f(w, r).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只要是形如<code>func xxx(w http.ResponseWriter, r *http.Request)</code>的函数都可以被存储为处理器</p>
<h3 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h3><p>在其他面向对象的语言中，实现方式为创建很多实现了<code>Handler</code>接口的类，然后通过多态来传递参数实现面向接口编程的统一美。但是在go语言中同样的效果不一定面向类（struct），go语言中能够做到直接面向函数，省去了创建很多<code>struct</code>的过程，对程序员更加友好。</p>
<h1 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h1><p><a href="http://www.cnblogs.com/golove/p/3262925.html" target="_blank" rel="noopener">strconv库</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/01/08/学习Hue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/08/学习Hue/" class="post-title-link" itemprop="url">学习Hue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-01-08 15:55:38 / Modified: 15:58:54" itemprop="dateCreated datePublished" datetime="2018-01-08T15:55:38+08:00">2018-01-08</time>
            </span>

          
            <span id="/2018/01/08/学习Hue/" class="post-meta-item leancloud_visitors" data-flag-title="学习Hue" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/01/08/学习Hue/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/08/学习Hue/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常用文档"><a href="#常用文档" class="headerlink" title="常用文档"></a>常用文档</h1><blockquote>
<ol>
<li><a href="http://gethue.com" target="_blank" rel="noopener">http://gethue.com</a></li>
<li><a href="https://github.com/cloudera/hue" target="_blank" rel="noopener">https://github.com/cloudera/hue</a></li>
<li><a href="https://archive.cloudera.com/cdh5/cdh/5/hue-3.9.0-cdh5.13.1/" target="_blank" rel="noopener">https://archive.cloudera.com/cdh5/cdh/5/hue-3.9.0-cdh5.13.1/</a></li>
</ol>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/01/08/java设计模式——Iterator模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/08/java设计模式——Iterator模式/" class="post-title-link" itemprop="url">java设计模式——Iterator模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-01-08 11:25:13 / Modified: 14:51:47" itemprop="dateCreated datePublished" datetime="2018-01-08T11:25:13+08:00">2018-01-08</time>
            </span>

          
            <span id="/2018/01/08/java设计模式——Iterator模式/" class="post-meta-item leancloud_visitors" data-flag-title="java设计模式——Iterator模式" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/01/08/java设计模式——Iterator模式/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/08/java设计模式——Iterator模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><blockquote>
<p>设计一个容器，要求具有统一的api，能够让底层实现不同的容器的操作对用户透明。</p>
</blockquote>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Collection-java"><a href="#Collection-java" class="headerlink" title="Collection.java"></a>Collection.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomkk.dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Iterator-java"><a href="#Iterator-java" class="headerlink" title="Iterator.java"></a>Iterator.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomkk.dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Iterator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 迭代器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: tomkk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018-01-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ArrayList-java"><a href="#ArrayList-java" class="headerlink" title="ArrayList.java"></a>ArrayList.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomkk.dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: ArrayList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 模拟JDK容器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: tomkk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018-01-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] elementData = <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; elementData.length) &#123;</span><br><span class="line">            Object[] newElemDate = <span class="keyword">new</span> Object[size &gt;&gt; <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(elementData, <span class="number">0</span>, newElemDate, <span class="number">0</span>, elementData.length);</span><br><span class="line">            elementData = newElemDate;</span><br><span class="line">        &#125;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cursor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (E) elementData[cursor++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedList-java"><a href="#LinkedList-java" class="headerlink" title="LinkedList.java"></a>LinkedList.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomkk.dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: LinkedList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 模拟JDK容器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: tomkk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2018-01-08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;( e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node.next = <span class="keyword">null</span>;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; node = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;index; i++) &#123;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="comment">//    可以加上单例管理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LinkedListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    非静态内部类自动继承外部类的泛型不用加上泛型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; cursor = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node&lt;E&gt; node = cursor;</span><br><span class="line">            cursor = cursor.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node.item;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cursor!=<span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Main-java"><a href="#Main-java" class="headerlink" title="Main.java"></a>Main.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomkk.dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            collection.add(<span class="string">"user"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(collection.size());</span><br><span class="line">        </span><br><span class="line">        Iterator&lt;String&gt; it = collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>面向接口编程，容器具有相同的对外api</li>
<li><code>Iterator</code>封装了不同底层实现的容器遍历，提供了统一的遍历方式。</li>
<li>对于更换容器实现，只需要更改<code>Collection&lt;String&gt; collection = new ArrayList&lt;&gt;();</code>这样一个地方即可。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/01/06/java设计模式——命令模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/06/java设计模式——命令模式/" class="post-title-link" itemprop="url">java设计模式——命令模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-01-06 21:30:40 / Modified: 21:43:56" itemprop="dateCreated datePublished" datetime="2018-01-06T21:30:40+08:00">2018-01-06</time>
            </span>

          
            <span id="/2018/01/06/java设计模式——命令模式/" class="post-meta-item leancloud_visitors" data-flag-title="java设计模式——命令模式" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/01/06/java设计模式——命令模式/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/06/java设计模式——命令模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><blockquote>
<p>女朋友命令男友，并且能够反悔。</p>
</blockquote>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomkk.dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">excecute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">unDo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCmd</span> <span class="keyword">extends</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">excecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"陪着逛商场。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unDo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"回家啦~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commondList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Command&gt; commandHistory = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        commondList.add(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCommands</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command c : commondList) &#123;</span><br><span class="line">            c.excecute();</span><br><span class="line">          </span><br><span class="line">            commandHistory.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unDo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!commandHistory.empty()) &#123;</span><br><span class="line">            commandHistory.peek().unDo();</span><br><span class="line">            commandHistory.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MM</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">order</span><span class="params">(Boy boy)</span> </span>&#123;</span><br><span class="line">        Command cmd = <span class="keyword">new</span> ShoppingCmd();</span><br><span class="line">        boy.addCommand(cmd);</span><br><span class="line">      </span><br><span class="line">        boy.doCommands();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regret</span><span class="params">(Boy boy)</span> </span>&#123;</span><br><span class="line">        boy.unDo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MM mm = <span class="keyword">new</span> MM();</span><br><span class="line">        Boy boy = <span class="keyword">new</span> Boy();</span><br><span class="line"></span><br><span class="line">        mm.order(boy);</span><br><span class="line">        mm.regret(boy);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/01/03/Java设计模式——桥接模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/01/03/Java设计模式——桥接模式/" class="post-title-link" itemprop="url">Java设计模式——桥接模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2018-01-03 17:12:51 / Modified: 20:47:00" itemprop="dateCreated datePublished" datetime="2018-01-03T17:12:51+08:00">2018-01-03</time>
            </span>

          
            <span id="/2018/01/03/Java设计模式——桥接模式/" class="post-meta-item leancloud_visitors" data-flag-title="Java设计模式——桥接模式" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/01/03/Java设计模式——桥接模式/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/01/03/Java设计模式——桥接模式/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h1><blockquote>
<p>设计汽车的类的继承结构，要求类向两个维度扩展</p>
<ol>
<li>维度一：具体的品牌，如BMW、Benz</li>
<li>维度二：类型，如跑车sports car、轿车saloon car</li>
</ol>
<p>这两个维度应该都是继承于父类Car，但是问题在于BWM和Benz中既存在跑车系列也存在轿车系列，所以将BWM直接继承跑车或者轿车都不合理。</p>
<p>要求能够实现品牌和类型之间的任意排列组合。</p>
</blockquote>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tomkk.dp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> CarImpl impl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">extends</span> <span class="title">CarImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">CarImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SportsCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SportsCar</span><span class="params">(CarImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaloonCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SaloonCar</span><span class="params">(CarImpl impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SportsCar(<span class="keyword">new</span> BMW());</span><br><span class="line">        <span class="keyword">new</span> SportsCar(<span class="keyword">new</span> Benz());</span><br><span class="line">        <span class="keyword">new</span> SaloonCar(<span class="keyword">new</span> BMW());</span><br><span class="line">        <span class="keyword">new</span> SaloonCar(<span class="keyword">new</span> Benz());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TomKK"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">TomKK</p>
  <div class="site-description" itemprop="description">学而后知不足</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:tomkklalala@qq.com" title="E-Mail → mailto:tomkklalala@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TomKK</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"ln2t4IqFJHxBwyPmvGIOSOq7-9Nh9j0Va","app_key":"KSRW7KXJo9vinkNUdDEkjaww","server_url":"https://ln2t4iqf.lc-cn-e1-shared.com","security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://http-tomkklalala-github-io.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>

</body>
</html>
