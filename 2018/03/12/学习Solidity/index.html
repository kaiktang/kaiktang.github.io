<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kaiktang.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1}},"activeClass":"disqus"},"algolia":{"appID":"FBQ33HXA0Q","apiKey":"5a256d1a0d5075a6a17b29fbae8cdbdc","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Solidity介绍  官网：http:&#x2F;&#x2F;solidity.readthedocs.io&#x2F;en&#x2F;develop&#x2F;   Solidity 是一个面向合约的高级语言，其语法类似于JavaScript 。是运行在以太坊虚拟机中的代码。  Solidity 是静态类型的编程语言，编译期间会检查其数据类型。支持继承、类和复杂的用户定义类型。  在线体验： https:&#x2F;&#x2F;remix.ethereum.or">
<meta property="og:type" content="article">
<meta property="og:title" content="学习Solidity">
<meta property="og:url" content="http://kaiktang.github.io/2018/03/12/%E5%AD%A6%E4%B9%A0Solidity/index.html">
<meta property="og:site_name" content="kaiktang&#39;s blogs">
<meta property="og:description" content="Solidity介绍  官网：http:&#x2F;&#x2F;solidity.readthedocs.io&#x2F;en&#x2F;develop&#x2F;   Solidity 是一个面向合约的高级语言，其语法类似于JavaScript 。是运行在以太坊虚拟机中的代码。  Solidity 是静态类型的编程语言，编译期间会检查其数据类型。支持继承、类和复杂的用户定义类型。  在线体验： https:&#x2F;&#x2F;remix.ethereum.or">
<meta property="og:locale">
<meta property="article:published_time" content="2018-03-12T02:45:54.000Z">
<meta property="article:modified_time" content="2019-01-06T07:08:17.000Z">
<meta property="article:author" content="kaiktang">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="Solidity">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://kaiktang.github.io/2018/03/12/%E5%AD%A6%E4%B9%A0Solidity/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>学习Solidity | kaiktang's blogs</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8714a47efb513991b4862eafeadb6a3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">kaiktang's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/03/12/%E5%AD%A6%E4%B9%A0Solidity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="kaiktang">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="kaiktang's blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          学习Solidity
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-03-12 10:45:54" itemprop="dateCreated datePublished" datetime="2018-03-12T10:45:54+08:00">2018-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-06 15:08:17" itemprop="dateModified" datetime="2019-01-06T15:08:17+08:00">2019-01-06</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/03/12/%E5%AD%A6%E4%B9%A0Solidity/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/03/12/学习Solidity/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Solidity介绍"><a href="#Solidity介绍" class="headerlink" title="Solidity介绍"></a>Solidity介绍</h1><blockquote>
<ul>
<li>官网：<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/">http://solidity.readthedocs.io/en/develop/</a></li>
</ul>
<ul>
<li><p>Solidity 是一个面向合约的高级语言，其语法类似于JavaScript 。是运行在以太坊虚拟机中的代码。</p>
</li>
<li><p>Solidity 是静态类型的编程语言，编译期间会检查其数据类型。支持继承、类和复杂的用户定义类型。</p>
</li>
<li><p>在线体验： <a target="_blank" rel="noopener" href="https://remix.ethereum.org">https://remix.ethereum.org</a></p>
<p>但是这平台只能撰写和编译Solidity代码，如果想真正运行代码的话，需要有一个以太坊的本地环境。</p>
</li>
</ul>
</blockquote>
<h1 id="Solidity源文件的布局"><a href="#Solidity源文件的布局" class="headerlink" title="Solidity源文件的布局"></a>Solidity源文件的布局</h1><h2 id="Version-Pragma"><a href="#Version-Pragma" class="headerlink" title="Version Pragma"></a>Version Pragma</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br></pre></td></tr></table></figure>
<p>这代表着该源文件只会被版本为从<code>0.4.0</code>到<code>0.5.0</code>之间的编译器编译（后面一个条件是由<code>^</code>来指出）。更复杂的编译器限定语法和npm一样。</p>
<h2 id="导入语句"><a href="#导入语句" class="headerlink" title="导入语句"></a>导入语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;filename&quot;;</span><br><span class="line">import * as symbolName from &quot;filename&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="State-Sariables"><a href="#State-Sariables" class="headerlink" title="State Sariables"></a>State Sariables</h2><p>会在合约存储中持久存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData; // State variable</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>函数是合约中的执行单元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    function bid() public payable &#123; // Function</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Function-Modifiers"><a href="#Function-Modifiers" class="headerlink" title="Function Modifiers"></a>Function Modifiers</h2><p>声明函数执行的条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    address public seller;</span><br><span class="line"></span><br><span class="line">    modifier onlySeller() &#123; // Modifier</span><br><span class="line">        require(msg.sender == seller);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function abort() public onlySeller &#123; // Modifier usage</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h2><p>提供日志功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); // Event</span><br><span class="line"></span><br><span class="line">    function bid() public payable &#123;</span><br><span class="line">        // ...</span><br><span class="line">        HighestBidIncreased(msg.sender, msg.value); // Triggering event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Struct-Types"><a href="#Struct-Types" class="headerlink" title="Struct Types"></a>Struct Types</h2><p>结构体</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Ballot &#123;</span><br><span class="line">    struct Voter &#123; // Struct</span><br><span class="line">        uint weight;</span><br><span class="line">        bool voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Enum-Types"><a href="#Enum-Types" class="headerlink" title="Enum Types"></a>Enum Types</h2><p>枚举类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    enum State &#123; Created, Locked, Inactive &#125; // Enum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>被赋值的时候为值传递，即会被原样复制一份。</p>
<h3 id="Boolean（布尔）"><a href="#Boolean（布尔）" class="headerlink" title="Boolean（布尔）"></a>Boolean（布尔）</h3><p>存在短路效应</p>
<h3 id="Integers（整数）"><a href="#Integers（整数）" class="headerlink" title="Integers（整数）"></a>Integers（整数）</h3><p><code>int/uint</code>都支持声明位数，规则为<code>int8/uint8</code>到<code>int256/uint256</code>以8为步长都支持。除法操作始终会截断，除非操作数都是字面值。<code>2**2</code>代表2的2次方。</p>
<p>注意：对负数进行右移操作会导致结果接近0。</p>
<h3 id="Fixed-Point-Numbers（定点数）"><a href="#Fixed-Point-Numbers（定点数）" class="headerlink" title="Fixed Point Numbers（定点数）"></a>Fixed Point Numbers（定点数）</h3><p>注意：还未完全支持，只能声明不能赋值或被赋值。</p>
<h3 id="Address（地址）"><a href="#Address（地址）" class="headerlink" title="Address（地址）"></a>Address（地址）</h3><p>20字节长。</p>
<p>支持操作：<code>&lt;=</code>，<code>&lt;</code>，<code>==</code>，<code>!=</code>，<code>&gt;=</code>，<code>&gt;</code></p>
<p>注意：从<code>0.5.0</code>版本开始合约只能从地址显式转换。</p>
<p>拥有的成员：</p>
<ul>
<li><code>balance</code>：用来查询账户余额</li>
<li><code>transfer</code>：用来向某个账户转账。如果转账失败，那么会产生异常并回滚。</li>
<li><code>send</code>：和<code>transfer</code>对应的更底层的方法。如果转账失败那么<code>send</code>将会返回false，而不会产生异常。</li>
<li><code>call</code>：接收任意个数任意类型的参数。返回一个bool代表执行是否成功。但是无法获取执行的返回值。可以设置供给的<code>gas()</code>和<code>value()</code></li>
<li><code>callcode</code>：不推荐使用，未来将会被移除。</li>
<li><code>delegatecall</code>：只执行指定地址的代码</li>
</ul>
<h3 id="Fixed-size-byte-arrays（定长字节数组）"><a href="#Fixed-size-byte-arrays（定长字节数组）" class="headerlink" title="Fixed-size byte arrays（定长字节数组）"></a>Fixed-size byte arrays（定长字节数组）</h3><p>支持<code>byte</code>,<code>byte1</code>…<code>byte32</code>，其中<code>byte</code>是<code>byte1</code>的别名。</p>
<p>支持操作：<code>&lt;=</code>, <code>&lt;</code>, <code>==</code>, <code>!=</code>, <code>&gt;=</code>, <code>&gt;</code>，<code>&amp;</code>, <code>|</code>, <code>^</code>，<code>~</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，索引操作</p>
<p>拥有的成员：<code>.length</code>只读，返回长度</p>
<h3 id="Dynamically-sized-byte-array（变长字节数组）"><a href="#Dynamically-sized-byte-array（变长字节数组）" class="headerlink" title="Dynamically-sized byte array（变长字节数组）"></a>Dynamically-sized byte array（变长字节数组）</h3><p><code>bytes</code>和<code>string</code>都是引用类型，即赋值的时候仅仅是引用传递。前者是动态长度的byte数组后者是动态长度的utf-8字符。</p>
<h3 id="Address-Literals（地址字面值）"><a href="#Address-Literals（地址字面值）" class="headerlink" title="Address Literals（地址字面值）"></a>Address Literals（地址字面值）</h3><p>通过校验和检验的十六进制常量。</p>
<h3 id="Rational-and-Integer-Literals（有理数和整数常量）"><a href="#Rational-and-Integer-Literals（有理数和整数常量）" class="headerlink" title="Rational and Integer Literals（有理数和整数常量）"></a>Rational and Integer Literals（有理数和整数常量）</h3><p>支持科学计数法。</p>
<p>字面值之间的计算并不会导致截断，比如<code>(2**800 + 1) - 2**800</code>将会得到1（类型为uint8），尽管中间结果已经超出了机器字长。<code>.5 * 8</code>将会得到4，尽管操作数中有小数。<code>5/2=2.5</code></p>
<p>位操作的两个操作数不允许小数参与，另外指数运算中，指数不能为小数，因为可能会产生无理数。</p>
<p>当字面值和非字面值进行运算的时候，字面值将会变成非字面值。</p>
<p>注意，在Solidity中没有浮点数类型，因为浮点数运算会导致精度问题，而在操作中所有的浮点数都可以被用<code>wei</code>来表示。</p>
<h3 id="String-Literals（字符串字面值）"><a href="#String-Literals（字符串字面值）" class="headerlink" title="String Literals（字符串字面值）"></a>String Literals（字符串字面值）</h3><p>可以用双引号或者单引号包裹，<code>&quot;foo&quot;</code>占3个字节，没有C语言中的<code>/0</code>。支持转义字符。</p>
<h3 id="Hexadecimal-Literals（十六进制字面值）"><a href="#Hexadecimal-Literals（十六进制字面值）" class="headerlink" title="Hexadecimal Literals（十六进制字面值）"></a>Hexadecimal Literals（十六进制字面值）</h3><p><code>hex&quot;001122FF&quot;</code>或者<code>hex&#39;001122FF&#39;</code></p>
<h3 id="Enums（枚举）"><a href="#Enums（枚举）" class="headerlink" title="Enums（枚举）"></a>Enums（枚举）</h3><p>可以转换为整数类型</p>
<h3 id="Function-Types（函数类型）"><a href="#Function-Types（函数类型）" class="headerlink" title="Function Types（函数类型）"></a>Function Types（函数类型）</h3><p>函数分为<code>internal</code>和<code>external</code>两种：内部的函数只能在当前合约内部调用。外部函数由地址和方法签名组成，只能被外部函数传入或者外部函数返回。</p>
<p>函数类型声明语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure>
<p>默认函数类型为<code>internal</code>。</p>
<p>有两种方式来访问当前合约的公开函数，一种是直接用名字，一种是<code>this.f</code>。前者会导致内部函数，后者会导致外部函数。</p>
<p>内部函数使用例子： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  // internal functions can be used in internal library functions because</span><br><span class="line">  // they will be part of the same code context</span><br><span class="line">  function map(uint[] memory self, function (uint) pure returns (uint) f)</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (uint[] memory r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = new uint[](self.length);</span><br><span class="line">    for (uint i = 0; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function reduce(</span><br><span class="line">    uint[] memory self,</span><br><span class="line">    function (uint, uint) pure returns (uint) f</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (uint r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = self[0];</span><br><span class="line">    for (uint i = 1; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function range(uint length) internal pure returns (uint[] memory r) &#123;</span><br><span class="line">    r = new uint[](length);</span><br><span class="line">    for (uint i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils for *;</span><br><span class="line">  function pyramid(uint l) public pure returns (uint) &#123;</span><br><span class="line">    return ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  function square(uint x) internal pure returns (uint) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  function sum(uint x, uint y) internal pure returns (uint) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部函数使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    function(bytes memory) external callback;</span><br><span class="line">  &#125;</span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  function query(bytes data, function(bytes memory) external callback) public &#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    NewRequest(requests.length - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  function reply(uint requestID, bytes response) public &#123;</span><br><span class="line">    // Here goes the check that the reply comes from a trusted source</span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(0x1234567); // known contract</span><br><span class="line">  function buySomething() &#123;</span><br><span class="line">    oracle.query(&quot;USD&quot;, this.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  function oracleResponse(bytes response) public &#123;</span><br><span class="line">    require(msg.sender == address(oracle));</span><br><span class="line">    // Use the data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>复杂类型。因为拷贝引用类型的变量耗费很高，所以我们需要考虑是将他们存放在<code>memory</code>（非持久化）还是<code>storage</code>（状态变量所存放的地方）里面。</p>
<h3 id="数据存储位置"><a href="#数据存储位置" class="headerlink" title="数据存储位置"></a>数据存储位置</h3><p>每个复杂类型如<code>Arrays</code>和<code>structs</code>都可以指明存储位置，<code>memory</code>或<code>storage</code>。</p>
<p>默认情况下，函数的参数和返回值为<code>memory</code>类型，局部变量为<code>storage</code>，状态变量强制为<code>storage</code>。外部函数的参数强制为<code>calldata</code>。</p>
<p><code>storage</code>和<code>memory</code>之间的相互赋值又或者是赋值给一个状态变量都会产生一个全新的拷贝。<code>storage</code>引用类型赋值给本地<code>storage</code>变量的仅仅是一个引用。<code>memory-stored reference type</code>之间的相互赋值并不会产生新的拷贝。</p>
<blockquote>
<p>总结：</p>
<ol>
<li><code>storage</code>引用类型和<code>storage</code>引用类型，为引用传递</li>
<li><code>storage</code>引用类型和<code>memory</code>引用类型，会产生拷贝</li>
<li><code>memory</code>引用类型和<code>memory</code>引用类型之间，为引用传递</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; // the data location of x is storage</span><br><span class="line"></span><br><span class="line">    // the data location of memoryArray is memory</span><br><span class="line">    function f(uint[] memoryArray) public &#123;</span><br><span class="line">        x = memoryArray; // works, copies the whole array to storage</span><br><span class="line">        var y = x; // works, assigns a pointer, data location of y is storage</span><br><span class="line">        y[7]; // fine, returns the 8th element</span><br><span class="line">        y.length = 2; // fine, modifies x through y</span><br><span class="line">        delete x; // fine, clears the array, also modifies y</span><br><span class="line">        // The following does not work; it would need to create a new temporary /</span><br><span class="line">        // unnamed array in storage, but storage is &quot;statically&quot; allocated:</span><br><span class="line">        // y = memoryArray;</span><br><span class="line">        // This does not work either, since it would &quot;reset&quot; the pointer, but there</span><br><span class="line">        // is no sensible location it could point to.</span><br><span class="line">        // delete y;</span><br><span class="line">        g(x); // calls g, handing over a reference to x</span><br><span class="line">        h(x); // calls h and creates an independent, temporary copy in memory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class="line">    function h(uint[] memoryArray) public &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>可以动态大小也可以固定大小。</p>
<p><code>bytes</code>和<code>string</code>为特殊的数组。<code>string</code>和<code>bytes</code>相同，但是目前不支持<code>length</code>和下标访问操作。</p>
<p>更推荐使用<code>bytes</code>，相比于<code>byte[]</code>。</p>
<p>可以将数组标记为<code>public</code>，然后<code>solidity</code>将会创建相应的<code>getter</code>，下标为<code>getter</code>的参数。</p>
<h3 id="分配内存数组"><a href="#分配内存数组" class="headerlink" title="分配内存数组"></a>分配内存数组</h3><p>不能像<code>storage</code>数组一样通过修改<code>length</code>字段来修改数组大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint len) public pure &#123;</span><br><span class="line">        uint[] memory a = new uint[](7);</span><br><span class="line">        bytes memory b = new bytes(len);</span><br><span class="line">        // Here we have a.length == 7 and b.length == len</span><br><span class="line">        a[6] = 8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Array-Literals-Inline-Arrays（数组字面值-行内数组）"><a href="#Array-Literals-Inline-Arrays（数组字面值-行内数组）" class="headerlink" title="Array Literals / Inline Arrays（数组字面值/行内数组）"></a>Array Literals / Inline Arrays（数组字面值/行内数组）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        g([uint(1), 2, 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    function g(uint[3] _data) public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>[1, 2, 3]</code>的类型为<code>uint8[3] memory</code>。无法将一个数组字面值赋值给一个动态大小数组。</p>
<p>成员有：</p>
<ul>
<li><code>length</code>：<code>storage</code>动态数组可以通过修改length来改变数组容量，但是<code>memory</code>不可以。越界访问并不会触发扩容，<code>memory</code>动态数组一旦被创建他们的大小是固定的。</li>
<li><code>push</code>：<code>storage</code>动态数组有<code>push</code>函数，返回新长度。</li>
</ul>
<h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>成员不能是自己。</p>
<h3 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h3><p>声明语法<code>mapping(_KeyType =&gt; _ValueType)</code>。其中<code>_KetType</code>可以是任意除了<code>mapping</code>的类型。<code>_ValueType</code>可以为任意类型。</p>
<p>实际是一个哈希表。</p>
<p><code>Mapping</code>变量只能为状态变量或者内部函数的<code>storage</code>引用类型。</p>
<h2 id="涉及左值的运算符"><a href="#涉及左值的运算符" class="headerlink" title="涉及左值的运算符"></a>涉及左值的运算符</h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><code>delete a</code>将<code>a</code>置成其零值，比如对于动态长度数组将会变为长度为0；固定长度的数组中的所有元素被重置；对于struct而言所有字段将会被重置。但是不会对mapping类型生效。</p>
<p><code>delete</code>操作就像赋值操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint x = data;</span><br><span class="line">        delete x; // sets x to 0, does not affect data</span><br><span class="line">        delete data; // sets data to 0, does not affect x which still holds a copy</span><br><span class="line">        uint[] storage y = dataArray;</span><br><span class="line">        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also</span><br><span class="line">        // y is affected which is an alias to the storage object</span><br><span class="line">        // On the other hand: &quot;delete y&quot; is not valid, as assignments to local variables</span><br><span class="line">        // referencing storage objects can only be made from existing storage objects.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h2><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>如果一个运算符应用于不同类型的，那么编译器会尝试转换一个操作数类型为另一个操作数类型（赋值操作类似）。总体来说，两个值类型之间的隐式转换在不丢失信息的时候是可能的。</p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p><code>for (var i = 0; i &lt; 2000; i++) &#123; … &#125;</code>，该循环将永远不会停止，因为<code>i</code>将会被推断为<code>uint8</code>，而其不会超过2000。</p>
<h1 id="单位以及全局变量"><a href="#单位以及全局变量" class="headerlink" title="单位以及全局变量"></a>单位以及全局变量</h1><h2 id="Ether-Units"><a href="#Ether-Units" class="headerlink" title="Ether Units"></a>Ether Units</h2><p><code>wei</code>， <code>finney</code>， <code>szabo</code> ， <code>ether</code>，如果没有单位那么默认单位为<code>wei</code>。</p>
<h2 id="Time-Units"><a href="#Time-Units" class="headerlink" title="Time Units"></a>Time Units</h2><p><code>seconds</code>, <code>minutes</code>, <code>hours</code>, <code>days</code>, <code>weeks</code> 和 <code>years</code></p>
<ul>
<li><code>1 == 1 seconds</code></li>
<li><code>1 minutes == 60 seconds</code></li>
<li><code>1 hours == 60 minutes</code></li>
<li><code>1 days == 24 hours</code></li>
<li><code>1 weeks == 7 days</code></li>
<li><code>1 years == 365 days</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(uint start, uint daysAfter) public &#123;</span><br><span class="line">    if (now &gt;= start + daysAfter * 1 days) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区块和交易属性"><a href="#区块和交易属性" class="headerlink" title="区块和交易属性"></a>区块和交易属性</h3><ul>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>: hash of the given block - only works for 256 most recent blocks excluding current</li>
<li><code>block.coinbase</code> (<code>address</code>): current block miner’s address</li>
<li><code>block.difficulty</code> (<code>uint</code>): current block difficulty</li>
<li><code>block.gaslimit</code> (<code>uint</code>): current block gaslimit</li>
<li><code>block.number</code> (<code>uint</code>): current block number</li>
<li><code>block.timestamp</code> (<code>uint</code>): current block timestamp as seconds since unix epoch</li>
<li><code>msg.data</code> (<code>bytes</code>): complete calldata</li>
<li><code>msg.gas</code> (<code>uint</code>): remaining gas</li>
<li><code>msg.sender</code> (<code>address</code>): sender of the message (current call)</li>
<li><code>msg.sig</code> (<code>bytes4</code>): first four bytes of the calldata (i.e. function identifier)</li>
<li><code>msg.value</code> (<code>uint</code>): number of wei sent with the message</li>
<li><code>now</code> (<code>uint</code>): current block timestamp (alias for <code>block.timestamp</code>)</li>
<li><code>tx.gasprice</code> (<code>uint</code>): gas price of the transaction</li>
<li><code>tx.origin</code> (<code>address</code>): sender of the transaction (full call chain)</li>
</ul>
<blockquote>
<p>注意：<code>msg</code>的所有的成员会随每次外部函数调用而改变。只能获取最近的256个区块哈希。</p>
</blockquote>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p><code>assert(bool condition)</code>:</p>
<p>throws if the condition is not met - to be used for internal errors. 用于内部错误。</p>
<p><code>require(bool condition)</code>:</p>
<p>throws if the condition is not met - to be used for errors in inputs or external components. 可以用于内部或者外部。</p>
<p><code>revert()</code>:</p>
<p>abort execution and revert state changes。终止执行，并回滚状态。</p>
<h3 id="数学和密码学函数"><a href="#数学和密码学函数" class="headerlink" title="数学和密码学函数"></a>数学和密码学函数</h3><ul>
<li><code>addmod(uint x, uint y, uint k) returns (uint)</code></li>
</ul>
<p>计算 <code>(x + y) % k</code> </p>
<ul>
<li><code>mulmod(uint x, uint y, uint k) returns (uint)</code></li>
</ul>
<p>计算<code>(x * y) % k</code> </p>
<ul>
<li><code>keccak256(...) returns (bytes32)</code></li>
</ul>
<p>计算<code>Ethereum-SHA-3 (Keccak-256) hash</code></p>
<ul>
<li><code>sha256(...) returns (bytes32)</code></li>
</ul>
<p>计算<code>SHA-256 hash</code></p>
<ul>
<li><code>sha3(...) returns (bytes32)</code></li>
</ul>
<p><code>keccak256</code>的别名</p>
<ul>
<li><code>ripemd160(...) returns (bytes20)</code></li>
</ul>
<p>计算<code>RIPEMD-160 hash</code></p>
<ul>
<li><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code></li>
</ul>
<p>根据椭圆曲线签名得到的公钥恢复地址</p>
<h3 id="地址相关"><a href="#地址相关" class="headerlink" title="地址相关"></a>地址相关</h3><ul>
<li><code>&lt;address&gt;.balance</code> (<code>uint256</code>)</li>
</ul>
<ul>
<li><code>&lt;address&gt;.transfer(uint256 amount)</code></li>
</ul>
<p>若失败，抛出异常</p>
<ul>
<li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code></li>
</ul>
<p>若失败，返回false</p>
<ul>
<li><code>&lt;address&gt;.call(...) returns (bool)</code></li>
</ul>
<p>若失败，返回false</p>
<ul>
<li><code>&lt;address&gt;.callcode(...) returns (bool)</code></li>
</ul>
<p>不推荐使用，未来将会被移除</p>
<ul>
<li><code>&lt;address&gt;.delegatecall(...) returns (bool)</code></li>
</ul>
<h3 id="合约相关"><a href="#合约相关" class="headerlink" title="合约相关"></a>合约相关</h3><ul>
<li><code>this</code></li>
</ul>
<p>代表当前合约，可以被显示的转化成地址</p>
<ul>
<li><code>selfdestruct(address recipient)</code></li>
</ul>
<p>销毁当前合约，并将余额发送到指定地址</p>
<ul>
<li><code>suicide(address recipient)</code></li>
</ul>
<p><code>selfdestruct</code>的别名</p>
<h1 id="表达式和控制结构"><a href="#表达式和控制结构" class="headerlink" title="表达式和控制结构"></a>表达式和控制结构</h1><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><p> <code>if</code>, <code>else</code>, <code>while</code>, <code>do</code>, <code>for</code>, <code>break</code>, <code>continue</code>, <code>return</code>, <code>? :</code></p>
<p>条件中括号不能被省略。</p>
<p>条件中不允许非布尔值转化为布尔值。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="内部函数调用"><a href="#内部函数调用" class="headerlink" title="内部函数调用"></a>内部函数调用</h3><p>在EVM被翻译为<code>jump</code>指令。</p>
<h3 id="外部函数调用"><a href="#外部函数调用" class="headerlink" title="外部函数调用"></a>外部函数调用</h3><p>用法类似<code>c.g(2)</code>，其中<code>c</code>为一个合约实例， 这种情况下调用将会通过消息来调用，而不是通过<code>jump</code>。</p>
<p>注意在构造器中不能使用<code>this</code>来调用其他函数，因为当时合约还未被创建。</p>
<p>其他合约的方法通过外部调用来实现，在外部调用的时候，可以使用<code>.gas()</code>和<code>.value()</code>来说明发送的<code>Wei</code>数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    function info() public payable returns (uint ret) &#123; return 42; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    function setFeed(address addr) public &#123; feed = InfoFeed(addr); &#125;</span><br><span class="line">    function callFeed() public &#123; feed.info.value(10).gas(800)(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>payable</code>使得<code>.value()</code>生效</p>
<p><code>feed = InfoFeed(addr);</code>将地址强制转换成合约，并不会调用构造器。</p>
<p><code>feed.info.value(10).gas(800)();</code>发送了10wei，并且限制了最高消费800wei。这里注意如果没有最后的括号的话，那么函数将不会执行。</p>
<blockquote>
<p>警告：任何和另一个合约的交互都潜在的危险，尤其在那个合约的代码没有事先知晓的情况下。当前合约交过控制权到被调用合约，而这意味着他可以做任何事情。即使被调用的合约是继承于一个已知合约，但是继承合约仅仅需要满足正确的接口即可，但是他的实现却可以是任意的，因此会造成危险。另外，需要注意防止它调用了你系统中的其他合约或者甚至在第一个调用结束前又回到了调用者。这意味着被调用合约能够通过它的函数来修改调用者的状态。应该以如下形式书写合约，比如：在修改完合约状态之后再去调用外部函数，以此来避免被重入利用。</p>
</blockquote>
<h3 id="通过new来创建合约"><a href="#通过new来创建合约" class="headerlink" title="通过new来创建合约"></a>通过<code>new</code>来创建合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function D(uint a) public payable &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    D d = new D(4); // will be executed as part of C&#x27;s constructor</span><br><span class="line"></span><br><span class="line">    function createD(uint arg) public &#123;</span><br><span class="line">        D newD = new D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createAndEndowD(uint arg, uint amount) public payable &#123;</span><br><span class="line">        // Send ether along with the creation</span><br><span class="line">        D newD = (new D).value(amount)(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在创建合约的同时是能够发送以太币。</p>
<h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function f() public pure returns (uint, bool, uint) &#123;</span><br><span class="line">        return (7, true, 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // Declares and assigns the variables. Specifying the type explicitly is not possible.</span><br><span class="line">        var (x, b, y) = f();</span><br><span class="line">        // Assigns to a pre-existing variable.</span><br><span class="line">        (x, y) = (2, 7);</span><br><span class="line">        // Common trick to swap values -- does not work for non-value storage types.</span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        // Components can be left out (also for variable declarations).</span><br><span class="line">        // If the tuple ends in an empty component,</span><br><span class="line">        // the rest of the values are discarded.</span><br><span class="line">        (data.length,) = f(); // Sets the length to 7</span><br><span class="line">        // The same can be done on the left side.</span><br><span class="line">        // If the tuple begins in an empty component, the beginning values are discarded.</span><br><span class="line">        (,data[3]) = f(); // Sets data[3] to 2</span><br><span class="line">        // Components can only be left out at the left-hand-side of assignments, with</span><br><span class="line">        // one exception:</span><br><span class="line">        (x,) = (1,);</span><br><span class="line">        // (1,) is the only way to specify a 1-component tuple, because (1) is</span><br><span class="line">        // equivalent to 1.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于Arrays和Structs的一些问题"><a href="#关于Arrays和Structs的一些问题" class="headerlink" title="关于Arrays和Structs的一些问题"></a>关于Arrays和Structs的一些问题</h3><p>对于一些像<code>Arrays</code>和<code>Structs</code>非值类型之间的赋值比较复杂。</p>
<p>向一个状态变量赋值总会产生一个新的拷贝。</p>
<p>只有当基本类型赋值给本地变量的情况下，才会产生新的拷贝。</p>
<p>如果一个类型为<code>struct</code>或者<code>arrays</code>的状态变量赋值给本地变量，那么本地变量将会持有状态变量的一个引用，再次被赋值并不会影响原状态变量，但是对其成员的修改将会影响原状态变量。</p>
<h2 id="作用域和声明"><a href="#作用域和声明" class="headerlink" title="作用域和声明"></a>作用域和声明</h2><p>刚被声明的变量初始值默认值从字节的角度来看都是0字节。</p>
<p>一个在函数内声明的变量，不论在什么位置，作用域都是整个函数，和JS类似，Solidity中并不存在块作用域，且也存在声明上移的机制。</p>
<h2 id="错误处理：Assert-Require-Revert-and-Exceptions"><a href="#错误处理：Assert-Require-Revert-and-Exceptions" class="headerlink" title="错误处理：Assert, Require, Revert and Exceptions"></a>错误处理：Assert, Require, Revert and Exceptions</h2><p>Solidity使用状态回滚来处理异常。</p>
<p>异常会进行向上冒泡，另外，需要注意的是对一个不存在账户调用函数将会返回成功，所以在外部调用之前应该先确保合约存在。</p>
<p><code>require</code>和<code>assert</code>的用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Sharer &#123;</span><br><span class="line">    function sendHalf(address addr) public payable returns (uint balance) &#123;</span><br><span class="line">        require(msg.value % 2 == 0); // Only allow even numbers</span><br><span class="line">        uint balanceBeforeTransfer = this.balance;</span><br><span class="line">        addr.transfer(msg.value / 2);</span><br><span class="line">        // Since transfer throws an exception on failure and</span><br><span class="line">        // cannot call back here, there should be no way for us to</span><br><span class="line">        // still have half of the money.</span><br><span class="line">        assert(this.balance == balanceBeforeTransfer - msg.value / 2);</span><br><span class="line">        return this.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会触发类似<code>assert</code>的异常的几种情况：</p>
<ol>
<li>访问一个变长/定长数组的越界下标或者负数下标</li>
<li>除法操作和取模操作对0进行(e.g. <code>5 / 0</code> or <code>23 % 0</code>)</li>
<li>试图移动负数位</li>
<li>试图将一个过大的数或者负数转换成枚举类型</li>
<li>试图调用一个未被赋值的函数</li>
<li><code>assert</code>检测条件返回失败</li>
</ol>
<p>会触发类似<code>require</code>的异常的几种情况：</p>
<ol>
<li>调用<code>throw</code></li>
<li>调用<code>require</code>并且判断的条件返回false</li>
<li>如果通过消息调用来调用一个函数，但它确并没有正确结束（可能是因为用尽gas，没有匹配的函数，或者其本身抛出了异常）。除非使用的是<code>call</code>, <code>send</code>, <code>delegatecall</code> 或 <code>callcode</code> ，他们将会返回false来代表失败</li>
<li>通过<code>new</code>创建了一个合约，但是创建并没有正确结束，可能情况和上一条类似</li>
<li>对一个没有代码的账户进行函数调用</li>
<li>如果你通过一个没有用<code>payable</code>修饰的public函数收到了以太币</li>
<li>如果你通过public getter函数收到了以太币</li>
<li>如果<code>.transfer()</code>失败了</li>
</ol>
<p><code>assert</code>类型的异常会消耗gas，而<code>require</code>类型的不会（从Metropolis版本后）</p>
<h1 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h1><h2 id="可见性和Getters"><a href="#可见性和Getters" class="headerlink" title="可见性和Getters"></a>可见性和Getters</h2><p>Solidity中有两种类型的函数调用：内部调用（并不会创建实际的EVM调用，也称为消息调用），外部调用。</p>
<p>Solidity中对于函数和状态变量有4种类型的可见性规则：</p>
<ul>
<li><code>external</code>：可以被外部合约和交易调用，在本合约内部调用的时候必须要这样使用<code>this.f()</code>。当接收大量数据的时候，很高效。</li>
<li><code>public</code>：既可以被内部调用又可以被消息调用。对于<code>public</code>的状态变量而言，会自动创建getter。</li>
<li><code>internal</code>：只能被当前合约或者子合约使用，不需要<code>this</code>关键字。</li>
<li><code>private</code>：只能被当前合约访问，但是子合约不行。</li>
</ul>
<blockquote>
<p>注意：合约中的任何东西对世界都是公开的，设置<code>private</code>仅仅是防止被外部访问和修改</p>
</blockquote>
<p>可见性修饰符，对于状态变量加在类型后面。对于函数而言，放在参数列表和返回值之间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a) private pure returns (uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) internal &#123; data = a; &#125;</span><br><span class="line">    uint public data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Getter函数"><a href="#Getter函数" class="headerlink" title="Getter函数"></a>Getter函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    C c = new C();</span><br><span class="line">    function f() public &#123;</span><br><span class="line">        uint local = c.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于状态变量data而言，编译器会自动创建一个函数名字为<code>data</code>返回一个uint。这个函数在被内部调用的时候（即不用this的情况下）被解析为状态变量，而在被外部调用的时候，将被解析为函数。</p>
<p>接下来是一个更加复杂的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Complex &#123;</span><br><span class="line">    struct Data &#123;</span><br><span class="line">        uint a;</span><br><span class="line">        bytes3 b;</span><br><span class="line">        mapping (uint =&gt; uint) map;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping (uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) &#123;</span><br><span class="line">    a = data[arg1][arg2][arg3].a;</span><br><span class="line">    b = data[arg1][arg2][arg3].b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意结构体中的map字段会被忽略。</p>
<h2 id="函数修改器"><a href="#函数修改器" class="headerlink" title="函数修改器"></a>函数修改器</h2><p>被用来在函数执行之前自动检查条件。修改器是可以被继承的。</p>
<p>如果同一个函数有多个修改器，他们之间以空格隔开，修饰器会依次检查执行。</p>
<p>函数内可见的符号，在修改器中依旧是可见的。但是在修改器中引入的符号，在函数内却不可见，这是因为它们可能被重写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // This contract only defines a modifier but does not use</span><br><span class="line">    // it: it will be used in derived contracts.</span><br><span class="line">    // The function body is inserted where the special symbol</span><br><span class="line">    // `_;` in the definition of a modifier appears.</span><br><span class="line">    // This means that if the owner calls this function, the</span><br><span class="line">    // function is executed and otherwise, an exception is</span><br><span class="line">    // thrown.</span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    // This contract inherits the `onlyOwner` modifier from</span><br><span class="line">    // `owned` and applies it to the `close` function, which</span><br><span class="line">    // causes that calls to `close` only have an effect if</span><br><span class="line">    // they are made by the stored owner.</span><br><span class="line">    function close() public onlyOwner &#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    // Modifiers can receive arguments:</span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        if (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line"></span><br><span class="line">    // It is important to also provide the</span><br><span class="line">    // `payable` keyword here, otherwise the function will</span><br><span class="line">    // automatically reject all Ether sent to it.</span><br><span class="line">    function register() public payable costs(price) &#123;</span><br><span class="line">        registeredAddresses[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        require(!locked);</span><br><span class="line">        locked = true;	//在函数体执行前执行</span><br><span class="line">        _;  			//继续执行剩下的函数体</span><br><span class="line">        locked = false;	//在函数体执行之后执行</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// This function is protected by a mutex, which means that</span><br><span class="line">    /// reentrant calls from within `msg.sender.call` cannot call `f` again.</span><br><span class="line">    /// The `return 7` statement assigns 7 to the return value but still</span><br><span class="line">    /// executes the statement `locked = false` in the modifier.</span><br><span class="line">    function f() public noReentrancy returns (uint) &#123;</span><br><span class="line">        require(msg.sender.call());</span><br><span class="line">        return 7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常状态变量"><a href="#常状态变量" class="headerlink" title="常状态变量"></a>常状态变量</h2><p>状态变量可以被声明为常量，那么它将在编译期间就固定了。常状态变量不可以被访问<code>storage</code>和区块信息（比如  <code>now</code>, <code>this.balance</code> or <code>block.number</code>）和执行信息（如：msg.gas），以及调用外部合约的表达式初始化。那些会影响内存分配的表达式被允许，但是那些会影响其他内存对象的表达式不会被允许。内置函数如：<code>keccak256</code>, <code>sha256</code>, <code>ripemd160</code>, <code>ecrecover</code>, <code>addmod</code> 和 <code>mulmod</code> 被允许。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant x = 32**22 + 8;</span><br><span class="line">    string constant text = &quot;abc&quot;;</span><br><span class="line">    bytes32 constant myHash = keccak256(&quot;abc&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="View-Functions"><a href="#View-Functions" class="headerlink" title="View Functions"></a>View Functions</h3><p>当函数内不存在修改状态的行为的时候，可以被声明为<code>view</code></p>
<p>一下行为被认为是修改状态：</p>
<ol>
<li>修改状态变量</li>
<li>发出事件</li>
<li>创建其他合约</li>
<li>使用<code>selfdestruct</code></li>
<li>通过调用发送以太币</li>
<li>调用其他没有被<code>pure</code>或者<code>view</code>修饰的函数</li>
<li>使用底层调用</li>
<li>使用包含某些操作码的内联汇编</li>
</ol>
<blockquote>
<p>注意：</p>
<p><code>constant</code>是<code>view</code>的别名。</p>
<p>Getter函数会被标记为view。</p>
<p>编译器不会强制view方法不去修改状态。</p>
</blockquote>
<h3 id="Pure-Functions"><a href="#Pure-Functions" class="headerlink" title="Pure Functions"></a>Pure Functions</h3><p>当函数内不存在读取或者修改状态行为的时候，可以被声明为<code>pure</code>。</p>
<p>修改状态的行为上面已经讨论过，对于读取状态行为如下：</p>
<ol>
<li>读取一个状态变量</li>
<li>访问<code>this.balance</code> 或者<code>&lt;address&gt;.balance</code></li>
<li>访问 <code>block</code>, <code>tx</code>, <code>msg</code> 的成员（除了<code>msg.sig</code>和<code>msg.data</code>）</li>
<li>调用其他没有被<code>pure</code>修饰的函数</li>
<li>使用包含某些操作码的内联汇编</li>
</ol>
<blockquote>
<p>警告：编译器不会强制<code>pure</code>方法不去读取状态。</p>
</blockquote>
<h3 id="Fallback-Function"><a href="#Fallback-Function" class="headerlink" title="Fallback Function"></a>Fallback Function</h3><p>一个合约只能有一个未命名函数。这个函数不能有参数也不能有返回值。当没有一个其他函数匹配的时候（或者甚至没有任何数据提供），将会被执行。另外当账户收到以太币的时候（没有携带数据）这个函数也将会被执行。另外为了能够接受以太币，<code>fallback function</code>必须要有<code>payable</code>修饰，如果没有这样的函数存在那么将无法收到以太币，会抛出异常，并退回以太币。但是这样的账户可以接收挖矿奖励，或者作为<code>selfdestruct</code>的收款方。</p>
<p>虽然fallback function不能设置参数，但是还是可以通过<code>msg.data</code>来获取。</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>一个合约可以有多个同名的函数，但是可以有不同参数。</p>
<p>当调用重载函数的时候，当使用的参数能够一对一地隐式转换为某个函数的参数列表的时候，这个函数将作为候选函数，当有多个候选函数的时候，调用失败。</p>
<blockquote>
<p>注意：返回值类型不被重载考虑在内。</p>
</blockquote>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件能够充分利用EVM的日志功能，能够触发JS的回调函数。</p>
<p>事件能够被继承，当事件被调用的时候，将会被存储在区块链上的一个特殊的数据结构log中，这些数据与区块链共存亡。</p>
<p>日志配合JS的使用案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">    event Deposit(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        bytes32 indexed _id,</span><br><span class="line">        uint _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function deposit(bytes32 _id) public payable &#123;</span><br><span class="line">        // Any call to this function (even deeply nested) can</span><br><span class="line">        // be detected from the JavaScript API by filtering</span><br><span class="line">        // for `Deposit` to be called.</span><br><span class="line">        Deposit(msg.sender, _id, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi as generated by the compiler */;</span><br><span class="line">var ClientReceipt = web3.eth.contract(abi);</span><br><span class="line">var clientReceipt = ClientReceipt.at(&quot;0x1234...ab67&quot; /* address */);</span><br><span class="line"></span><br><span class="line">var event = clientReceipt.Deposit();</span><br><span class="line"></span><br><span class="line">// watch for changes</span><br><span class="line">event.watch(function(error, result)&#123;</span><br><span class="line">    // result will contain various information</span><br><span class="line">    // including the argumets given to the `Deposit`</span><br><span class="line">    // call.</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Or pass a callback to start watching immediately</span><br><span class="line">var event = clientReceipt.Deposit(function(error, result) &#123;</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>solidity支持多继承，包括多态。</p>
<p>当一个合约继承了多个合约之后，只有一个合约会在区块链上创建，那些基合约的代码将会被拷贝到子合约中。</p>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Use `is` to derive from another contract. Derived</span><br><span class="line">// contracts can access all non-private members including</span><br><span class="line">// internal functions and state variables. These cannot be</span><br><span class="line">// accessed externally via `this`, though.</span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// These abstract contracts are only provided to make the</span><br><span class="line">// interface known to the compiler. Note the function</span><br><span class="line">// without body. If a contract does not implement all</span><br><span class="line">// functions it can only be used as an interface.</span><br><span class="line">contract Config &#123;</span><br><span class="line">    function lookup(uint id) public returns (address adr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NameReg &#123;</span><br><span class="line">    function register(bytes32 name) public;</span><br><span class="line">    function unregister() public;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// Multiple inheritance is possible. Note that `owned` is</span><br><span class="line">// also a base class of `mortal`, yet there is only a single</span><br><span class="line">// instance of `owned` (as for virtual inheritance in C++).</span><br><span class="line">contract named is owned, mortal &#123;</span><br><span class="line">    function named(bytes32 name) &#123;</span><br><span class="line">        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">        NameReg(config.lookup(1)).register(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Functions can be overridden by another function with the same name and</span><br><span class="line">    // the same number/types of inputs.  If the overriding function has different</span><br><span class="line">    // types of output parameters, that causes an error.</span><br><span class="line">    // Both local and message-based function calls take these overrides</span><br><span class="line">    // into account.</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) &#123;</span><br><span class="line">            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">            NameReg(config.lookup(1)).unregister();</span><br><span class="line">            // It is still possible to call a specific</span><br><span class="line">            // overridden function.</span><br><span class="line">            mortal.kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// If a constructor takes an argument, it needs to be</span><br><span class="line">// provided in the header (or modifier-invocation-style at</span><br><span class="line">// the constructor of the derived contract (see below)).</span><br><span class="line">contract PriceFeed is owned, mortal, named(&quot;GoldFeed&quot;) &#123;</span><br><span class="line">   function updateInfo(uint newInfo) public &#123;</span><br><span class="line">      if (msg.sender == owner) info = newInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function get() public view returns(uint r) &#123; return info; &#125;</span><br><span class="line"></span><br><span class="line">   uint info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果继承的父类的构造函数需要接受参数，那么在后面加上括号，传入参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 1 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 2 */ mortal.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用<code>Final.kill()</code>的时候将会按照<code>Final</code>，<code>Base2</code>，<code>Base1</code>，<code>motal</code>，<code>owned</code>的顺序来进行查找，所以最后执行的是<code>Base1.kill()</code></p>
<p>当需要调用父合约的方法的时候，可以使用<code>super</code></p>
<h3 id="为基合约设置参数"><a href="#为基合约设置参数" class="headerlink" title="为基合约设置参数"></a>为基合约设置参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function Base(uint _x) public &#123; x = _x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Derived is Base(7) &#123;</span><br><span class="line">    function Derived(uint _y) Base(_y * _y) public &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一共有两种方式，第一种为在列表中直接设置，这种适合参数为常数的情况下，第二种方式类似修改器，作为子合约构造方法的一部分，这种方式适合基合约的参数需要根据子基类而定。</p>
<h3 id="多继承的钻石问题"><a href="#多继承的钻石问题" class="headerlink" title="多继承的钻石问题"></a>多继承的钻石问题</h3><p>在<code>is</code>后应该按照从基合约往子合约的顺序排列。</p>
<p>下面是一个错误实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// This will not compile</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract X &#123;&#125;</span><br><span class="line">contract A is X &#123;&#125;</span><br><span class="line">contract C is A, X &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>C应该声明为<code>contract C is X, A &#123;&#125;</code></p>
<h3 id="继承相同名称不同类型的成员"><a href="#继承相同名称不同类型的成员" class="headerlink" title="继承相同名称不同类型的成员"></a>继承相同名称不同类型的成员</h3><p>当继承导致函数和修改器重名，将会被认为是错误。当事件和修改器重名的时候，也同样会被认为是错误。另外还有函数和事件重名的情况。</p>
<h2 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h2><p>当合约中存在未实现函数的时候，该合约就会被认为是抽象合约。抽象合约不能被编译，只能用来作为基合约。继承了抽象合约但是没有实现其抽象方法，那么该合约也是抽象合约。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>合约中所有的函数都是抽象的时候，该合约被称为接口。接口有如下几个限制：</p>
<ol>
<li>不能继承其他合约或者接口</li>
<li>不能定义构造器</li>
<li>不能定义变量</li>
<li>不能定义结构体</li>
<li>不能定义枚举变量</li>
</ol>
<h2 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h2><p>Libraries和合约很像，但是他们目的是仅仅在特定地点部署一次，并且他们的代码是通过EVM的<code>DELEGATECALL</code> 来重用（Homestead之后为<code>CALLCODE</code> ）。这意味着当库函数被调用的时候，使用的是调用者的上下文环境，即可以访问调用者的storage。因为Library是源码中独立的一块。如果库函数不修改状态的话，那么他们可以被直接调用（比如：不使用<code>DELEGATECALL</code>），因为库是无状态的。</p>
<p>库可以被看做调用者的隐式基合约。他们在继承结构中并不显式可见，但是调用库函数仿佛就像调用一个显式的基合约（比如：<code>L.f()</code>其中L是库的名字）。另外，库的<code>internal</code>函数们对所有合约可见。</p>
<p>外部库函数的例子，以下实现另一个集合工具类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Set &#123;</span><br><span class="line">  // We define a new struct datatype that will be used to</span><br><span class="line">  // hold its data in the calling contract.</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  // Note that the first parameter is of type &quot;storage</span><br><span class="line">  // reference&quot; and thus only its storage address and not</span><br><span class="line">  // its contents is passed as part of the call.  This is a</span><br><span class="line">  // special feature of library functions.  It is idiomatic</span><br><span class="line">  // to call the first parameter `self`, if the function can</span><br><span class="line">  // be seen as a method of that object.</span><br><span class="line">  // 注意第一个参数是`storage reference`类型因此只有它的地址而不是值被传递。这是库函数的一个特性</span><br><span class="line">  // 如果该函数可以被看做是第一个参数的函数，那么我们一般把其命名为self</span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">          return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // The library functions can be called without a</span><br><span class="line">        // specific instance of the library, since the</span><br><span class="line">        // &quot;instance&quot; will be the current contract.</span><br><span class="line">        // 库函数可以不需要被一个实例所调用，因为当前合约即为那个实例</span><br><span class="line">        require(Set.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    // In this contract, we can also directly access knownValues.flags, if we want.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个内部库函数的使用例子，下面自定义了一个大数类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line">    struct bigint &#123;</span><br><span class="line">        uint[] limbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fromUint(uint x) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](1);</span><br><span class="line">        r.limbs[0] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(bigint _a, bigint _b) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">        uint carry = 0;</span><br><span class="line">        for (uint i = 0; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">            uint a = limb(_a, i);</span><br><span class="line">            uint b = limb(_b, i);</span><br><span class="line">            r.limbs[i] = a + b + carry;</span><br><span class="line">            if (a + b &lt; a || (a + b == uint(-1) &amp;&amp; carry &gt; 0))</span><br><span class="line">                carry = 1;</span><br><span class="line">            else</span><br><span class="line">                carry = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &gt; 0) &#123;</span><br><span class="line">            // too bad, we have to add a limb</span><br><span class="line">            uint[] memory newLimbs = new uint[](r.limbs.length + 1);</span><br><span class="line">            for (i = 0; i &lt; r.limbs.length; ++i)</span><br><span class="line">                newLimbs[i] = r.limbs[i];</span><br><span class="line">            newLimbs[i] = carry;</span><br><span class="line">            r.limbs = newLimbs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function limb(bigint _a, uint _limb) internal pure returns (uint) &#123;</span><br><span class="line">        return _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function max(uint a, uint b) private pure returns (uint) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using BigInt for BigInt.bigint;</span><br><span class="line"></span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        var x = BigInt.fromUint(7);</span><br><span class="line">        var y = BigInt.fromUint(uint(-1));</span><br><span class="line">        var z = x.add(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Library和合约的不同点在于：</p>
<ol>
<li>没有状态变量</li>
<li>不能继承或者被继承</li>
<li>不能接受以太币</li>
</ol>
<h2 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For</h2><p> <code>using A for B;</code>用来将库<code>A</code>中的函数绑定到<code>B</code>上，那么B在调用A的函数的时候，方法的第一个参数默认就是B变量。 <code>using A for *;</code>将A上的函数绑定到所有类型上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">// This is the same code as before, just without comments</span><br><span class="line">library Set &#123;</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">        return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Set for Set.Data; // this is the crucial change</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // Here, all variables of type Set.Data have</span><br><span class="line">        // corresponding member functions.</span><br><span class="line">        // The following function call is identical to</span><br><span class="line">        // `Set.insert(knownValues, value)`</span><br><span class="line">        require(knownValues.insert(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="kaiktang WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="kaiktang Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag"># 区块链</a>
              <a href="/tags/Solidity/" rel="tag"># Solidity</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/03/05/p2p%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/" rel="prev" title="p2p网络学习">
      <i class="fa fa-chevron-left"></i> p2p网络学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/04/28/EVM%E5%AD%A6%E4%B9%A0/" rel="next" title="EVM学习">
      EVM学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Solidity%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">Solidity介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Solidity%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">2.</span> <span class="nav-text">Solidity源文件的布局</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Version-Pragma"><span class="nav-number">2.1.</span> <span class="nav-text">Version Pragma</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%85%A5%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.2.</span> <span class="nav-text">导入语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#State-Sariables"><span class="nav-number">2.3.</span> <span class="nav-text">State Sariables</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Functions"><span class="nav-number">2.4.</span> <span class="nav-text">Functions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function-Modifiers"><span class="nav-number">2.5.</span> <span class="nav-text">Function Modifiers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Events"><span class="nav-number">2.6.</span> <span class="nav-text">Events</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Struct-Types"><span class="nav-number">2.7.</span> <span class="nav-text">Struct Types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enum-Types"><span class="nav-number">2.8.</span> <span class="nav-text">Enum Types</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">值类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Boolean%EF%BC%88%E5%B8%83%E5%B0%94%EF%BC%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">Boolean（布尔）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Integers%EF%BC%88%E6%95%B4%E6%95%B0%EF%BC%89"><span class="nav-number">3.1.2.</span> <span class="nav-text">Integers（整数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fixed-Point-Numbers%EF%BC%88%E5%AE%9A%E7%82%B9%E6%95%B0%EF%BC%89"><span class="nav-number">3.1.3.</span> <span class="nav-text">Fixed Point Numbers（定点数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Address%EF%BC%88%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="nav-number">3.1.4.</span> <span class="nav-text">Address（地址）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fixed-size-byte-arrays%EF%BC%88%E5%AE%9A%E9%95%BF%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%EF%BC%89"><span class="nav-number">3.1.5.</span> <span class="nav-text">Fixed-size byte arrays（定长字节数组）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dynamically-sized-byte-array%EF%BC%88%E5%8F%98%E9%95%BF%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%EF%BC%89"><span class="nav-number">3.1.6.</span> <span class="nav-text">Dynamically-sized byte array（变长字节数组）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Address-Literals%EF%BC%88%E5%9C%B0%E5%9D%80%E5%AD%97%E9%9D%A2%E5%80%BC%EF%BC%89"><span class="nav-number">3.1.7.</span> <span class="nav-text">Address Literals（地址字面值）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rational-and-Integer-Literals%EF%BC%88%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E6%95%B4%E6%95%B0%E5%B8%B8%E9%87%8F%EF%BC%89"><span class="nav-number">3.1.8.</span> <span class="nav-text">Rational and Integer Literals（有理数和整数常量）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-Literals%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%EF%BC%89"><span class="nav-number">3.1.9.</span> <span class="nav-text">String Literals（字符串字面值）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hexadecimal-Literals%EF%BC%88%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E9%9D%A2%E5%80%BC%EF%BC%89"><span class="nav-number">3.1.10.</span> <span class="nav-text">Hexadecimal Literals（十六进制字面值）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enums%EF%BC%88%E6%9E%9A%E4%B8%BE%EF%BC%89"><span class="nav-number">3.1.11.</span> <span class="nav-text">Enums（枚举）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-Types%EF%BC%88%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="nav-number">3.1.12.</span> <span class="nav-text">Function Types（函数类型）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.</span> <span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="nav-number">3.2.1.</span> <span class="nav-text">数据存储位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays"><span class="nav-number">3.2.2.</span> <span class="nav-text">Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84"><span class="nav-number">3.2.3.</span> <span class="nav-text">分配内存数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-Literals-Inline-Arrays%EF%BC%88%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E5%80%BC-%E8%A1%8C%E5%86%85%E6%95%B0%E7%BB%84%EF%BC%89"><span class="nav-number">3.2.4.</span> <span class="nav-text">Array Literals &#x2F; Inline Arrays（数组字面值&#x2F;行内数组）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Structs"><span class="nav-number">3.2.5.</span> <span class="nav-text">Structs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mappings"><span class="nav-number">3.2.6.</span> <span class="nav-text">Mappings</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%89%E5%8F%8A%E5%B7%A6%E5%80%BC%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">3.3.</span> <span class="nav-text">涉及左值的运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#delete"><span class="nav-number">3.3.1.</span> <span class="nav-text">delete</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.4.</span> <span class="nav-text">基本类型之间的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.4.1.</span> <span class="nav-text">隐式转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-number">3.4.2.</span> <span class="nav-text">类型推断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E4%BD%8D%E4%BB%A5%E5%8F%8A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">单位以及全局变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ether-Units"><span class="nav-number">4.1.</span> <span class="nav-text">Ether Units</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Time-Units"><span class="nav-number">4.2.</span> <span class="nav-text">Time Units</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%9D%97%E5%92%8C%E4%BA%A4%E6%98%93%E5%B1%9E%E6%80%A7"><span class="nav-number">4.2.1.</span> <span class="nav-text">区块和交易属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">4.2.2.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.3.</span> <span class="nav-text">数学和密码学函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%9B%B8%E5%85%B3"><span class="nav-number">4.2.4.</span> <span class="nav-text">地址相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E7%BA%A6%E7%9B%B8%E5%85%B3"><span class="nav-number">4.2.5.</span> <span class="nav-text">合约相关</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">表达式和控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">控制结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">函数调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">5.2.1.</span> <span class="nav-text">内部函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="nav-number">5.2.2.</span> <span class="nav-text">外部函数调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87new%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6"><span class="nav-number">5.2.3.</span> <span class="nav-text">通过new来创建合约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">5.2.4.</span> <span class="nav-text">赋值操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EArrays%E5%92%8CStructs%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">5.2.5.</span> <span class="nav-text">关于Arrays和Structs的一些问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="nav-number">5.3.</span> <span class="nav-text">作用域和声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9AAssert-Require-Revert-and-Exceptions"><span class="nav-number">5.4.</span> <span class="nav-text">错误处理：Assert, Require, Revert and Exceptions</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%88%E7%BA%A6"><span class="nav-number">6.</span> <span class="nav-text">合约</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8CGetters"><span class="nav-number">6.1.</span> <span class="nav-text">可见性和Getters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Getter%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">Getter函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="nav-number">6.3.</span> <span class="nav-text">函数修改器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">6.4.</span> <span class="nav-text">常状态变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">6.5.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#View-Functions"><span class="nav-number">6.5.1.</span> <span class="nav-text">View Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pure-Functions"><span class="nav-number">6.5.2.</span> <span class="nav-text">Pure Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fallback-Function"><span class="nav-number">6.5.3.</span> <span class="nav-text">Fallback Function</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="nav-number">6.5.4.</span> <span class="nav-text">方法重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">6.6.</span> <span class="nav-text">事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">6.7.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E5%9F%BA%E5%90%88%E7%BA%A6%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">6.7.1.</span> <span class="nav-text">为基合约设置参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E9%92%BB%E7%9F%B3%E9%97%AE%E9%A2%98"><span class="nav-number">6.7.2.</span> <span class="nav-text">多继承的钻石问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9B%B8%E5%90%8C%E5%90%8D%E7%A7%B0%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-number">6.7.3.</span> <span class="nav-text">继承相同名称不同类型的成员</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6"><span class="nav-number">6.8.</span> <span class="nav-text">抽象合约</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.9.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Libraries"><span class="nav-number">6.10.</span> <span class="nav-text">Libraries</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-For"><span class="nav-number">6.11.</span> <span class="nav-text">Using For</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="kaiktang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">kaiktang</p>
  <div class="site-description" itemprop="description">学而后知不足</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:tomkklalala@qq.com" title="E-Mail → mailto:tomkklalala@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">kaiktang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://kaiktang.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://kaiktang.github.io/2018/03/12/%E5%AD%A6%E4%B9%A0Solidity/";
    this.page.identifier = "2018/03/12/学习Solidity/";
    this.page.title = "学习Solidity";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://kaiktang.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
