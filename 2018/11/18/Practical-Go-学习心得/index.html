<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kaiktang.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1}},"activeClass":"disqus"},"algolia":{"appID":"FBQ33HXA0Q","apiKey":"5a256d1a0d5075a6a17b29fbae8cdbdc","indexName":"blog","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Practical Go 学习心得Practical Go: Real world advice for writing maintainable Go programs Go编程的原则 简单性 可读性 生产力  变量命名好的变量命名应该有如下几个特质：  简洁（concise） 表达力强（descriptive）：应该介绍变量的应用而不是变量的内容。 可预测的（predictable）：应该能够">
<meta name="keywords" content="go">
<meta property="og:type" content="article">
<meta property="og:title" content="Practical Go 学习心得">
<meta property="og:url" content="http://kaiktang.github.io/2018/11/18/Practical-Go-学习心得/index.html">
<meta property="og:site_name" content="TomKK&#39;s blogs">
<meta property="og:description" content="Practical Go 学习心得Practical Go: Real world advice for writing maintainable Go programs Go编程的原则 简单性 可读性 生产力  变量命名好的变量命名应该有如下几个特质：  简洁（concise） 表达力强（descriptive）：应该介绍变量的应用而不是变量的内容。 可预测的（predictable）：应该能够">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-06T06:57:21.491Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Practical Go 学习心得">
<meta name="twitter:description" content="Practical Go 学习心得Practical Go: Real world advice for writing maintainable Go programs Go编程的原则 简单性 可读性 生产力  变量命名好的变量命名应该有如下几个特质：  简洁（concise） 表达力强（descriptive）：应该介绍变量的应用而不是变量的内容。 可预测的（predictable）：应该能够">

<link rel="canonical" href="http://kaiktang.github.io/2018/11/18/Practical-Go-学习心得/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Practical Go 学习心得 | TomKK's blogs</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8714a47efb513991b4862eafeadb6a3d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TomKK's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://kaiktang.github.io/2018/11/18/Practical-Go-学习心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="TomKK">
      <meta itemprop="description" content="学而后知不足">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TomKK's blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Practical Go 学习心得
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-18 14:53:15" itemprop="dateCreated datePublished" datetime="2018-11-18T14:53:15+08:00">2018-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-01-06 14:57:21" itemprop="dateModified" datetime="2019-01-06T14:57:21+08:00">2019-01-06</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2018/11/18/Practical-Go-学习心得/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2018/11/18/Practical-Go-学习心得/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Practical-Go-学习心得"><a href="#Practical-Go-学习心得" class="headerlink" title="Practical Go 学习心得"></a>Practical Go 学习心得</h1><p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_introduction" target="_blank" rel="noopener">Practical Go: Real world advice for writing maintainable Go programs</a></p>
<h1 id="Go编程的原则"><a href="#Go编程的原则" class="headerlink" title="Go编程的原则"></a>Go编程的原则</h1><ol>
<li>简单性</li>
<li>可读性</li>
<li>生产力</li>
</ol>
<h1 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h1><p>好的变量命名应该有如下几个特质：</p>
<ol>
<li>简洁（concise）</li>
<li>表达力强（descriptive）：应该介绍变量的应用而不是变量的内容。</li>
<li>可预测的（predictable）：应该能够从变量名中猜测出他大概的用法。</li>
</ol>
<h2 id="变量名的长度"><a href="#变量名的长度" class="headerlink" title="变量名的长度"></a>变量名的长度</h2><blockquote>
<p>一个变量使用的地方离它声明的地方越远，那么它变量名的长度就应该越长。</p>
</blockquote>
<ol>
<li>当变量的最近一次使用和它的声明离得很近，那么短变量名也是可以接受的。</li>
<li>变量的长度越长提供的信息就应该更多。</li>
<li>变量的名字中不要包含变量的类型信息，比如：userMap等</li>
<li>常量应该用来描述它们所持有的值，而不是它的用法。</li>
<li>分支和循环变量使用单字母变量名。函数参数和返回值使用单个单词的变量名。包级变量的变量名应该由多个单词组成。</li>
<li>方法名、包名和接口名应该使用单个单词。</li>
<li>记住当使用包内的资源的时候，调用者必须要加上包名，所以可以好好利用包名。</li>
</ol>
<h2 id="上下文是关键"><a href="#上下文是关键" class="headerlink" title="上下文是关键"></a>上下文是关键</h2><p>比如一个代表数组下标的变量，在作为循环变量的时候使用i就挺好，而在函数中作为参数的时候，可能使用index会更具表现力。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SNMP)</span> <span class="title">Fetch</span><span class="params">(oid []<span class="keyword">int</span>, index <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="使用一致的声明风格"><a href="#使用一致的声明风格" class="headerlink" title="使用一致的声明风格"></a>使用一致的声明风格</h2><ul>
<li><p>当仅仅声明而不初始化一个变量的时候，使用<code>var</code>。当声明一个会在函数中被显式声明的变量的时候，使用<code>var</code>关键字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> players <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> things []Thing <span class="comment">// an empty slice of Things</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thing Thing    <span class="comment">// empty Thing struct</span></span><br><span class="line">json.Unmarshall(reader, &amp;thing)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当在声明的同时初始化了变量的时候，应该使用<code>:=</code>。明确告诉读者，我们不要零值。</p>
</li>
</ul>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><ol>
<li><p>注释应该解释这段代码做了什么事情。</p>
<ul>
<li>这种适合在public的代码外标注</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open opens the named file for reading.</span></span><br><span class="line"><span class="comment">// If successful, methods on the returned file can be used for reading.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注释应该解释这段代码是怎么做的这些事。</p>
<ul>
<li>这种一般适合在方法内部标注</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// queue all dependant actions</span></span><br><span class="line"><span class="keyword">var</span> results []<span class="keyword">chan</span> error</span><br><span class="line"><span class="keyword">for</span> _, dep := <span class="keyword">range</span> a.Deps &#123;</span><br><span class="line">        results = <span class="built_in">append</span>(results, execute(seen, dep))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注释应该解释这段代码为什么要做这些事。</p>
<ul>
<li>这种类型的注释是不能被前两种所取代的，同时也不能取代前两种。主要用来解释导致执行这段代码的外部因素。注释用来解释上下文。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;v2.Cluster_CommonLbConfig&#123;</span><br><span class="line">	<span class="comment">// Disable HealthyPanicThreshold</span></span><br><span class="line">        HealthyPanicThreshold: &amp;envoy_type.Percent&#123;</span><br><span class="line">        	Value: <span class="number">0</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例中，注释解释了将Value设为0，将会导致使HealthyPanicThreshold失效。</p>
</li>
</ol>
<h2 id="变量和常量上的注释应该描述他们的内容而不是他们的目的"><a href="#变量和常量上的注释应该描述他们的内容而不是他们的目的" class="headerlink" title="变量和常量上的注释应该描述他们的内容而不是他们的目的"></a>变量和常量上的注释应该描述他们的内容而不是他们的目的</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StatusContinue           = <span class="number">100</span> <span class="comment">// RFC 7231, 6.2.1</span></span><br><span class="line">    StatusSwitchingProtocols = <span class="number">101</span> <span class="comment">// RFC 7231, 6.2.2</span></span><br><span class="line">    StatusProcessing         = <span class="number">102</span> <span class="comment">// RFC 2518, 10.1</span></span><br><span class="line"></span><br><span class="line">    StatusOK                 = <span class="number">200</span> <span class="comment">// RFC 7231, 6.3.1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>对于那些没有初始值的变量，注释应该说明谁负责初始化该变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sizeCalculationDisabled indicates whether it is safe</span></span><br><span class="line"><span class="comment">// to calculate Types' widths and alignments. See dowidth.</span></span><br><span class="line"><span class="keyword">var</span> sizeCalculationDisabled <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
<p>上例中就告诉读者，dowidth方法负责维护该变量的状态。</p>
<h2 id="始终为公共符号写文档"><a href="#始终为公共符号写文档" class="headerlink" title="始终为公共符号写文档"></a>始终为公共符号写文档</h2><ul>
<li>任何除了又明显又短的公开方法都必须写注释。</li>
<li>任何在库中的方法都需要被注释，无论复杂度和长度。</li>
<li>不需要为那些实现自接口的的方法写注释。</li>
</ul>
<blockquote>
<p>在写一个方法之前先写注释去描述这个方法。如果你发现很难写出注释，那么意味着你将写出难懂的代码。</p>
</blockquote>
<h2 id="不要为糟糕的代码写注释，重写它"><a href="#不要为糟糕的代码写注释，重写它" class="headerlink" title="不要为糟糕的代码写注释，重写它"></a>不要为糟糕的代码写注释，重写它</h2><p>当发现问题的时候，使用TODO来标记提醒自己未来去修复他。</p>
<blockquote>
<p>// TODO(dfc) this is O(N^2), find a faster way to do this.</p>
</blockquote>
<h2 id="如果需要注释一大段代码，不如重构它"><a href="#如果需要注释一大段代码，不如重构它" class="headerlink" title="如果需要注释一大段代码，不如重构它"></a>如果需要注释一大段代码，不如重构它</h2><p>好的代码不需要注释也能看懂。</p>
<p>一个函数应该只做一件事情，如果你正在为一段和其他函数不太相关的代码写注释，你可能需要提取这些代码为函数。</p>
<p>当函数被拆分的小而专精时，函数名就已经是最好的注释。</p>
<h1 id="包的设计"><a href="#包的设计" class="headerlink" title="包的设计"></a>包的设计</h1><p>模块之间应该不暴露任何不重要的东西，并且他们不依赖其他模块的实现。</p>
<p>一个好的Go的包应该努力降低源码的耦合度，降低修改代码时带来的级联的影响。</p>
<h2 id="一个好的设计应该从包名开始"><a href="#一个好的设计应该从包名开始" class="headerlink" title="一个好的设计应该从包名开始"></a>一个好的设计应该从包名开始</h2><p>包名应该体现它提供了什么，而不是它包含了什么</p>
<h3 id="好的包名应该（在项目内）是唯一的"><a href="#好的包名应该（在项目内）是唯一的" class="headerlink" title="好的包名应该（在项目内）是唯一的"></a>好的包名应该（在项目内）是唯一的</h3><p>包名应该来自该设计该包的目的，如果你发现两个包需要相同的名称，那么可能：</p>
<ol>
<li>包的名称太泛指。</li>
<li>两个包可能功能有重叠，考虑合并两个包。</li>
</ol>
<h3 id="避免像base，common或者util这样的包名"><a href="#避免像base，common或者util这样的包名" class="headerlink" title="避免像base，common或者util这样的包名"></a>避免像<code>base</code>，<code>common</code>或者<code>util</code>这样的包名</h3><p>这样的包一般都是为了共用工具方法避免循环引用而创建的。</p>
<p>建议应该通过分析这些工具方法他们都是在哪里被调用的，然后尝试把他们移到他们调用者的包里去。即使这样会涉及一些复制重复代码，但是这也比在两个包之间引入依赖要好。</p>
<blockquote>
<p>一些小重复代码比错误的抽象好太多。</p>
</blockquote>
<p>对于那些真正提供工具的包，建议使用负数的名称，比如：<code>strings</code>等。</p>
<p>比如，像<code>net/http</code>包，并没有包含<code>client</code>和<code>server</code>这样的子包，而是包含<code>client.go</code>和<code>server.go</code>这样的文件，每个文件里面都有他们各自的类型，还有一个<code>tansport.go</code>文件，这里面包含了通用的消息传输的代码。</p>
<blockquote>
<p>注意：一个标识符包含了包名。</p>
<ul>
<li>比如<code>net/http</code>包内的<code>Get</code>方法当在外部被访问的时候，应该是<code>http.Get</code>。</li>
<li><code>strings</code>包里的<code>Reader</code>类型被别的包引入的时候变为了<code>strings.Reader</code>。</li>
<li><code>net</code>包里的<code>Error</code>接口很明显是关于网络的错误。</li>
</ul>
</blockquote>
<h2 id="应该早点return而不是更深的嵌套"><a href="#应该早点return而不是更深的嵌套" class="headerlink" title="应该早点return而不是更深的嵌套"></a>应该早点return而不是更深的嵌套</h2><ul>
<li><p>早return的风格</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.lastRead &lt;= opInvalid &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b.off &gt;= <span class="keyword">int</span>(b.lastRead) &#123;</span><br><span class="line">		b.off -= <span class="keyword">int</span>(b.lastRead)</span><br><span class="line">	&#125;</span><br><span class="line">	b.lastRead = opInvalid</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种风格能够保证成功路径的代码随着判断条件的增多是一直垂直向下延伸的。</p>
</li>
<li><p>嵌套的风格</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">UnreadRune</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b.lastRead &gt; opInvalid &#123;</span><br><span class="line">		<span class="keyword">if</span> b.off &gt;= <span class="keyword">int</span>(b.lastRead) &#123;</span><br><span class="line">			b.off -= <span class="keyword">int</span>(b.lastRead)</span><br><span class="line">		&#125;</span><br><span class="line">		b.lastRead = opInvalid</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">"bytes.Buffer: UnreadRune: previous operation was not a successful ReadRune"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种风格的代码会导致成功路径的代码随着判断条件的增多不断地被向右移动。这样风格的代码让条件判断和返回语句离得太远，这样让维护者或者读者阅读更加困难。</p>
</li>
</ul>
<h2 id="利用零值"><a href="#利用零值" class="headerlink" title="利用零值"></a>利用零值</h2><p>比如<code>sync.Mutex</code>类型包含了两个没有导出的整数字段，代表了互斥信号量的内部状态，作者充分利用了数值类型零值为0的特点，使得<code>sync.Mutex</code>类型被使用的时候不需要被显式的初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu  sync.Mutex</span><br><span class="line">	val <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i MyInt</span><br><span class="line"></span><br><span class="line">	<span class="comment">// i.mu is usable without explicit initialisation.</span></span><br><span class="line">	i.mu.Lock()</span><br><span class="line">	i.val++</span><br><span class="line">	i.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个例子是<code>bytes.Buffer</code>这个类型，你可以不用显式初始化它，只需要声明它就能使用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">	b.WriteString(<span class="string">"Hello, world!\n"</span>)</span><br><span class="line">	io.Copy(os.Stdout, &amp;b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于在runtime包里定义的slice类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">        array *[...]T <span class="comment">// pointer to the underlying array</span></span><br><span class="line">        <span class="built_in">len</span>   <span class="keyword">int</span></span><br><span class="line">        <span class="built_in">cap</span>   <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// s := make([]string, 0)</span></span><br><span class="line">	<span class="comment">// s := []string&#123;&#125;</span></span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="string">"Hello"</span>)</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="string">"world"</span>)</span><br><span class="line">	fmt.Println(strings.Join(s, <span class="string">" "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是注意注释里的两种方式出来的变量虽然都是零值，但是不相等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> s2 []<span class="keyword">string</span></span><br><span class="line">	fmt.Println(reflect.DeepEqual(s1, s2)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于未初始化的变量虽然为nil，可以非常方便的提供默认值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	path <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Config)</span> <span class="title">Path</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"/usr/home"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c.path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c1 *Config</span><br><span class="line">	<span class="keyword">var</span> c2 = &amp;Config&#123;</span><br><span class="line">		path: <span class="string">"/export"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(c1.Path(), c2.Path())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="避免包级别的状态"><a href="#避免包级别的状态" class="headerlink" title="避免包级别的状态"></a>避免包级别的状态</h2><p>有两个非常棒的方式来达到降低耦合度：</p>
<ol>
<li>使用接口。</li>
<li>避免使用全局变量。</li>
</ol>
<p>使用开放的全局变量会使得该变量非常容易被修改，导致不稳定因素。</p>
<p>如果你想要解决全局变量带来的耦合，可以通过：</p>
<ol>
<li>将一个结构体依赖的相关的变量放到它的成员变量里面。</li>
<li>使用接口来屏蔽实现，降低耦合。</li>
</ol>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>一个包应该有一个清晰的目标。如果你的 项目是一个库，那么应该提供只提供一件事，比如说解析XML或者日志库。你应该避免将多个不同目的的包合并进一个单独的包，这会帮助你避免产生类似<code>common</code>这样的库。</p>
<h2 id="考虑使用更少但是更大的包"><a href="#考虑使用更少但是更大的包" class="headerlink" title="考虑使用更少但是更大的包"></a>考虑使用更少但是更大的包</h2><p>和其他语言不同，Go语言里面只有两种访问控制符，public和private，所以当一个功能被拆到多个包里的时候，势必会导致很多接口都被迫的被开放为Public，而且这样的API层次太浅，并不是面向用户的。</p>
<p>所以推荐使用更少，更大的包来放所有相关的功能。要求每个文件夹内都应该有源代码，除了<code>cmd</code>等。</p>
<h3 id="通过import语句来组织代码"><a href="#通过import语句来组织代码" class="headerlink" title="通过import语句来组织代码"></a>通过import语句来组织代码</h3><p>如果你是根据代码为调用者提供的内容来组织包，那么你是否也应该同样来组织包内的文件呢？</p>
<p>你怎么知道什么时候将代码分散到多个<code>.go</code>文件中，你怎么知道你是否拆的太过，应该合并几个为一个<code>.go</code>文件呢？</p>
<ul>
<li>每个包先从一个<code>.go</code>文件开始。并且让这个文件的文件名和包名一致。比如：<code>http</code>包对应的文件下下应该有个<code>http.go</code>文件。</li>
<li>当你的包逐渐变大，你应该决定是否将不同的职责拆分到不同的文件中去。比如：<code>messages.go</code>里面包含<code>Request</code>和<code>Response</code>类型，<code>client.go</code>包含<code>Client</code>类型，<code>server.go</code>里面包含了<code>Server</code>类型。</li>
<li>当你发现你的几个文件中有着相似的<code>import</code>声明，那么考虑将他们合并。</li>
<li>不同的文件应该负责包中不同的领域的工作。</li>
</ul>
<blockquote>
<p>推荐使用名词来作为源代码文件的名称。</p>
<p>注意：Go的编译器在编译的时候会并行的编译各个包。而在每个包内，编译器会并行的编译各个方法。所以改变包内的代码结构并不会影响编译时间。</p>
</blockquote>
<h3 id="多用内部测试，而不是外部测试"><a href="#多用内部测试，而不是外部测试" class="headerlink" title="多用内部测试，而不是外部测试"></a>多用内部测试，而不是外部测试</h3><p>go工具支持把你的<code>testing</code>包放在两个地方。</p>
<ul>
<li>假设你的包叫<code>http2</code>，你可以把<code>http2_test.go</code>文件放到包内，那么编译的时候会把该文件作为包的一部分被编译进去，这被称为“内部测试”。</li>
<li>也可以使用一个以test结尾的特殊的包名，比如<code>http_test</code>包，这样在编译的时候，测试代码仿佛就是用户从外部调用接口，这样的方式被称为“外部测试”。</li>
</ul>
<p>建议使用内部测试来写单元测试，这可以使你能够直接的测试那些方法，而不用从外部引用。</p>
<p>但是你应该把你的样例测试代码放到外部的包中，因为这样在生成文档的时候，测试代码中有着正确的包名前缀，方便直接复制来用。</p>
<h3 id="使用internal包来减少开放的API"><a href="#使用internal包来减少开放的API" class="headerlink" title="使用internal包来减少开放的API"></a>使用<code>internal</code>包来减少开放的API</h3><p>如果你的项目包含了很多包，他们的接口只希望将接口暴露给其他本项目内的包的时候。你可以使用<code>interna/</code>这样一个特殊的目录，放在里面的代码对于本项目是public的，但是对于其他项目是private的。</p>
<p>为了创建这样一个包，应该将目录命名为<code>internal</code>或者一个名为<code>internal</code>的目录下。当go命令看到导入了一个包路径中包含<code>internal</code>，那么这代表这个包仅仅是在internal的父目录域下可见。</p>
<p>比如：<code>.../a/b/c/internal/d/e/f</code>只能被在<code>/a/b/c</code>目录下的代码所导入，而不能被<code>.../a/b</code>或者<code>.../a</code>或者其他仓库所导入。</p>
<h2 id="让包内的main越小越好"><a href="#让包内的main越小越好" class="headerlink" title="让包内的main越小越好"></a>让包内的main越小越好</h2><p>因为<code>main.main</code>是一个单例，只会被执行一次，而且对于在main函数内的逻辑很难写单元测试，所以建议让main函数内的逻辑越少越好。</p>
<blockquote>
<p>main应该用来解析flags，开放对数据库，日志的连接，然后将执行交给更高层次的对象。</p>
</blockquote>
<h1 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h1><p>对于上面提到的建议其实都可以不那么严格，因为这些都是可以在不影响向下兼容性的情况下被修复。但是API的设计需要更加严谨， 因为一旦有用户已经在使用这些API，那么这些API就不能再动了。</p>
<h2 id="将API设计成很难用错"><a href="#将API设计成很难用错" class="headerlink" title="将API设计成很难用错"></a>将API设计成很难用错</h2><p>API应该很容易使用而且很难被用错。</p>
<h3 id="注意那些接收几个相同类型参数的函数"><a href="#注意那些接收几个相同类型参数的函数" class="headerlink" title="注意那些接收几个相同类型参数的函数"></a>注意那些接收几个相同类型参数的函数</h3><p>让我们比较一下下面这两个方法签名：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">CopyFile</span><span class="params">(to, from <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>对于Max方法，两个参数是可交换的，但是对于CopyFile的两个参数顺序不同将会导致完全不同的行为，而检查CopyFile是否被正确使用只能通过查阅文档。</p>
<p>解决这个问题的一种方式为：使用一个helper类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Source <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(src Source)</span> <span class="title">CopyTo</span><span class="params">(dest <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> CopyFile(dest, <span class="keyword">string</span>(src))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> from Source = <span class="string">"presentation.md"</span></span><br><span class="line">	from.CopyTo(<span class="string">"/tmp/backup"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>那些接收相同类型参数的函数非常容易被用错。</p>
</blockquote>
<h2 id="为默认用例设计API"><a href="#为默认用例设计API" class="headerlink" title="为默认用例设计API"></a>为默认用例设计API</h2><p>你不应该要求调用者提供他们不关心的参数。</p>
<h3 id="不建议使用nil作为参数"><a href="#不建议使用nil作为参数" class="headerlink" title="不建议使用nil作为参数"></a>不建议使用nil作为参数</h3><p>以<code>net/http</code>包为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> http</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListenAndServe listens on the TCP network address addr and then calls</span></span><br><span class="line"><span class="comment">// Serve with handler to handle requests on incoming connections.</span></span><br><span class="line"><span class="comment">// Accepted connections are configured to enable TCP keep-alives.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The handler is typically nil, in which case the DefaultServeMux is used.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br></pre></td></tr></table></figure>
<p><code>ListenAndServe</code>接收两个参数，第一个为监听请求来源的TCP地址，第二个参数用来处理接收到的HTTP请求。第二个参数可以为nil，代表应该使用<code>http.DefaultServeMux</code>作为默认handler。</p>
<p>也就是下面两种写放做的事情是一样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p><code>http</code>包内有一个<code>http.Serve</code>方法，分别接受<code>listener</code>和<code>handler</code>。事实上，就是它实现了如果handler为nil，那么使用DefaultServeMux的逻辑。所以可以想象<code>ListenAndServe</code>的实现大概是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	l, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> l.Close()</span><br><span class="line">	<span class="keyword">return</span> Serve(l, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不推荐在同一个方法签名中同时出现可为nil和不为nil的参数。</p>
<p>对于上例，不建议使用下面两种写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">"/htdocs"</span>)</span><br><span class="line">http.Handle(<span class="string">"/"</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">// and</span></span><br><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">"/htdocs"</span>)</span><br><span class="line">http.Handle(<span class="string">"/"</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, http.DefaultServeMux)</span><br></pre></td></tr></table></figure>
<p>建议使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = http.Dir(<span class="string">"/htdocs"</span>)</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">http.Handle(<span class="string">"/"</span>, http.FileServer(root))</span><br><span class="line">http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>避免在public API中设置只为测试使用的参数。</p>
<p>应该使用public的包装类来隐藏这些参数，然后使用test范围里的helper类来设置这个属性。</p>
<p>TomKK：因为test代码应该是在和待测试的方法在同一个包内可以访问私有属性，这样对于用户屏蔽了这些测试属性，又可以修改他们。</p>
</blockquote>
<h3 id="推荐使用可变数量参数而不是切片类型"><a href="#推荐使用可变数量参数而不是切片类型" class="headerlink" title="推荐使用可变数量参数而不是切片类型"></a>推荐使用可变数量参数而不是切片类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShutdownVMs</span><span class="params">(ids []<span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>像上面这种签名的函数，可能被调用的时候只需要传入一个参数，但是调用者必须将这一个参数强行包装成slice然后传入，这样非常不友好。而且slice类型的参数是能够接受nil的，这样会让函数多出一些多余的判断逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> svc.MaxConnections &gt; <span class="number">0</span> || svc.MaxPendingRequests &gt; <span class="number">0</span> || svc.MaxRequests &gt; <span class="number">0</span> || svc.MaxRetries &gt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// apply the non zero parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码的书写方式，会随着需要判断的参数的增长而越来越长，通过可变数量参数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anyPostive indicates if any value is greater than zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyPositive</span><span class="params">(values ...<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个函数能够非常好的减少判断语句，让程序语句变的更加优雅：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> anyPositive(svc.MaxConnections, svc.MaxPendingRequests, svc.MaxRequests, svc.MaxRetries) &#123;</span><br><span class="line">        <span class="comment">// apply the non zero parameters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，因为动态参数的限制，用户可以这样调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> anyPositive() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这样这个函数就会恒返回false，如果这样的调用是不允许的，那么我们可以通过修改函数签名来让编译器为我们限制用户的行为。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anyPostive indicates if any value is greater than zero.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyPositive</span><span class="params">(first <span class="keyword">int</span>, rest ...<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> first &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> rest &#123;</span><br><span class="line">		<span class="keyword">if</span> v &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="让函数自己定义他们需要的行为"><a href="#让函数自己定义他们需要的行为" class="headerlink" title="让函数自己定义他们需要的行为"></a>让函数自己定义他们需要的行为</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the file f.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(f *os.File, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>像这样的函数就是很不好的，有如下几个弊端：</p>
<ol>
<li>如果未来不只想要将文件写入磁盘文件中，而是想要将文件写入网络，那么就需要修改函数的签名影响所有的调用者。</li>
<li>该函数签名也很不利于写测试用例，因为我们每次都会生成文件，并且需要保证文件被写入一个临时目录并且在每次测试后将临时文件删除。并且为了验证该测试用例，在将内容输出到磁盘后，我们必须再次读取文件的内容，这样才能证明测试通过。</li>
</ol>
<p>这是因为<code>*os.File</code>中定义了很多和<code>Save</code>方法无关的方法。我们应该让<code>Save</code>方法中只包含它所需要的行为（接口隔离原则）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// ReadWriterCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(rwc io.ReadWriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>除了接口隔离原则，还要单一职责原则，所以还可以更加优化。</p>
<p>因为<code>Save</code>方法内不太可能会去读取文件的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// WriteCloser.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(wc io.WriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>但是这种签名中包含了写入和关闭两种行为，这就涉及了一个问题，什么时候应该去关闭文件，该方法是否需要改行为：</p>
<ul>
<li>可能用户想要在写入成功后马上关闭流。</li>
<li>可能用户想要在写入成功后还想要向其中在向其中写入信息。</li>
<li>可能用户想要在写入出错后立刻关闭流。</li>
</ul>
<p>所以作为函数的设计者，我们很难猜测用户的使用场景。所以我们应该更加优化函数的签名设计：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save writes the contents of doc to the supplied</span></span><br><span class="line"><span class="comment">// Writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(w io.Writer, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>
<p>该函数只需要一个写入方法就够了。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="检查错误"><a href="#检查错误" class="headerlink" title="检查错误"></a>检查错误</h2><p>一个通用的准则就是：调用者在检查错误之前不应该相信函数返回的所有返回值。</p>
<p>大多数情况下，用户只检查返回的err是否为nil即可，但是对于那些和外界世界交互的接口等，可能需要知道err真正的原因，比如：网络程序，以此来决定是否要重发请求。</p>
<p>对于这种需求，一个常见的设计就是将错误的类型作为public公开，然后调用者通过使用类型断言来判断错误类型，但是这种设计方式会导致几个不太好的问题：</p>
<ul>
<li>public的错误类型会增加包的接口范围。</li>
<li>新实现的接口必须要返回那些声明的public的错误类型，即使真正的错误和它并不太匹配。</li>
<li>错误类型不能被修改，不然会引起不兼容变动。</li>
</ul>
<p>这种让用户类型断言错误是否为某一特定错误的设计本质上和让用户去通过判断<code>Error()</code>返回的字符串格式一样僵硬。</p>
<h3 id="断言错误的行为特征而不是类型"><a href="#断言错误的行为特征而不是类型" class="headerlink" title="断言错误的行为特征而不是类型"></a>断言错误的行为特征而不是类型</h3><p>这个建议更加契合Go语言<code>has a</code>的设计理念，而不是继承类语言的<code>is a</code>的理念。下面是一个样例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isTimeout</span><span class="params">(err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">        <span class="keyword">type</span> timeout <span class="keyword">interface</span> &#123;</span><br><span class="line">                Timeout() <span class="keyword">bool</span></span><br><span class="line">        &#125;</span><br><span class="line">        te, ok := err.(timeout)</span><br><span class="line">        <span class="keyword">return</span> ok &amp;&amp; te.Timeout()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用者通过调用<code>isTimeout</code>去判断该错误是否和超时有关，这样能够对调用者屏蔽真实的错误类型。</p>
<h2 id="错误常量值"><a href="#错误常量值" class="headerlink" title="错误常量值"></a>错误常量值</h2><p>哨岗错误（常量错误值）并不好，但是有时很有必要，但是最好把它们设置为常量（常量错误值）。</p>
<p><code>io.EOF</code>就是一个典型的哨岗错误值，但是它却不是一个常量，而是一个任何代码都可以修改的公开变量。这会导致一些很奇怪的现象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(io.EOF == io.EOF) <span class="comment">// true</span></span><br><span class="line">x := io.EOF</span><br><span class="line">fmt.Println(io.EOF == x)      <span class="comment">// true</span></span><br><span class="line">	</span><br><span class="line">io.EOF = fmt.Errorf(<span class="string">"whoops"</span>)</span><br><span class="line">fmt.Println(io.EOF == io.EOF) <span class="comment">// true</span></span><br><span class="line">fmt.Println(x == io.EOF)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>另一个问题是<code>io.EOF</code>表现为一个单例，而不是常量。即使我们使用和包中完全一样的定义方式，他们也不能兼容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := errors.New(<span class="string">"EOF"</span>)   <span class="comment">// io/io.go line 38</span></span><br><span class="line">fmt.Println(io.EOF == err) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在Go语言中，只要任何实现了<code>Error() string</code>方法的类型都能能算作是错误类型。</p>
<p>所以，我们为了解决上面的问题我们可以这样来设计：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Error)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> <span class="keyword">string</span>(e) &#125;</span><br></pre></td></tr></table></figure>
<p>对于上面提出的问题：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eof = Error(<span class="string">"eof"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reader)</span> <span class="title">Read</span><span class="params">([]<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, eof</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> r Reader</span><br><span class="line">        _, err := r.Read([]<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">        fmt.Println(err == eof) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过消除错误来消除错误处理"><a href="#通过消除错误来消除错误处理" class="headerlink" title="通过消除错误来消除错误处理"></a>通过消除错误来消除错误处理</h2><p>比提升错误处理语法更好的是根本不需要处理错误。</p>
<h3 id="Counting-lines"><a href="#Counting-lines" class="headerlink" title="Counting lines"></a>Counting lines</h3><p>比如下面这个实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		br    = bufio.NewReader(r)</span><br><span class="line">		lines <span class="keyword">int</span></span><br><span class="line">		err   error</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		_, err = br.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		lines++</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lines, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个奇怪的地方：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err = br.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">lines++</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在错误处理之前递增了lines。这是因为可能某个文件的末尾没有换行符，这样br将读不出内容那么最后一行将不能被统计进去。但是其实这样也是不完美的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountLines</span><span class="params">(r io.Reader)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	sc := bufio.NewScanner(r)</span><br><span class="line">	lines := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> sc.Scan() &#123;</span><br><span class="line">		lines++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用<code>bufio.NewScanner(r)</code>，能够将错误处理从我们的逻辑中剔除。而它底层其实也是使用的<code>bufio.Reader</code>，它能够扫描任何格式，但是默认扫描换行。它在检测到一行的内容并且没有遇到错误的时候才会返回<code>true</code>。</p>
<p>这样很好的处理了行末没有换行和空文件的特殊情况。并且让我们避免了判断是否读取遇到了错误。而且它还记住了第一个遇到的错误，替我们处理了<code>io.EOF</code>的情况（返回nil）。</p>
<blockquote>
<p>建议：如果你发现你需要处理很多难以忍受的错误处理，那么试图提取一些操作到helper类型中。</p>
</blockquote>
<h3 id="WriteResponse"><a href="#WriteResponse" class="headerlink" title="WriteResponse"></a>WriteResponse</h3><p>像上面那个例子中因为有<code>ioutil</code>之类的帮助类型的存在，使得我们能够避免一些错误处理。但是当我们处理一些较底层的网络协议的时候，使用原始的I/O来构建响应就是必须的了。</p>
<p>看下面这段http服务器中构建HTTP响应的代码片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key, Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Status <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code   <span class="keyword">int</span></span><br><span class="line">	Reason <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	_, err := fmt.Fprintf(w, <span class="string">"HTTP/1.1 %d %s\r\n"</span>, st.Code, st.Reason)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		_, err := fmt.Fprintf(w, <span class="string">"%s: %s\r\n"</span>, h.Key, h.Value)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _, err := fmt.Fprint(w, <span class="string">"\r\n"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = io.Copy(w, body)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 通过引入一个<code>errWriter</code>类型来避免大量的错误处理逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> errWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">	io.Writer</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errWriter)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> e.err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, e.err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">	n, e.err = e.Writer.Write(buf)</span><br><span class="line">	<span class="keyword">return</span> n, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteResponse</span><span class="params">(w io.Writer, st Status, headers []Header, body io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">	fmt.Fprintf(ew, <span class="string">"HTTP/1.1 %d %s\r\n"</span>, st.Code, st.Reason)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">		fmt.Fprintf(ew, <span class="string">"%s: %s\r\n"</span>, h.Key, h.Value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Fprint(ew, <span class="string">"\r\n"</span>)</span><br><span class="line">	io.Copy(ew, body)</span><br><span class="line">	<span class="keyword">return</span> ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过结构体来将错误处理的代码提取出来。</p>
<h2 id="只处理一个错误一次"><a href="#只处理一个错误一次" class="headerlink" title="只处理一个错误一次"></a>只处理一个错误一次</h2><p>不处理和处理一个错误多次都是不好的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteAll writes the contents of buf to the supplied writer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">        w.Write(buf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就丢弃了错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteAll</span><span class="params">(w io.Writer, buf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	_, err := w.Write(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"unable to write:"</span>, err) <span class="comment">// annotated error goes to log file</span></span><br><span class="line">		<span class="keyword">return</span> err                           <span class="comment">// unannotated error returned to caller</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而上面的代码在函数中输出了错误日志并且将错误返回了，而调用者拿到错误后很可能又会再出输出到日志，这样就处理了两次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteConfig</span><span class="params">(w io.Writer, conf *Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	buf, err := json.Marshal(conf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Printf(<span class="string">"could not marshal config: %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := WriteAll(w, buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(<span class="string">"could not write config: %v"</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以很可能在日志中就会呈现为这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unable to write: io.EOF</span><br><span class="line">could not write config: io.EOF</span><br></pre></td></tr></table></figure>
<p>但是第一条日志是没有上下文环境的。这样做无可厚非。</p>
<p>另一个情况是程序员在检测到错误后忘记return，因为我们在错误发生后无法信任所有其他返回值，所以忘记return可能导致很多隐蔽的错误。</p>
<h3 id="推荐在错误中加入上下文环境"><a href="#推荐在错误中加入上下文环境" class="headerlink" title="推荐在错误中加入上下文环境"></a>推荐在错误中加入上下文环境</h3><p>比如<code>json.Marshal(conf)</code>出错了，只报错提示marshal错误了就不是很具体，应该加入上下文：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf, err := json.Marshal(conf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Errorf(<span class="string">"could not marshal config: %v"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样能够加入更多的提示信息。</p>
<h3 id="使用github-com-pkg-errors包来包装错误"><a href="#使用github-com-pkg-errors包来包装错误" class="headerlink" title="使用github.com/pkg/errors包来包装错误"></a>使用github.com/pkg/errors包来包装错误</h3><p>使用<code>fmt.Errorf</code>已经能够很好的处理错误信息，但是它是以掩盖了错误源头的代价工作的。虽然前面说过隐藏真实的错误类型会让程序之间耦合更少，但是对于简单的错误处理而言：</p>
<ol>
<li>判断错误是否为nil</li>
<li>打印错误</li>
</ol>
<p>并不会影响什么。但是有些情况下，你需要从错误中恢复出根错误值，这时你可以使用这个errors包来处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	f, err := os.Open(path)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"open failed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	buf, err := ioutil.ReadAll(f)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"read failed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> buf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadConfig</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	home := os.Getenv(<span class="string">"HOME"</span>)</span><br><span class="line">	config, err := ReadFile(filepath.Join(home, <span class="string">".settings.xml"</span>))</span><br><span class="line">	<span class="keyword">return</span> config, errors.WithMessage(err, <span class="string">"could not read config"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, err := ReadConfig()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">        fmt.Printf(<span class="string">"original error: %T %v\n"</span>, errors.Cause(err), errors.Cause(err))</span><br><span class="line">		fmt.Printf(<span class="string">"stack trace:\n%+v\n"</span>, err)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将分别输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">could not read config: open failed: open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">original error: *os.PathError open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">stack trace:</span><br><span class="line">open /Users/dfc/.settings.xml: no such file or directory</span><br><span class="line">open failed</span><br><span class="line">main.ReadFile</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:16</span><br><span class="line">main.ReadConfig</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:29</span><br><span class="line">main.main</span><br><span class="line">        /Users/dfc/devel/practical-go/src/errors/readfile2.go:35</span><br><span class="line">runtime.main</span><br><span class="line">        /Users/dfc/go/src/runtime/proc.go:201</span><br><span class="line">runtime.goexit</span><br><span class="line">        /Users/dfc/go/src/runtime/asm_amd64.s:1333</span><br><span class="line">could not read config</span><br></pre></td></tr></table></figure>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>GoLang以其高并发特性闻名，编写他们的团队也在为Go的并发消耗更少的硬件资源上投入了很多的精力，但是如果没有好的使用，你很可能不能发挥出它的优势。</p>
<h2 id="让你自己保持忙碌或者自己做工作"><a href="#让你自己保持忙碌或者自己做工作" class="headerlink" title="让你自己保持忙碌或者自己做工作"></a>让你自己保持忙碌或者自己做工作</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">"Hello, GopherCon SG"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码中，最后一行的死循环会占据并浪费着CPU的资源。</p>
<p>那么我们如何去修复它呢？下面是一个建议：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		runtime.Gosched()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是不了解潜在问题的症状。</p>
<p>但是如果你是一个有经验的Go程序员，你应该会写出下面这种：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>该语句会一直阻塞在那里，但是并不占用CPU。</p>
<p>但是更好的做法是，既然在这里goroutine和主线程之间是有严格的同步关系的，那么不如就让主线程来做这件事情，而不是委派给别的协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(w, <span class="string">"Hello, GopherCon SG"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做会消除很多的状态追踪、channel通信等携程间通信的操作。</p>
<h2 id="让调用者去做并发"><a href="#让调用者去做并发" class="headerlink" title="让调用者去做并发"></a>让调用者去做并发</h2><p>比较下面两个方法签名的区别：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListDirectory returns the contents of dir.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, error)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListDirectory returns a channel over which</span></span><br><span class="line"><span class="comment">// directory entries will be published. When the list</span></span><br><span class="line"><span class="comment">// of entries is exhausted, the channel will be closed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>)</span> <span class="title">chan</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>
<p>前者是一个同步调用，会阻塞的去读取文件夹，并将文件夹中的内容读入一个slice，然后返回。对于一个很大的文件夹可能会导致阻塞非常长时间。</p>
<p>第二个版本是返回一个channel，里面会被放入文件夹中的内容，如果channel被关闭，那么意味着目录的内容已经读取完毕。但是第二个版本还是有两个问题：</p>
<ul>
<li>无法传达错误信息。调用者无法分辨是读取顺利完成了还是中途发生了错误。</li>
<li>无法主动停止读取的协程，只能不断循环去读取直到读取协程主动关闭通道。这在大目录的时候更省内存，但是并没有比第一个版本的运行速度上更快些。</li>
</ul>
<p>比较好的方案是通过回调函数的形式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListDirectory</span><span class="params">(dir <span class="keyword">string</span>, fn <span class="keyword">func</span>(<span class="keyword">string</span>)</span>)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议：如果你的方法启用了一个线程，那么你一定要提供了一个让调用者能够显示停止这个goroutine的方式。</p>
</blockquote>
<h2 id="不要启动一个不会停止的协程"><a href="#不要启动一个不会停止的协程" class="headerlink" title="不要启动一个不会停止的协程"></a>不要启动一个不会停止的协程</h2><p>有一个关于http服务器的例子，端口8080监听应用相关的内容，端口8001用来访问/debug/pprof。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	_ <span class="string">"net/http/pprof"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">go</span> http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux) <span class="comment">// debug</span></span><br><span class="line">	http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)                       <span class="comment">// app traffic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着项目的增长会不断有问题出现，我们先解决一部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> serveDebug()</span><br><span class="line">	serveApp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过拆分相关的逻辑到<code>serveApp</code>和<code>serveDebug</code>中，我们降低了main函数的耦合度，并且对于这两个函数我们把并发的任务留给了调用者。</p>
<p>但是这个项目有一些可操作性错误，比如如果<code>serveApp</code>返回了那么main函数也会返回，从而导致程序的关闭，然后再被别的进程重新启动。</p>
<p>但是<code>serveDebug</code>是工作在单独一个协程中的，并且如果它退出了，那么剩下的程序还是能够正常运行的。这样运维人员将不再能够得到运行数据。</p>
<p>我们想要确保的是，如果任何为该应用服务的协程退出了，我们将关闭整个应用程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> serveDebug()</span><br><span class="line">	<span class="keyword">go</span> serveApp()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在发生错误的时候使用<code>log.Fatal</code>。</p>
<p>但是这种方式有一些弊端：</p>
<ol>
<li>如果<code>ListenAndServe</code>返回了nil错误，<code>log.Fatal</code>将不会调用，那么该协程将退出，而应用程序不会退出。</li>
<li><code>log.Fatal</code>会调用<code>os.Exit</code>，而它会无条件的退出整个应用程序，这会导致defer不会被执行，并且其他的协程也不会被通知关闭。这让程序员很难去写单元测试。</li>
</ol>
<blockquote>
<p>建议：只在main函数和init中使用<code>log.Fatal</code></p>
</blockquote>
<p>我们真正想要的效果是当协程产生错误的时候将错误传递回协程的创建者，这样它就知道为什么那个协程会退出，之后再将整个进程干净的退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(<span class="string">"0.0.0.0:8080"</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> http.ListenAndServe(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveDebug()</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveApp()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := &lt;-done; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"error: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用一个通道去收集协程的返回状态。通道的的大小等于我们想要控制的协程的数目，这样发送到done通道不会导致阻塞。</p>
<p>因为没有一个安全的方式去close通道，所以我们不能使用<code>for range</code>，而是使用for循环代替。</p>
<p>现在我们已经能够等待各个协程干净的退出，并且将错误信息输出。只需要找到一个方式去转发来自第一个退出的协程的关闭信号给另一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(addr <span class="keyword">string</span>, handler http.Handler, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	s := http.Server&#123;</span><br><span class="line">		Addr:    addr,</span><br><span class="line">		Handler: handler,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		&lt;-stop <span class="comment">// wait for stop signal</span></span><br><span class="line">		s.Shutdown(context.Background())</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Fprintln(resp, <span class="string">"Hello, QCon!"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> serve(<span class="string">"0.0.0.0:8080"</span>, mux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serveDebug</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> serve(<span class="string">"127.0.0.1:8001"</span>, http.DefaultServeMux, stop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">2</span>)</span><br><span class="line">	stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveDebug(stop)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		done &lt;- serveApp(stop)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stopped <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">cap</span>(done); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := &lt;-done; err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"error: %v"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !stopped &#123;</span><br><span class="line">			stopped = <span class="literal">true</span></span><br><span class="line">			<span class="built_in">close</span>(stop)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当我们从done通道中收到一个值的时候，我们将关闭stop通道，这将导致所有等待的通道去关闭他们的<code>http.Server</code>，而这又会导致<code>ListenAndServe</code>的协程退出，一旦所有协程退出，整个进程也会干净的退出。</p>
<blockquote>
<p><a href="https://github.com/heptio/workgroup" target="_blank" rel="noopener">https://github.com/heptio/workgroup</a></p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_1" target="_blank" rel="noopener">1</a>. <a href="https://gaston.life/books/effective-programming/" target="_blank" rel="noopener">https://gaston.life/books/effective-programming/</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_2" target="_blank" rel="noopener">2</a>. <a href="https://talks.golang.org/2014/names.slide#4" target="_blank" rel="noopener">https://talks.golang.org/2014/names.slide#4</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_3" target="_blank" rel="noopener">3</a>. <a href="https://www.infoq.com/articles/API-Design-Joshua-Bloch" target="_blank" rel="noopener">https://www.infoq.com/articles/API-Design-Joshua-Bloch</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_1" target="_blank" rel="noopener">1</a>. <a href="https://www.lysator.liu.se/c/pikestyle.html" target="_blank" rel="noopener">https://www.lysator.liu.se/c/pikestyle.html</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_2" target="_blank" rel="noopener">2</a>. <a href="https://speakerdeck.com/campoy/understanding-nil" target="_blank" rel="noopener">https://speakerdeck.com/campoy/understanding-nil</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_3" target="_blank" rel="noopener">3</a>. <a href="https://www.youtube.com/watch?v=Ic2y6w8lMPA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=Ic2y6w8lMPA</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_4" target="_blank" rel="noopener">4</a>. <a href="https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88" target="_blank" rel="noopener">https://medium.com/@matryer/line-of-sight-in-code-186dd7cdea88</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_5" target="_blank" rel="noopener">5</a>. <a href="https://golang.org/doc/go1.4#internalpackages" target="_blank" rel="noopener">https://golang.org/doc/go1.4#internalpackages</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_6" target="_blank" rel="noopener">6</a>. <a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_7" target="_blank" rel="noopener">7</a>. <a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_8" target="_blank" rel="noopener">8</a>. <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_9" target="_blank" rel="noopener">9</a>. <a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201" target="_blank" rel="noopener">https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_10" target="_blank" rel="noopener">10</a>. <a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a></p>
<p><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_footnoteref_11" target="_blank" rel="noopener">11</a>. <a href="http://www.gopl.io/" target="_blank" rel="noopener">http://www.gopl.io/</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="TomKK WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="TomKK Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/09/25/《Go并发编程实战》读书笔记/" rel="prev" title="《Go并发编程实战》读书笔记">
      <i class="fa fa-chevron-left"></i> 《Go并发编程实战》读书笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/11/18/Go语言中的比较运算符/" rel="next" title="Go语言中的比较运算符">
      Go语言中的比较运算符 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Practical-Go-学习心得"><span class="nav-number">1.</span> <span class="nav-text">Practical Go 学习心得</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Go编程的原则"><span class="nav-number">2.</span> <span class="nav-text">Go编程的原则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量命名"><span class="nav-number">3.</span> <span class="nav-text">变量命名</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量名的长度"><span class="nav-number">3.1.</span> <span class="nav-text">变量名的长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上下文是关键"><span class="nav-number">3.2.</span> <span class="nav-text">上下文是关键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用一致的声明风格"><span class="nav-number">3.3.</span> <span class="nav-text">使用一致的声明风格</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注释"><span class="nav-number">4.</span> <span class="nav-text">注释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量和常量上的注释应该描述他们的内容而不是他们的目的"><span class="nav-number">4.1.</span> <span class="nav-text">变量和常量上的注释应该描述他们的内容而不是他们的目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#始终为公共符号写文档"><span class="nav-number">4.2.</span> <span class="nav-text">始终为公共符号写文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不要为糟糕的代码写注释，重写它"><span class="nav-number">4.3.</span> <span class="nav-text">不要为糟糕的代码写注释，重写它</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果需要注释一大段代码，不如重构它"><span class="nav-number">4.4.</span> <span class="nav-text">如果需要注释一大段代码，不如重构它</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#包的设计"><span class="nav-number">5.</span> <span class="nav-text">包的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一个好的设计应该从包名开始"><span class="nav-number">5.1.</span> <span class="nav-text">一个好的设计应该从包名开始</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#好的包名应该（在项目内）是唯一的"><span class="nav-number">5.1.1.</span> <span class="nav-text">好的包名应该（在项目内）是唯一的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免像base，common或者util这样的包名"><span class="nav-number">5.1.2.</span> <span class="nav-text">避免像base，common或者util这样的包名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应该早点return而不是更深的嵌套"><span class="nav-number">5.2.</span> <span class="nav-text">应该早点return而不是更深的嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用零值"><span class="nav-number">5.3.</span> <span class="nav-text">利用零值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免包级别的状态"><span class="nav-number">5.4.</span> <span class="nav-text">避免包级别的状态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#项目结构"><span class="nav-number">6.</span> <span class="nav-text">项目结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑使用更少但是更大的包"><span class="nav-number">6.1.</span> <span class="nav-text">考虑使用更少但是更大的包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过import语句来组织代码"><span class="nav-number">6.1.1.</span> <span class="nav-text">通过import语句来组织代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多用内部测试，而不是外部测试"><span class="nav-number">6.1.2.</span> <span class="nav-text">多用内部测试，而不是外部测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用internal包来减少开放的API"><span class="nav-number">6.1.3.</span> <span class="nav-text">使用internal包来减少开放的API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让包内的main越小越好"><span class="nav-number">6.2.</span> <span class="nav-text">让包内的main越小越好</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#API设计"><span class="nav-number">7.</span> <span class="nav-text">API设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#将API设计成很难用错"><span class="nav-number">7.1.</span> <span class="nav-text">将API设计成很难用错</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意那些接收几个相同类型参数的函数"><span class="nav-number">7.1.1.</span> <span class="nav-text">注意那些接收几个相同类型参数的函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为默认用例设计API"><span class="nav-number">7.2.</span> <span class="nav-text">为默认用例设计API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#不建议使用nil作为参数"><span class="nav-number">7.2.1.</span> <span class="nav-text">不建议使用nil作为参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推荐使用可变数量参数而不是切片类型"><span class="nav-number">7.2.2.</span> <span class="nav-text">推荐使用可变数量参数而不是切片类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让函数自己定义他们需要的行为"><span class="nav-number">7.2.3.</span> <span class="nav-text">让函数自己定义他们需要的行为</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#错误处理"><span class="nav-number">8.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#检查错误"><span class="nav-number">8.1.</span> <span class="nav-text">检查错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#断言错误的行为特征而不是类型"><span class="nav-number">8.1.1.</span> <span class="nav-text">断言错误的行为特征而不是类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误常量值"><span class="nav-number">8.2.</span> <span class="nav-text">错误常量值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决方案"><span class="nav-number">8.2.1.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过消除错误来消除错误处理"><span class="nav-number">8.3.</span> <span class="nav-text">通过消除错误来消除错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Counting-lines"><span class="nav-number">8.3.1.</span> <span class="nav-text">Counting lines</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WriteResponse"><span class="nav-number">8.3.2.</span> <span class="nav-text">WriteResponse</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#只处理一个错误一次"><span class="nav-number">8.4.</span> <span class="nav-text">只处理一个错误一次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#推荐在错误中加入上下文环境"><span class="nav-number">8.4.1.</span> <span class="nav-text">推荐在错误中加入上下文环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用github-com-pkg-errors包来包装错误"><span class="nav-number">8.4.2.</span> <span class="nav-text">使用github.com/pkg/errors包来包装错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并发"><span class="nav-number">9.</span> <span class="nav-text">并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#让你自己保持忙碌或者自己做工作"><span class="nav-number">9.1.</span> <span class="nav-text">让你自己保持忙碌或者自己做工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#让调用者去做并发"><span class="nav-number">9.2.</span> <span class="nav-text">让调用者去做并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不要启动一个不会停止的协程"><span class="nav-number">9.3.</span> <span class="nav-text">不要启动一个不会停止的协程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">10.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="TomKK"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">TomKK</p>
  <div class="site-description" itemprop="description">学而后知不足</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:tomkklalala@qq.com" title="E-Mail → mailto:tomkklalala@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">TomKK</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://http-tomkklalala-github-io.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://kaiktang.github.io/2018/11/18/Practical-Go-学习心得/";
    this.page.identifier = "2018/11/18/Practical-Go-学习心得/";
    this.page.title = "Practical Go 学习心得";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://http-tomkklalala-github-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
